<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BestHTTP</name>
    </assembly>
    <members>
        <member name="T:BestHTTP.Authentication.AuthenticationTypes">
            <summary>
            Authentication types that supported by BestHTTP.
            The authentication is defined by the server, so the Basic and Digest are not interchangeable. If you don't know what to use, the preferred way is to choose Unknow.
            </summary>
        </member>
        <member name="F:BestHTTP.Authentication.AuthenticationTypes.Unknown">
            <summary>
            If the authentication type is not known this will do a challenge turn to receive what methode should be choosen.
            </summary>
        </member>
        <member name="F:BestHTTP.Authentication.AuthenticationTypes.Basic">
            <summary>
            The most basic authentication type. It's easy to do, and easy to crack. ;)
            </summary>
        </member>
        <member name="F:BestHTTP.Authentication.AuthenticationTypes.Digest">
            <summary>
            
            </summary>
        </member>
        <member name="T:BestHTTP.Authentication.Credentials">
            <summary>
            Hold all information that required to authenticate to a remote server.
            </summary>
        </member>
        <member name="M:BestHTTP.Authentication.Credentials.#ctor(System.String,System.String)">
            <summary>
            Set up the authentication credentials with the username and password. The Type will be set to Unknown.
            </summary>
        </member>
        <member name="M:BestHTTP.Authentication.Credentials.#ctor(BestHTTP.Authentication.AuthenticationTypes,System.String,System.String)">
            <summary>
            Set up the authentication credentials with the given authentication type, username and password.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Credentials.Type">
            <summary>
            The type of the Authentication. If you don't know what to use, the preferred way is to choose Unknow.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Credentials.UserName">
            <summary>
            The username to authenticate on the remote server.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Credentials.Password">
            <summary>
            The password to use in the authentication process. The password will be stored only in this class.
            </summary>
        </member>
        <member name="T:BestHTTP.Authentication.Digest">
            <summary>
            Internal class that stores all information that received from a server in a WWW-Authenticate and need to construct a valid Authorization header. Based on rfc 2617 (http://tools.ietf.org/html/rfc2617).
            Used only internally by the plugin.
            </summary>
        </member>
        <member name="M:BestHTTP.Authentication.Digest.ParseChallange(System.String)">
            <summary>
            Parses a WWW-Authenticate header's value to retrive all information.
            </summary>
        </member>
        <member name="M:BestHTTP.Authentication.Digest.GenerateResponseHeader(BestHTTP.HTTPRequest,BestHTTP.Authentication.Credentials)">
            <summary>
            Generates a string that can be set to an Authorization header.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.Uri">
            <summary>
            The Uri that this Digest is bound to.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.Realm">
            <summary>
            A string to be displayed to users so they know which username and password to use. 
            This string should contain at least the name of the host performing the authentication and might additionally indicate the collection of users who might have access.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.Stale">
            <summary>
            A flag, indicating that the previous request from the client was rejected because the nonce value was stale. 
            If stale is TRUE (case-insensitive), the client may wish to simply retry the request with a new encrypted response, without  the user for a new username and password. 
            The server should only set stale to TRUE if it receives a request for which the nonce is invalid but with a valid digest for that nonce 
            (indicating that the client knows the correct username/password). 
            If stale is FALSE, or anything other than TRUE, or the stale directive is not present, the username and/or password are invalid, and new values must be obtained.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.Nonce">
            <summary>
            A server-specified data string which should be uniquely generated each time a 401 response is made. 
            Specifically, since the string is passed in the header lines as a quoted string, the double-quote character is not allowed.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.Opaque">
            <summary>
            A string of data, specified by the server, which should be returned by the client unchanged in the Authorization header of subsequent requests with URIs in the same protection space. 
            It is recommended that this string be base64 or data.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.Algorithm">
            <summary>
            A string indicating a pair of algorithms used to produce the digest and a checksum. If this is not present it is assumed to be "MD5". 
            If the algorithm is not understood, the challenge should be ignored (and a different one used, if there is more than one).
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.ProtectedUris">
            <summary>
            List of URIs, as specified in RFC XURI, that define the protection space.
            If a URI is an abs_path, it is relative to the canonical root URL (see section 1.2 above) of the server being accessed. 
            An absoluteURI in this list may refer to a different server than the one being accessed.
            The client can use this list to determine the set of URIs for which the same authentication information may be sent: 
            any URI that has a URI in this list as a prefix (after both have been made absolute) may be assumed to be in the same protection space.
            If this directive is omitted or its value is empty, the client should assume that the protection space consists of all URIs on the responding server.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.QualityOfProtections">
            <summary>
            If present, it is a quoted string of one or more tokens indicating the "quality of protection" values supported by the server. 
            The value "auth" indicates authentication. The value "auth-int" indicates authentication with integrity protection.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.NonceCount">
            <summary>
            his MUST be specified if a qop directive is sent (see above), and MUST NOT be specified if the server did not send a qop directive in the WWW-Authenticate header field.
            The nc-value is the hexadecimal count of the number of requests (including the current request) that the client has sent with the nonce value in this request.
            </summary>
        </member>
        <member name="P:BestHTTP.Authentication.Digest.HA1Sess">
            <summary>
            Used to store the last HA1 that can be used in the next header generation when Algorithm is set to "md5-sess".
            </summary>
        </member>
        <member name="T:BestHTTP.Authentication.DigestStore">
            <summary>
            Stores and manages already received digest infos.
            </summary>
        </member>
        <member name="F:BestHTTP.Authentication.DigestStore.SupportedAlgorithms">
            <summary>
            Array of algorithms that the plugin supports. It's in the order of priority(first has the highest priority).
            </summary>
        </member>
        <member name="M:BestHTTP.Authentication.DigestStore.GetOrCreate(System.Uri)">
            <summary>
            It will retrive or create a new Digest for the given Uri.
            </summary>
            <param name="uri"></param>
            <returns></returns>
        </member>
        <member name="T:BestHTTP.Caching.HTTPCacheFileInfo">
            <summary>
            Holds all metadata that need for efficient caching, so we don't need to touch the disk to load headers.
            </summary>
        </member>
        <member name="P:BestHTTP.Caching.HTTPCacheFileInfo.Uri">
            <summary>
            The uri that this HTTPCacheFileInfo belongs to.
            </summary>
        </member>
        <member name="P:BestHTTP.Caching.HTTPCacheFileInfo.LastAccess">
            <summary>
            The last access time to this cache entity. The date is in UTC.
            </summary>
        </member>
        <member name="P:BestHTTP.Caching.HTTPCacheFileInfo.BodyLength">
            <summary>
            The length of the cache entity's body.
            </summary>
        </member>
        <member name="P:BestHTTP.Caching.HTTPCacheFileInfo.ETag">
            <summary>
            ETag of the entity.
            </summary>
        </member>
        <member name="P:BestHTTP.Caching.HTTPCacheFileInfo.LastModified">
            <summary>
            LastModified date of the entity.
            </summary>
        </member>
        <member name="P:BestHTTP.Caching.HTTPCacheFileInfo.Expires">
            <summary>
            When the cache will expire.
            </summary>
        </member>
        <member name="P:BestHTTP.Caching.HTTPCacheFileInfo.Age">
            <summary>
            The age that came with the response
            </summary>
        </member>
        <member name="P:BestHTTP.Caching.HTTPCacheFileInfo.MaxAge">
            <summary>
            Maximum how long the entry should served from the cache without revalidation.
            </summary>
        </member>
        <member name="P:BestHTTP.Caching.HTTPCacheFileInfo.Date">
            <summary>
            The Date that came with the response.
            </summary>
        </member>
        <member name="P:BestHTTP.Caching.HTTPCacheFileInfo.MustRevalidate">
            <summary>
            Indicates whether the entity must be revalidated with the server or can be serverd directly from the cache without touching the server.
            </summary>
        </member>
        <member name="P:BestHTTP.Caching.HTTPCacheFileInfo.Received">
            <summary>
            The date and time when the HTTPResponse received.
            </summary>
        </member>
        <member name="P:BestHTTP.Caching.HTTPCacheFileInfo.ConstructedPath">
            <summary>
            Cached path.
            </summary>
        </member>
        <member name="P:BestHTTP.Caching.HTTPCacheFileInfo.MappedNameIDX">
            <summary>
            This is the index of the enity. Filenames are generated from this value.
            </summary>
        </member>
        <member name="P:BestHTTP.Caching.HTTPCacheMaintananceParams.DeleteOlder">
            <summary>
            Delete cache entries that accessed older then this value. If TimeSpan.FromSeconds(0) is used then all cache entries will be deleted. With TimeSpan.FromDays(2) entries that older then two days will be deleted.
            </summary>
        </member>
        <member name="P:BestHTTP.Caching.HTTPCacheMaintananceParams.MaxCacheSize">
            <summary>
            If the cache is larger then the MaxCacheSize after the first maintanance step, then the maintanance job will forcedelete cache entries starting with the oldest last accessed one.
            </summary>
        </member>
        <member name="F:BestHTTP.Caching.HTTPCacheService.LibraryVersion">
            <summary>
            Library file-format versioning support
            </summary>
        </member>
        <member name="F:BestHTTP.Caching.HTTPCacheService.NextNameIDX">
            <summary>
            Stores the index of the next stored entity. The entity's file name is generated from this index.
            </summary>
        </member>
        <member name="M:BestHTTP.Caching.HTTPCacheService.SetHeaders(BestHTTP.HTTPRequest)">
            <summary>
            Utility function to set the cache control headers according to the spec.: http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.3.4
            </summary>
            <param name="request"></param>
        </member>
        <member name="M:BestHTTP.Caching.HTTPCacheService.IsCacheble(System.Uri,BestHTTP.HTTPMethods,BestHTTP.HTTPResponse)">
            <summary>
            Checks if the given response can be cached. http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.4
            </summary>
            <returns>Returns true if cacheable, false otherwise.</returns>
        </member>
        <member name="M:BestHTTP.Caching.HTTPCacheService.BeginClear">
            <summary>
            Deletes all cache entity. Non blocking.
            <remarks>Call it only if there no requests currently processed, becouse cache entries can be deleted while a server sends back a 304 result, so there will be no data to read from the cache!</remarks>
            </summary>
        </member>
        <member name="M:BestHTTP.Caching.HTTPCacheService.BeginMaintainence(BestHTTP.Caching.HTTPCacheMaintananceParams)">
            <summary>
            Deletes all expired cache entity.
            <remarks>Call it only if there no requests currently processed, becouse cache entries can be deleted while a server sends back a 304 result, so there will be no data to read from the cache!</remarks>
            </summary>
        </member>
        <member name="M:BestHTTP.Caching.HTTPCacheService.DeleteUnusedFiles">
            <summary>
            Deletes all files from the cache folder that isn't in the Library.
            </summary>
        </member>
        <member name="P:BestHTTP.ConnectionBase.ServerAddress">
            <summary>
            The address of the server that this connection is bound to.
            </summary>
        </member>
        <member name="P:BestHTTP.ConnectionBase.State">
            <summary>
            The state of this connection.
            </summary>
        </member>
        <member name="P:BestHTTP.ConnectionBase.IsFree">
            <summary>
            It's true if this connection is available to process a HTTPRequest.
            </summary>
        </member>
        <member name="P:BestHTTP.ConnectionBase.IsActive">
            <summary>
            Returns true if it's an active connection.
            </summary>
        </member>
        <member name="P:BestHTTP.ConnectionBase.CurrentRequest">
            <summary>
            If the State is HTTPConnectionStates.Processing, then it holds a HTTPRequest instance. Otherwise it's null.
            </summary>
        </member>
        <member name="P:BestHTTP.ConnectionBase.StartTime">
            <summary>
            When we start to process the current request. It's set after the connection is estabilished.
            </summary>
        </member>
        <member name="P:BestHTTP.ConnectionBase.TimedOutStart">
            <summary>
            When this connection timed out.
            </summary>
        </member>
        <member name="T:BestHTTP.Cookies.Cookie">
            <summary>
            The Cookie implementation based on RFC 6265(http://tools.ietf.org/html/rfc6265).
            </summary>
        </member>
        <member name="M:BestHTTP.Cookies.Cookie.GuessSize">
            <summary>
            Guess the storage size of the cookie.
            </summary>
            <returns></returns>
        </member>
        <member name="P:BestHTTP.Cookies.Cookie.Name">
            <summary>
            The name of the cookie.
            </summary>
        </member>
        <member name="P:BestHTTP.Cookies.Cookie.Value">
            <summary>
            The value of the cookie.
            </summary>
        </member>
        <member name="P:BestHTTP.Cookies.Cookie.Date">
            <summary>
            The Data when the Cookie is registered.
            </summary>
        </member>
        <member name="P:BestHTTP.Cookies.Cookie.LastAccess">
            <summary>
            When this Cookie last used in a request.
            </summary>
        </member>
        <member name="P:BestHTTP.Cookies.Cookie.Expires">
            <summary>
            The Expires attribute indicates the maximum lifetime of the cookie, represented as the date and time at which the cookie expires. 
            The user agent is not required to retain the cookie until the specified date has passed. 
            In fact, user agents often evict cookies due to memory pressure or privacy concerns.
            </summary>
        </member>
        <member name="P:BestHTTP.Cookies.Cookie.MaxAge">
            <summary>
            The Max-Age attribute indicates the maximum lifetime of the cookie, represented as the number of seconds until the cookie expires. 
            The user agent is not required to retain the cookie for the specified duration.
            In fact, user agents often evict cookies due to memory pressure or privacy concerns.
            </summary>
        </member>
        <member name="P:BestHTTP.Cookies.Cookie.IsSession">
            <summary>
            If a cookie has neither the Max-Age nor the Expires attribute, the user agent will retain the cookie until "the current session is over".
            </summary>
        </member>
        <member name="P:BestHTTP.Cookies.Cookie.Domain">
            <summary>
            The Domain attribute specifies those hosts to which the cookie will be sent.
            For example, if the value of the Domain attribute is "example.com", the user agent will include the cookie
            in the Cookie header when making HTTP requests to example.com, www.example.com, and www.corp.example.com.
            If the server omits the Domain attribute, the user agent will return the cookie only to the origin server.
            </summary>
        </member>
        <member name="P:BestHTTP.Cookies.Cookie.Path">
            <summary>
            The scope of each cookie is limited to a set of paths, controlled by the Path attribute.
            If the server omits the Path attribute, the user agent will use the "directory" of the request-uri's path component as the default value.
            </summary>
        </member>
        <member name="P:BestHTTP.Cookies.Cookie.IsSecure">
            <summary>
            The Secure attribute limits the scope of the cookie to "secure" channels (where "secure" is defined by the user agent).
            When a cookie has the Secure attribute, the user agent will include the cookie in an HTTP request only if the request is 
            transmitted over a secure channel (typically HTTP over Transport Layer Security (TLS)).
            </summary>
        </member>
        <member name="P:BestHTTP.Cookies.Cookie.IsHttpOnly">
            <summary>
            The HttpOnly attribute limits the scope of the cookie to HTTP requests.
            In particular, the attribute instructs the user agent to omit the cookie when providing access to
            cookies via "non-HTTP" APIs (such as a web browser API that exposes cookies to scripts).
            </summary>
        </member>
        <member name="T:BestHTTP.Cookies.CookieJar">
            <summary>
            The Cookie Jar implementation based on RFC 6265(http://tools.ietf.org/html/rfc6265).
            </summary>
        </member>
        <member name="F:BestHTTP.Cookies.CookieJar.Cookies">
            <summary>
            List of the Cookies
            </summary>
        </member>
        <member name="F:BestHTTP.Cookies.CookieJar.Locker">
            <summary>
            Synchronization object for thread safety.
            </summary>
        </member>
        <member name="M:BestHTTP.Cookies.CookieJar.Set(BestHTTP.HTTPResponse)">
            <summary>
            Will set or update all cookies from the response object.
            </summary>
        </member>
        <member name="M:BestHTTP.Cookies.CookieJar.Maintain">
            <summary>
            Deletes all expired or 'old' cookies, and will keep the sum size of cookies under the given size.
            </summary>
        </member>
        <member name="M:BestHTTP.Cookies.CookieJar.Persist">
            <summary>
            Saves the Cookie Jar to a file.
            </summary>
            <remarks>Not implemented under Unity WebPlayer</remarks>
        </member>
        <member name="M:BestHTTP.Cookies.CookieJar.Load">
            <summary>
            Load previously persisted cooki library from the file.
            </summary>
        </member>
        <member name="M:BestHTTP.Cookies.CookieJar.Get(System.Uri)">
            <summary>
            Returns all Cookies that corresponds to the given Uri.
            </summary>
        </member>
        <member name="M:BestHTTP.Cookies.CookieJar.Set(System.Uri,BestHTTP.Cookies.Cookie)">
            <summary>
            Will add a new, or overwrite an old cookie if already exists.
            </summary>
        </member>
        <member name="M:BestHTTP.Cookies.CookieJar.Clear">
            <summary>
            Deletes all cookies from the Jar.
            </summary>
        </member>
        <member name="M:BestHTTP.Cookies.CookieJar.Clear(System.TimeSpan)">
            <summary>
            Removes cookies that older than the given parameter.
            </summary>
        </member>
        <member name="M:BestHTTP.Cookies.CookieJar.Clear(System.String)">
            <summary>
            Removes cookies that matches to the given domain.
            </summary>
        </member>
        <member name="M:BestHTTP.Cookies.CookieJar.Find(BestHTTP.Cookies.Cookie,System.Int32@)">
            <summary>
            Find and return a Cookie and his index in the list.
            </summary>
        </member>
        <member name="P:BestHTTP.Cookies.CookieJar.IsSavingSupported">
            <summary>
            Returns true if File apis are supported.
            </summary>
        </member>
        <member name="T:BestHTTP.Decompression.Crc.CRC32">
            <summary>
              Computes a CRC-32. The CRC-32 algorithm is parameterized - you
              can set the polynomial and enable or disable bit
              reversal. This can be used for GZIP, BZip2, or ZIP.
            </summary>
            <remarks>
              This type is used internally by DotNetZip; it is generally not used
              directly by applications wishing to create, read, or manipulate zip
              archive files.
            </remarks>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.GetCrc32(System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.GetCrc32AndCopy(System.IO.Stream,System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream, and writes the input into the
            output stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <param name="output">The stream into which to deflate the input</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.ComputeCrc32(System.Int32,System.Byte)">
            <summary>
              Get the CRC32 for the given (word,byte) combo.  This is a
              computation defined by PKzip for PKZIP 2.0 (weak) encryption.
            </summary>
            <param name="W">The word to start with.</param>
            <param name="B">The byte to combine it with.</param>
            <returns>The CRC-ized result.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.SlurpBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the value for the running CRC32 using the given block of bytes.
            This is useful when using the CRC32() class in a Stream.
            </summary>
            <param name="block">block of bytes to slurp</param>
            <param name="offset">starting point in the block</param>
            <param name="count">how many bytes within the block to slurp</param>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.UpdateCRC(System.Byte)">
            <summary>
              Process one byte in the CRC.
            </summary>
            <param name = "b">the byte to include into the CRC .  </param>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.UpdateCRC(System.Byte,System.Int32)">
            <summary>
              Process a run of N identical bytes into the CRC.
            </summary>
            <remarks>
              <para>
                This method serves as an optimization for updating the CRC when a
                run of identical bytes is found. Rather than passing in a buffer of
                length n, containing all identical bytes b, this method accepts the
                byte value and the length of the (virtual) buffer - the length of
                the run.
              </para>
            </remarks>
            <param name = "b">the byte to include into the CRC.  </param>
            <param name = "n">the number of times that byte should be repeated. </param>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.Combine(System.Int32,System.Int32)">
            <summary>
              Combines the given CRC32 value with the current running total.
            </summary>
            <remarks>
              This is useful when using a divide-and-conquer approach to
              calculating a CRC.  Multiple threads can each calculate a
              CRC32 on a segment of the data, and then combine the
              individual CRC32 values at the end.
            </remarks>
            <param name="crc">the crc value to be combined with this one</param>
            <param name="length">the length of data the CRC value was calculated on</param>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.#ctor">
            <summary>
              Create an instance of the CRC32 class using the default settings: no
              bit reversal, and a polynomial of 0xEDB88320.
            </summary>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.#ctor(System.Boolean)">
            <summary>
              Create an instance of the CRC32 class, specifying whether to reverse
              data bits or not.
            </summary>
            <param name='reverseBits'>
              specify true if the instance should reverse data bits.
            </param>
            <remarks>
              <para>
                In the CRC-32 used by BZip2, the bits are reversed. Therefore if you
                want a CRC32 with compatibility with BZip2, you should pass true
                here. In the CRC-32 used by GZIP and PKZIP, the bits are not
                reversed; Therefore if you want a CRC32 with compatibility with
                those, you should pass false.
              </para>
            </remarks>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.#ctor(System.Int32,System.Boolean)">
             <summary>
               Create an instance of the CRC32 class, specifying the polynomial and
               whether to reverse data bits or not.
             </summary>
             <param name='polynomial'>
               The polynomial to use for the CRC, expressed in the reversed (LSB)
               format: the highest ordered bit in the polynomial value is the
               coefficient of the 0th power; the second-highest order bit is the
               coefficient of the 1 power, and so on. Expressed this way, the
               polynomial for the CRC-32C used in IEEE 802.3, is 0xEDB88320.
             </param>
             <param name='reverseBits'>
               specify true if the instance should reverse data bits.
             </param>
            
             <remarks>
               <para>
                 In the CRC-32 used by BZip2, the bits are reversed. Therefore if you
                 want a CRC32 with compatibility with BZip2, you should pass true
                 here for the <c>reverseBits</c> parameter. In the CRC-32 used by
                 GZIP and PKZIP, the bits are not reversed; Therefore if you want a
                 CRC32 with compatibility with those, you should pass false for the
                 <c>reverseBits</c> parameter.
               </para>
             </remarks>
        </member>
        <member name="M:BestHTTP.Decompression.Crc.CRC32.Reset">
            <summary>
              Reset the CRC-32 class - clear the CRC "remainder register."
            </summary>
            <remarks>
              <para>
                Use this when employing a single instance of this class to compute
                multiple, distinct CRCs on multiple, distinct data blocks.
              </para>
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Crc.CRC32.TotalBytesRead">
            <summary>
              Indicates the total number of bytes applied to the CRC.
            </summary>
        </member>
        <member name="P:BestHTTP.Decompression.Crc.CRC32.Crc32Result">
            <summary>
            Indicates the current CRC for all blocks slurped in.
            </summary>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.DeflateStream">
             <summary>
             A class for compressing and decompressing streams using the Deflate algorithm.
             </summary>
            
             <remarks>
            
             <para>
               The DeflateStream is a <see href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a <see cref="T:System.IO.Stream"/>.  It adds DEFLATE compression or decompression to any
               stream.
             </para>
            
             <para>
               Using this stream, applications can compress or decompress data via stream
               <c>Read</c> and <c>Write</c> operations.  Either compresssion or decompression
               can occur through either reading or writing. The compression format used is
               DEFLATE, which is documented in <see href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC 1951</see>, "DEFLATE
               Compressed Data Format Specification version 1.3.".
             </para>
            
             </remarks>
            
             <seealso cref="T:BestHTTP.Decompression.Zlib.GZipStream"/>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode)">
             <summary>
               Create a DeflateStream using the specified CompressionMode.
             </summary>
            
             <remarks>
               When mode is <c>CompressionMode.Compress</c>, the DeflateStream will use
               the default compression level. The "captive" stream will be closed when
               the DeflateStream is closed.
             </remarks>
            
             <example>
             This example uses a DeflateStream to compress data from a file, and writes
             the compressed data to another file.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".deflated"))
                 {
                     using (Stream compressor = new DeflateStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".deflated")
                     Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode,BestHTTP.Decompression.Zlib.CompressionLevel)">
             <summary>
             Create a DeflateStream using the specified CompressionMode and the specified CompressionLevel.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is
               ignored.  The "captive" stream will be closed when the DeflateStream is
               closed.
             </para>
            
             </remarks>
            
             <example>
            
               This example uses a DeflateStream to compress data from a file, and writes
               the compressed data to another file.
            
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".deflated"))
                 {
                     using (Stream compressor = new DeflateStream(raw,
                                                                  CompressionMode.Compress,
                                                                  CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n= -1;
                         while (n != 0)
                         {
                             if (n &gt; 0)
                                 compressor.Write(buffer, 0, n);
                             n= input.Read(buffer, 0, buffer.Length);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".deflated")
                     Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to be read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the <c>DeflateStream</c> will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode,System.Boolean)">
             <summary>
               Create a <c>DeflateStream</c> using the specified
               <c>CompressionMode</c>, and explicitly specify whether the
               stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compression.  Specify true for
               the <paramref name="leaveOpen"/> parameter to leave the stream open.
             </para>
            
             <para>
               The <c>DeflateStream</c> will use the default compression level.
             </para>
            
             <para>
               See the other overloads of this constructor for example code.
             </para>
             </remarks>
            
             <param name="stream">
               The stream which will be read or written. This is called the
               "captive" stream in other places in this documentation.
             </param>
            
             <param name="mode">
               Indicates whether the <c>DeflateStream</c> will compress or decompress.
             </param>
            
             <param name="leaveOpen">true if the application would like the stream to
             remain open after inflation/deflation.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode,BestHTTP.Decompression.Zlib.CompressionLevel,System.Boolean)">
             <summary>
               Create a <c>DeflateStream</c> using the specified <c>CompressionMode</c>
               and the specified <c>CompressionLevel</c>, and explicitly specify whether
               the stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is ignored.
             </para>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               <see cref="T:System.IO.MemoryStream"/> that will be re-read after
               compression.  Specify true for the <paramref name="leaveOpen"/> parameter
               to leave the stream open.
             </para>
            
             </remarks>
            
             <example>
            
               This example shows how to use a <c>DeflateStream</c> to compress data from
               a file, and store the compressed data into another file.
            
             <code>
             using (var output = System.IO.File.Create(fileToCompress + ".deflated"))
             {
                 using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
                 {
                     using (Stream compressor = new DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n= -1;
                         while (n != 0)
                         {
                             if (n &gt; 0)
                                 compressor.Write(buffer, 0, n);
                             n= input.Read(buffer, 0, buffer.Length);
                         }
                     }
                 }
                 // can write additional data to the output stream here
             }
             </code>
            
             <code lang="VB">
             Using output As FileStream = File.Create(fileToCompress &amp; ".deflated")
                 Using input As Stream = File.OpenRead(fileToCompress)
                     Using compressor As Stream = New DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
                 ' can write additional data to the output stream here.
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <remarks>
              <para>
                This may or may not result in a <c>Close()</c> call on the captive
                stream.  See the constructors that have a <c>leaveOpen</c> parameter
                for more information.
              </para>
              <para>
                Application code won't call this code directly.  This method may be
                invoked in two distinct scenarios.  If disposing == true, the method
                has been called directly or indirectly by a user's code, for example
                via the public Dispose() method. In this case, both managed and
                unmanaged resources can be referenced and disposed.  If disposing ==
                false, the method has been called by the runtime from inside the
                object finalizer and this method should not reference other objects;
                in that case only unmanaged resources must be referenced or
                disposed.
              </para>
            </remarks>
            <param name="disposing">
              true if the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Read data from the stream.
             </summary>
             <remarks>
            
             <para>
               If you wish to use the <c>DeflateStream</c> to compress data while
               reading, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Compress</c>, providing an uncompressed data stream.
               Then call Read() on that <c>DeflateStream</c>, and the data read will be
               compressed as you read.  If you wish to use the <c>DeflateStream</c> to
               decompress data while reading, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Decompress</c>, providing a readable compressed data
               stream.  Then call Read() on that <c>DeflateStream</c>, and the data read
               will be decompressed as you read.
             </para>
            
             <para>
               A <c>DeflateStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not both.
             </para>
            
             </remarks>
             <param name="buffer">The buffer into which the read data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">this is irrelevant, since it will always throw!</param>
            <param name="origin">this is irrelevant, since it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">this is irrelevant, since it will always throw!</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
             <remarks>
            
             <para>
               If you wish to use the <c>DeflateStream</c> to compress data while
               writing, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Compress</c>, and a writable output stream.  Then call
               <c>Write()</c> on that <c>DeflateStream</c>, providing uncompressed data
               as input.  The data sent to the output stream will be the compressed form
               of the data written.  If you wish to use the <c>DeflateStream</c> to
               decompress data while writing, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Decompress</c>, and a writable output stream.  Then
               call <c>Write()</c> on that stream, providing previously compressed
               data. The data sent to the output stream will be the decompressed form of
               the data written.
             </para>
            
             <para>
               A <c>DeflateStream</c> can be used for <c>Read()</c> or <c>Write()</c>,
               but not both.
             </para>
            
             </remarks>
            
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.CompressString(System.String)">
             <summary>
               Compress a string into a byte array using DEFLATE (RFC 1951).
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:BestHTTP.Decompression.Zlib.DeflateStream.UncompressString(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:BestHTTP.Decompression.Zlib.DeflateStream.UncompressString(System.Byte[])">DeflateStream.UncompressString(byte[])</seealso>
             <seealso cref="M:BestHTTP.Decompression.Zlib.DeflateStream.CompressBuffer(System.Byte[])">DeflateStream.CompressBuffer(byte[])</seealso>
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.CompressString(System.String)">GZipStream.CompressString(string)</seealso>
            
             <param name="s">
               A string to compress. The string will first be encoded
               using UTF8, then compressed.
             </param>
            
             <returns>The string in compressed form</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.CompressBuffer(System.Byte[])">
             <summary>
               Compress a byte array into a new byte array using DEFLATE.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:BestHTTP.Decompression.Zlib.DeflateStream.UncompressBuffer(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:BestHTTP.Decompression.Zlib.DeflateStream.CompressString(System.String)">DeflateStream.CompressString(string)</seealso>
             <seealso cref="M:BestHTTP.Decompression.Zlib.DeflateStream.UncompressBuffer(System.Byte[])">DeflateStream.UncompressBuffer(byte[])</seealso>
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.CompressBuffer(System.Byte[])">GZipStream.CompressBuffer(byte[])</seealso>
            
             <param name="b">
               A buffer to compress.
             </param>
            
             <returns>The data in compressed form</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.UncompressString(System.Byte[])">
             <summary>
               Uncompress a DEFLATE'd byte array into a single string.
             </summary>
            
             <seealso cref="M:BestHTTP.Decompression.Zlib.DeflateStream.CompressString(System.String)">DeflateStream.CompressString(String)</seealso>
             <seealso cref="M:BestHTTP.Decompression.Zlib.DeflateStream.UncompressBuffer(System.Byte[])">DeflateStream.UncompressBuffer(byte[])</seealso>
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressString(System.Byte[])">GZipStream.UncompressString(byte[])</seealso>
            
             <param name="compressed">
               A buffer containing DEFLATE-compressed data.
             </param>
            
             <returns>The uncompressed string</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.DeflateStream.UncompressBuffer(System.Byte[])">
             <summary>
               Uncompress a DEFLATE'd byte array into a byte array.
             </summary>
            
             <seealso cref="M:BestHTTP.Decompression.Zlib.DeflateStream.CompressBuffer(System.Byte[])">DeflateStream.CompressBuffer(byte[])</seealso>
             <seealso cref="M:BestHTTP.Decompression.Zlib.DeflateStream.UncompressString(System.Byte[])">DeflateStream.UncompressString(byte[])</seealso>
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressBuffer(System.Byte[])">GZipStream.UncompressBuffer(byte[])</seealso>
            
             <param name="compressed">
               A buffer containing data that has been compressed with DEFLATE.
             </param>
            
             <returns>The data in uncompressed form</returns>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            </summary>
            <remarks> See the ZLIB documentation for the meaning of the flush behavior.
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.BufferSize">
             <summary>
               The size of the working buffer for the compression codec.
             </summary>
            
             <remarks>
             <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes.  The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
            
             <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.Strategy">
             <summary>
               The ZLIB strategy to be used during compression.
             </summary>
            
             <remarks>
               By tweaking this parameter, you may be able to optimize the compression for
               data with particular characteristics.
             </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.DeflateStream.Position">
             <summary>
             The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see cref="T:System.NotImplementedException"/>. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.GZipStream">
             <summary>
               A class for compressing and decompressing GZIP streams.
             </summary>
             <remarks>
            
             <para>
               The <c>GZipStream</c> is a <see href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a
               <see cref="T:System.IO.Stream"/>. It adds GZIP compression or decompression to any
               stream.
             </para>
            
             <para>
               Like the <c>System.IO.Compression.GZipStream</c> in the .NET Base Class Library, the
               <c>Ionic.Zlib.GZipStream</c> can compress while writing, or decompress while
               reading, but not vice versa.  The compression method used is GZIP, which is
               documented in <see href="http://www.ietf.org/rfc/rfc1952.txt">IETF RFC
               1952</see>, "GZIP file format specification version 4.3".</para>
            
             <para>
               A <c>GZipStream</c> can be used to decompress data (through <c>Read()</c>) or
               to compress data (through <c>Write()</c>), but not both.
             </para>
            
             <para>
               If you wish to use the <c>GZipStream</c> to compress data, you must wrap it
               around a write-able stream. As you call <c>Write()</c> on the <c>GZipStream</c>, the
               data will be compressed into the GZIP format.  If you want to decompress data,
               you must wrap the <c>GZipStream</c> around a readable stream that contains an
               IETF RFC 1952-compliant stream.  The data will be decompressed as you call
               <c>Read()</c> on the <c>GZipStream</c>.
             </para>
            
             <para>
               Though the GZIP format allows data from multiple files to be concatenated
               together, this stream handles only a single segment of GZIP format, typically
               representing a single file.
             </para>
            
             </remarks>
            
             <seealso cref="T:BestHTTP.Decompression.Zlib.DeflateStream"/>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.GZipStream.LastModified">
             <summary>
               The last modified time for the GZIP stream.
             </summary>
            
             <remarks>
               GZIP allows the storage of a last modified time with each GZIP entity.
               When compressing data, you can set this before the first call to
               <c>Write()</c>.  When decompressing, you can retrieve this value any time
               after the first call to <c>Read()</c>.
             </remarks>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c>.
             </summary>
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Compress</c>, the <c>GZipStream</c> will use the
               default compression level.
             </para>
            
             <para>
               As noted in the class documentation, the <c>CompressionMode</c> (Compress
               or Decompress) also establishes the "direction" of the stream.  A
               <c>GZipStream</c> with <c>CompressionMode.Compress</c> works only through
               <c>Write()</c>.  A <c>GZipStream</c> with
               <c>CompressionMode.Decompress</c> works only through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
               This example shows how to use a GZipStream to compress data.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new GZipStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                 Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
            
             <example>
             This example shows how to use a GZipStream to uncompress a file.
             <code>
             private void GunZipFile(string filename)
             {
                 if (!filename.EndsWith(".gz))
                     throw new ArgumentException("filename");
                 var DecompressedFile = filename.Substring(0,filename.Length-3);
                 byte[] working = new byte[WORKING_BUFFER_SIZE];
                 int n= 1;
                 using (System.IO.Stream input = System.IO.File.OpenRead(filename))
                 {
                     using (Stream decompressor= new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, true))
                     {
                         using (var output = System.IO.File.Create(DecompressedFile))
                         {
                             while (n !=0)
                             {
                                 n= decompressor.Read(working, 0, working.Length);
                                 if (n > 0)
                                 {
                                     output.Write(working, 0, n);
                                 }
                             }
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Private Sub GunZipFile(ByVal filename as String)
                 If Not (filename.EndsWith(".gz)) Then
                     Throw New ArgumentException("filename")
                 End If
                 Dim DecompressedFile as String = filename.Substring(0,filename.Length-3)
                 Dim working(WORKING_BUFFER_SIZE) as Byte
                 Dim n As Integer = 1
                 Using input As Stream = File.OpenRead(filename)
                     Using decompressor As Stream = new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, True)
                         Using output As Stream = File.Create(UncompressedFile)
                             Do
                                 n= decompressor.Read(working, 0, working.Length)
                                 If n > 0 Then
                                     output.Write(working, 0, n)
                                 End IF
                             Loop While (n  > 0)
                         End Using
                     End Using
                 End Using
             End Sub
             </code>
             </example>
            
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode,BestHTTP.Decompression.Zlib.CompressionLevel)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c> and
               the specified <c>CompressionLevel</c>.
             </summary>
             <remarks>
            
             <para>
               The <c>CompressionMode</c> (Compress or Decompress) also establishes the
               "direction" of the stream.  A <c>GZipStream</c> with
               <c>CompressionMode.Compress</c> works only through <c>Write()</c>.  A
               <c>GZipStream</c> with <c>CompressionMode.Decompress</c> works only
               through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
            
             This example shows how to use a <c>GZipStream</c> to compress a file into a .gz file.
            
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".gz"))
                 {
                     using (Stream compressor = new GZipStream(raw,
                                                               CompressionMode.Compress,
                                                               CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".gz")
                     Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to be read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the <c>GZipStream</c> will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode,System.Boolean)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c>, and
               explicitly specify whether the stream should be left open after Deflation
               or Inflation.
             </summary>
            
             <remarks>
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compressed data has been written
               to it.  Specify true for the <paramref name="leaveOpen"/> parameter to leave
               the stream open.
             </para>
            
             <para>
               The <see cref="T:BestHTTP.Decompression.Zlib.CompressionMode"/> (Compress or Decompress) also
               establishes the "direction" of the stream.  A <c>GZipStream</c> with
               <c>CompressionMode.Compress</c> works only through <c>Write()</c>.  A <c>GZipStream</c>
               with <c>CompressionMode.Decompress</c> works only through <c>Read()</c>.
             </para>
            
             <para>
               The <c>GZipStream</c> will use the default compression level. If you want
               to specify the compression level, see <see cref="M:BestHTTP.Decompression.Zlib.GZipStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode,BestHTTP.Decompression.Zlib.CompressionLevel,System.Boolean)"/>.
             </para>
            
             <para>
               See the other overloads of this constructor for example code.
             </para>
            
             </remarks>
            
             <param name="stream">
               The stream which will be read or written. This is called the "captive"
               stream in other places in this documentation.
             </param>
            
             <param name="mode">Indicates whether the GZipStream will compress or decompress.
             </param>
            
             <param name="leaveOpen">
               true if the application would like the base stream to remain open after
               inflation/deflation.
             </param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.#ctor(System.IO.Stream,BestHTTP.Decompression.Zlib.CompressionMode,BestHTTP.Decompression.Zlib.CompressionLevel,System.Boolean)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c> and the
               specified <c>CompressionLevel</c>, and explicitly specify whether the
               stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compressed data has been written
               to it.  Specify true for the <paramref name="leaveOpen"/> parameter to
               leave the stream open.
             </para>
            
             <para>
               As noted in the class documentation, the <c>CompressionMode</c> (Compress
               or Decompress) also establishes the "direction" of the stream.  A
               <c>GZipStream</c> with <c>CompressionMode.Compress</c> works only through
               <c>Write()</c>.  A <c>GZipStream</c> with <c>CompressionMode.Decompress</c> works only
               through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
               This example shows how to use a <c>GZipStream</c> to compress data.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                 Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <remarks>
              <para>
                This may or may not result in a <c>Close()</c> call on the captive
                stream.  See the constructors that have a <c>leaveOpen</c> parameter
                for more information.
              </para>
              <para>
                This method may be invoked in two distinct scenarios.  If disposing
                == true, the method has been called directly or indirectly by a
                user's code, for example via the public Dispose() method. In this
                case, both managed and unmanaged resources can be referenced and
                disposed.  If disposing == false, the method has been called by the
                runtime from inside the object finalizer and this method should not
                reference other objects; in that case only unmanaged resources must
                be referenced or disposed.
              </para>
            </remarks>
            <param name="disposing">
              indicates whether the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Read and decompress data from the source stream.
             </summary>
            
             <remarks>
               With a <c>GZipStream</c>, decompression is done through reading.
             </remarks>
            
             <example>
             <code>
             byte[] working = new byte[WORKING_BUFFER_SIZE];
             using (System.IO.Stream input = System.IO.File.OpenRead(_CompressedFile))
             {
                 using (Stream decompressor= new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, true))
                 {
                     using (var output = System.IO.File.Create(_DecompressedFile))
                     {
                         int n;
                         while ((n= decompressor.Read(working, 0, working.Length)) !=0)
                         {
                             output.Write(working, 0, n);
                         }
                     }
                 }
             }
             </code>
             </example>
             <param name="buffer">The buffer into which the decompressed data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">irrelevant; it will always throw!</param>
            <param name="origin">irrelevant; it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.SetLength(System.Int64)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">irrelevant; this method will always throw!</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
            
             <remarks>
             <para>
               If you wish to use the <c>GZipStream</c> to compress data while writing,
               you can create a <c>GZipStream</c> with <c>CompressionMode.Compress</c>, and a
               writable output stream.  Then call <c>Write()</c> on that <c>GZipStream</c>,
               providing uncompressed data as input.  The data sent to the output stream
               will be the compressed form of the data written.
             </para>
            
             <para>
               A <c>GZipStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not
               both. Writing implies compression.  Reading implies decompression.
             </para>
            
             </remarks>
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.CompressString(System.String)">
             <summary>
               Compress a string into a byte array using GZip.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressString(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressString(System.Byte[])"/>
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.CompressBuffer(System.Byte[])"/>
            
             <param name="s">
               A string to compress. The string will first be encoded
               using UTF8, then compressed.
             </param>
            
             <returns>The string in compressed form</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.CompressBuffer(System.Byte[])">
             <summary>
               Compress a byte array into a new byte array using GZip.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.CompressString(System.String)"/>
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="b">
               A buffer to compress.
             </param>
            
             <returns>The data in compressed form</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressString(System.Byte[])">
             <summary>
               Uncompress a GZip'ed byte array into a single string.
             </summary>
            
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.CompressString(System.String)"/>
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing GZIP-compressed data.
             </param>
            
             <returns>The uncompressed string</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressBuffer(System.Byte[])">
             <summary>
               Uncompress a GZip'ed byte array into a byte array.
             </summary>
            
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.CompressBuffer(System.Byte[])"/>
             <seealso cref="M:BestHTTP.Decompression.Zlib.GZipStream.UncompressString(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing data that has been compressed with GZip.
             </param>
            
             <returns>The data in uncompressed form</returns>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.Comment">
             <summary>
               The comment on the GZIP stream.
             </summary>
            
             <remarks>
             <para>
               The GZIP format allows for each file to optionally have an associated
               comment stored with the file.  The comment is encoded with the ISO-8859-1
               code page.  To include a comment in a GZIP stream you create, set this
               property before calling <c>Write()</c> for the first time on the
               <c>GZipStream</c>.
             </para>
            
             <para>
               When using <c>GZipStream</c> to decompress, you can retrieve this property
               after the first call to <c>Read()</c>.  If no comment has been set in the
               GZIP bytestream, the Comment property will return <c>null</c>
               (<c>Nothing</c> in VB).
             </para>
             </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.FileName">
             <summary>
               The FileName for the GZIP stream.
             </summary>
            
             <remarks>
            
             <para>
               The GZIP format optionally allows each file to have an associated
               filename.  When compressing data (through <c>Write()</c>), set this
               FileName before calling <c>Write()</c> the first time on the <c>GZipStream</c>.
               The actual filename is encoded into the GZIP bytestream with the
               ISO-8859-1 code page, according to RFC 1952. It is the application's
               responsibility to insure that the FileName can be encoded and decoded
               correctly with this code page.
             </para>
            
             <para>
               When decompressing (through <c>Read()</c>), you can retrieve this value
               any time after the first <c>Read()</c>.  In the case where there was no filename
               encoded into the GZIP bytestream, the property will return <c>null</c> (<c>Nothing</c>
               in VB).
             </para>
             </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.Crc32">
            <summary>
            The CRC on the GZIP stream.
            </summary>
            <remarks>
            This is used for internal error checking. You probably don't need to look at this property.
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            </summary>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.BufferSize">
             <summary>
               The size of the working buffer for the compression codec.
             </summary>
            
             <remarks>
             <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes.  The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
            
             <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.GZipStream.Position">
             <summary>
               The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see cref="T:System.NotImplementedException"/>. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.FlushType">
            <summary>
            Describes how to flush the current deflate operation.
            </summary>
            <remarks>
            The different FlushType values are useful when using a Deflate in a streaming application.
            </remarks>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.FlushType.None">
            <summary>No flush at all.</summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.FlushType.Partial">
            <summary>Closes the current block, but doesn't flush it to
            the output. Used internally only in hypothetical
            scenarios.  This was supposed to be removed by Zlib, but it is
            still in use in some edge cases.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.FlushType.Sync">
            <summary>
            Use this during compression to specify that all pending output should be
            flushed to the output buffer and the output should be aligned on a byte
            boundary.  You might use this in a streaming communication scenario, so that
            the decompressor can get all input data available so far.  When using this
            with a ZlibCodec, <c>AvailableBytesIn</c> will be zero after the call if
            enough output space has been provided before the call.  Flushing will
            degrade compression and so it should be used only when necessary.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.FlushType.Full">
            <summary>
            Use this during compression to specify that all output should be flushed, as
            with <c>FlushType.Sync</c>, but also, the compression state should be reset
            so that decompression can restart from this point if previous compressed
            data has been damaged or if random access is desired.  Using
            <c>FlushType.Full</c> too often can significantly degrade the compression.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.FlushType.Finish">
            <summary>Signals the end of the compression/decompression stream.</summary>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.CompressionLevel">
            <summary>
            The compression level to be used when using a DeflateStream or ZlibStream with CompressionMode.Compress.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.None">
            <summary>
            None means that the data will be simply stored, with no change at all.
            If you are producing ZIPs for use on Mac OSX, be aware that archives produced with CompressionLevel.None
            cannot be opened with the default zip reader. Use a different CompressionLevel.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level0">
            <summary>
            Same as None.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.BestSpeed">
            <summary>
            The fastest but least effective compression.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level1">
            <summary>
            A synonym for BestSpeed.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level2">
            <summary>
            A little slower, but better, than level 1.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level3">
            <summary>
            A little slower, but better, than level 2.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level4">
            <summary>
            A little slower, but better, than level 3.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level5">
            <summary>
            A little slower than level 4, but with better compression.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Default">
            <summary>
            The default compression level, with a good balance of speed and compression efficiency.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level6">
            <summary>
            A synonym for Default.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level7">
            <summary>
            Pretty good compression!
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level8">
            <summary>
             Better compression than Level7!
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.BestCompression">
            <summary>
            The "best" compression, where best means greatest reduction in size of the input data stream.
            This is also the slowest compression.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionLevel.Level9">
            <summary>
            A synonym for BestCompression.
            </summary>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.CompressionStrategy">
            <summary>
            Describes options for how the compression algorithm is executed.  Different strategies
            work better on different sorts of data.  The strategy parameter can affect the compression
            ratio and the speed of compression but not the correctness of the compresssion.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionStrategy.Default">
            <summary>
            The default strategy is probably the best for normal data.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionStrategy.Filtered">
            <summary>
            The <c>Filtered</c> strategy is intended to be used most effectively with data produced by a
            filter or predictor.  By this definition, filtered data consists mostly of small
            values with a somewhat random distribution.  In this case, the compression algorithm
            is tuned to compress them better.  The effect of <c>Filtered</c> is to force more Huffman
            coding and less string matching; it is a half-step between <c>Default</c> and <c>HuffmanOnly</c>.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionStrategy.HuffmanOnly">
            <summary>
            Using <c>HuffmanOnly</c> will force the compressor to do Huffman encoding only, with no
            string matching.
            </summary>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.CompressionMode">
            <summary>
            An enum to specify the direction of transcoding - whether to compress or decompress.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionMode.Compress">
            <summary>
            Used to specify that the stream should compress the data.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.CompressionMode.Decompress">
            <summary>
            Used to specify that the stream should decompress the data.
            </summary>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.ZlibException">
            <summary>
            A general purpose exception class for exceptions in the Zlib library.
            </summary>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibException.#ctor">
            <summary>
            The ZlibException class captures exception information generated
            by the Zlib library.
            </summary>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibException.#ctor(System.String)">
            <summary>
            This ctor collects a message attached to the exception.
            </summary>
            <param name="s">the message for the exception.</param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.SharedUtils.URShift(System.Int32,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.SharedUtils.ReadInput(System.IO.TextReader,System.Byte[],System.Int32,System.Int32)">
             <summary>
               Reads a number of characters from the current source TextReader and writes
               the data to the target array at the specified index.
             </summary>
            
             <param name="sourceTextReader">The source TextReader to read from</param>
             <param name="target">Contains the array of characteres read from the source TextReader.</param>
             <param name="start">The starting index of the target array.</param>
             <param name="count">The maximum number of characters to read from the source TextReader.</param>
            
             <returns>
               The number of characters read. The number will be less than or equal to
               count depending on the data available in the source TextReader. Returns -1
               if the end of the stream is reached.
             </returns>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.Adler">
             <summary>
             Computes an Adler-32 checksum.
             </summary>
             <remarks>
             The Adler checksum is similar to a CRC checksum, but faster to compute, though less
             reliable.  It is used in producing RFC1950 compressed streams.  The Adler checksum
             is a required part of the "ZLIB" standard.  Applications will almost never need to
             use this class directly.
             </remarks>
            
             <exclude/>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.Adler.Adler32(System.UInt32,System.Byte[],System.Int32,System.Int32)">
            <summary>
              Calculates the Adler32 checksum.
            </summary>
            <remarks>
              <para>
                This is used within ZLIB.  You probably don't need to use this directly.
              </para>
            </remarks>
            <example>
               To compute an Adler32 checksum on a byte array:
             <code>
               var adler = Adler.Adler32(0, null, 0, 0);
               adler = Adler.Adler32(adler, buffer, index, length);
             </code>
            </example>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.ZlibCodec">
             <summary>
             Encoder and Decoder for ZLIB and DEFLATE (IETF RFC1950 and RFC1951).
             </summary>
            
             <remarks>
             This class compresses and decompresses data according to the Deflate algorithm
             and optionally, the ZLIB format, as documented in <see
             href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950 - ZLIB</see> and <see
             href="http://www.ietf.org/rfc/rfc1951.txt">RFC 1951 - DEFLATE</see>.
             </remarks>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.InputBuffer">
            <summary>
            The buffer from which data is taken.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.NextIn">
            <summary>
            An index into the InputBuffer array, indicating where to start reading. 
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.AvailableBytesIn">
            <summary>
            The number of bytes available in the InputBuffer, starting at NextIn. 
            </summary>
            <remarks>
            Generally you should set this to InputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.TotalBytesIn">
            <summary>
            Total number of bytes read so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.OutputBuffer">
            <summary>
            Buffer to store output data.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.NextOut">
            <summary>
            An index into the OutputBuffer array, indicating where to start writing. 
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.AvailableBytesOut">
            <summary>
            The number of bytes available in the OutputBuffer, starting at NextOut. 
            </summary>
            <remarks>
            Generally you should set this to OutputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.TotalBytesOut">
            <summary>
            Total number of bytes written to the output so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.Message">
            <summary>
            used for diagnostics, when something goes wrong!
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.CompressLevel">
            <summary>
            The compression level to use in this codec.  Useful only in compression mode.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.WindowBits">
            <summary>
            The number of Window Bits to use.  
            </summary>
            <remarks>
            This gauges the size of the sliding window, and hence the 
            compression effectiveness as well as memory consumption. It's best to just leave this 
            setting alone if you don't know what it is.  The maximum value is 15 bits, which implies
            a 32k window.  
            </remarks>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibCodec.Strategy">
            <summary>
            The compression strategy to use.
            </summary>
            <remarks>
            This is only effective in compression.  The theory offered by ZLIB is that different
            strategies could potentially produce significant differences in compression behavior
            for different data sets.  Unfortunately I don't have any good recommendations for how
            to set it differently.  When I tested changing the strategy I got minimally different
            compression performance. It's best to leave this property alone if you don't have a
            good feel for it.  Or, you may want to produce a test harness that runs through the
            different strategy options and evaluates them on different file types. If you do that,
            let me know your results.
            </remarks>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.#ctor">
            <summary>
            Create a ZlibCodec.
            </summary>
            <remarks>
            If you use this default constructor, you will later have to explicitly call 
            InitializeInflate() or InitializeDeflate() before using the ZlibCodec to compress 
            or decompress. 
            </remarks>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.#ctor(BestHTTP.Decompression.Zlib.CompressionMode)">
            <summary>
            Create a ZlibCodec that either compresses or decompresses.
            </summary>
            <param name="mode">
            Indicates whether the codec should compress (deflate) or decompress (inflate).
            </param>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.InitializeInflate">
            <summary>
            Initialize the inflation state. 
            </summary>
            <remarks>
            It is not necessary to call this before using the ZlibCodec to inflate data; 
            It is implicitly called when you call the constructor.
            </remarks>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.InitializeInflate(System.Boolean)">
             <summary>
             Initialize the inflation state with an explicit flag to
             govern the handling of RFC1950 header bytes.
             </summary>
            
             <remarks>
             By default, the ZLIB header defined in <see
             href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950</see> is expected.  If
             you want to read a zlib stream you should specify true for
             expectRfc1950Header.  If you have a deflate stream, you will want to specify
             false. It is only necessary to invoke this initializer explicitly if you
             want to specify false.
             </remarks>
            
             <param name="expectRfc1950Header">whether to expect an RFC1950 header byte
             pair when reading the stream of data to be inflated.</param>
            
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.InitializeInflate(System.Int32)">
            <summary>
            Initialize the ZlibCodec for inflation, with the specified number of window bits. 
            </summary>
            <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
            then you shouldn't be calling this initializer.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.InitializeInflate(System.Int32,System.Boolean)">
             <summary>
             Initialize the inflation state with an explicit flag to govern the handling of
             RFC1950 header bytes. 
             </summary>
            
             <remarks>
             If you want to read a zlib stream you should specify true for
             expectRfc1950Header. In this case, the library will expect to find a ZLIB
             header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
             1950</see>, in the compressed stream.  If you will be reading a DEFLATE or
             GZIP stream, which does not have such a header, you will want to specify
             false.
             </remarks>
            
             <param name="expectRfc1950Header">whether to expect an RFC1950 header byte pair when reading 
             the stream of data to be inflated.</param>
             <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
             then you shouldn't be calling this initializer.</param>
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.Inflate(BestHTTP.Decompression.Zlib.FlushType)">
             <summary>
             Inflate the data in the InputBuffer, placing the result in the OutputBuffer.
             </summary>
             <remarks>
             You must have set InputBuffer and OutputBuffer, NextIn and NextOut, and AvailableBytesIn and 
             AvailableBytesOut  before calling this method.
             </remarks>
             <example>
             <code>
             private void InflateBuffer()
             {
                 int bufferSize = 1024;
                 byte[] buffer = new byte[bufferSize];
                 ZlibCodec decompressor = new ZlibCodec();
             
                 Console.WriteLine("\n============================================");
                 Console.WriteLine("Size of Buffer to Inflate: {0} bytes.", CompressedBytes.Length);
                 MemoryStream ms = new MemoryStream(DecompressedBytes);
             
                 int rc = decompressor.InitializeInflate();
             
                 decompressor.InputBuffer = CompressedBytes;
                 decompressor.NextIn = 0;
                 decompressor.AvailableBytesIn = CompressedBytes.Length;
             
                 decompressor.OutputBuffer = buffer;
             
                 // pass 1: inflate 
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(FlushType.None);
             
                     if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     ms.Write(decompressor.OutputBuffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 // pass 2: finish and flush
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(FlushType.Finish);
             
                     if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     if (buffer.Length - decompressor.AvailableBytesOut &gt; 0)
                         ms.Write(buffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 decompressor.EndInflate();
             }
            
             </code>
             </example>
             <param name="flush">The flush to use when inflating.</param>
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.EndInflate">
            <summary>
            Ends an inflation session. 
            </summary>
            <remarks>
            Call this after successively calling Inflate().  This will cause all buffers to be flushed. 
            After calling this you cannot call Inflate() without a intervening call to one of the
            InitializeInflate() overloads.
            </remarks>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.SyncInflate">
            <summary>
            I don't know what this does!
            </summary>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.InitializeDeflate">
            <summary>
            Initialize the ZlibCodec for deflation operation.
            </summary>
            <remarks>
            The codec will use the MAX window bits and the default level of compression.
            </remarks>
            <example>
            <code>
             int bufferSize = 40000;
             byte[] CompressedBytes = new byte[bufferSize];
             byte[] DecompressedBytes = new byte[bufferSize];
             
             ZlibCodec compressor = new ZlibCodec();
             
             compressor.InitializeDeflate(CompressionLevel.Default);
             
             compressor.InputBuffer = System.Text.ASCIIEncoding.ASCII.GetBytes(TextToCompress);
             compressor.NextIn = 0;
             compressor.AvailableBytesIn = compressor.InputBuffer.Length;
             
             compressor.OutputBuffer = CompressedBytes;
             compressor.NextOut = 0;
             compressor.AvailableBytesOut = CompressedBytes.Length;
             
             while (compressor.TotalBytesIn != TextToCompress.Length &amp;&amp; compressor.TotalBytesOut &lt; bufferSize)
             {
               compressor.Deflate(FlushType.None);
             }
             
             while (true)
             {
               int rc= compressor.Deflate(FlushType.Finish);
               if (rc == ZlibConstants.Z_STREAM_END) break;
             }
             
             compressor.EndDeflate();
              
            </code>
            </example>
            <returns>Z_OK if all goes well. You generally don't need to check the return code.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.InitializeDeflate(BestHTTP.Decompression.Zlib.CompressionLevel)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel.
            </summary>
            <remarks>
            The codec will use the maximum window bits (15) and the specified
            CompressionLevel.  It will emit a ZLIB stream as it compresses.
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.InitializeDeflate(BestHTTP.Decompression.Zlib.CompressionLevel,System.Boolean)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the explicit flag governing whether to emit an RFC1950 header byte pair.
            </summary>
            <remarks>
            The codec will use the maximum window bits (15) and the specified CompressionLevel.
            If you want to generate a zlib stream, you should specify true for
            wantRfc1950Header. In this case, the library will emit a ZLIB
            header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
            1950</see>, in the compressed stream.  
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.InitializeDeflate(BestHTTP.Decompression.Zlib.CompressionLevel,System.Int32)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the specified number of window bits. 
            </summary>
            <remarks>
            The codec will use the specified number of window bits and the specified CompressionLevel.
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.InitializeDeflate(BestHTTP.Decompression.Zlib.CompressionLevel,System.Int32,System.Boolean)">
             <summary>
             Initialize the ZlibCodec for deflation operation, using the specified
             CompressionLevel, the specified number of window bits, and the explicit flag
             governing whether to emit an RFC1950 header byte pair.
             </summary>
            
             <param name="level">The compression level for the codec.</param>
             <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
             <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
             <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.Deflate(BestHTTP.Decompression.Zlib.FlushType)">
            <summary>
            Deflate one batch of data.
            </summary>
            <remarks>
            You must have set InputBuffer and OutputBuffer before calling this method.
            </remarks>
            <example>
            <code>
            private void DeflateBuffer(CompressionLevel level)
            {
                int bufferSize = 1024;
                byte[] buffer = new byte[bufferSize];
                ZlibCodec compressor = new ZlibCodec();
            
                Console.WriteLine("\n============================================");
                Console.WriteLine("Size of Buffer to Deflate: {0} bytes.", UncompressedBytes.Length);
                MemoryStream ms = new MemoryStream();
            
                int rc = compressor.InitializeDeflate(level);
            
                compressor.InputBuffer = UncompressedBytes;
                compressor.NextIn = 0;
                compressor.AvailableBytesIn = UncompressedBytes.Length;
            
                compressor.OutputBuffer = buffer;
            
                // pass 1: deflate 
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(FlushType.None);
            
                    if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                        throw new Exception("deflating: " + compressor.Message);
            
                    ms.Write(compressor.OutputBuffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                // pass 2: finish and flush
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(FlushType.Finish);
            
                    if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                        throw new Exception("deflating: " + compressor.Message);
            
                    if (buffer.Length - compressor.AvailableBytesOut &gt; 0)
                        ms.Write(buffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                compressor.EndDeflate();
            
                ms.Seek(0, SeekOrigin.Begin);
                CompressedBytes = new byte[compressor.TotalBytesOut];
                ms.Read(CompressedBytes, 0, CompressedBytes.Length);
            }
            </code>
            </example>
            <param name="flush">whether to flush all data as you deflate. Generally you will want to 
            use Z_NO_FLUSH here, in a series of calls to Deflate(), and then call EndDeflate() to 
            flush everything. 
            </param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.EndDeflate">
            <summary>
            End a deflation session.
            </summary>
            <remarks>
            Call this after making a series of one or more calls to Deflate(). All buffers are flushed.
            </remarks>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.ResetDeflate">
            <summary>
            Reset a codec for another deflation session.
            </summary>
            <remarks>
            Call this to reset the deflation state.  For example if a thread is deflating
            non-consecutive blocks, you can call Reset() after the Deflate(Sync) of the first
            block and before the next Deflate(None) of the second block.
            </remarks>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.SetDeflateParams(BestHTTP.Decompression.Zlib.CompressionLevel,BestHTTP.Decompression.Zlib.CompressionStrategy)">
            <summary>
            Set the CompressionStrategy and CompressionLevel for a deflation session.
            </summary>
            <param name="level">the level of compression to use.</param>
            <param name="strategy">the strategy to use for compression.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZlibCodec.SetDictionary(System.Byte[])">
            <summary>
            Set the dictionary to be used for either Inflation or Deflation.
            </summary>
            <param name="dictionary">The dictionary bytes to use.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="P:BestHTTP.Decompression.Zlib.ZlibCodec.Adler32">
            <summary>
            The Adler32 checksum on the data transferred through the codec so far. You probably don't need to look at this.
            </summary>
        </member>
        <member name="T:BestHTTP.Decompression.Zlib.ZlibConstants">
            <summary>
            A bunch of constants used in the Zlib interface.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.WindowBitsMax">
            <summary>
            The maximum number of window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.WindowBitsDefault">
            <summary>
            The default number of window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.Z_OK">
            <summary>
            indicates everything is A-OK
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.Z_STREAM_END">
            <summary>
            Indicates that the last operation reached the end of the stream.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.Z_NEED_DICT">
            <summary>
            The operation ended in need of a dictionary. 
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.Z_STREAM_ERROR">
            <summary>
            There was an error with the stream - not enough data, not open and readable, etc.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.Z_DATA_ERROR">
            <summary>
            There was an error with the data - not enough data, bad data, etc.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.Z_BUF_ERROR">
            <summary>
            There was an error with the working buffer.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.WorkingBufferSizeDefault">
            <summary>
            The size of the working buffer used in the ZlibCodec class. Defaults to 8192 bytes.
            </summary>
        </member>
        <member name="F:BestHTTP.Decompression.Zlib.ZlibConstants.WorkingBufferSizeMin">
            <summary>
            The minimum size of the working buffer used in the ZlibCodec class.  Currently it is 128 bytes.
            </summary>
        </member>
        <member name="M:BestHTTP.Decompression.Zlib.ZTree.DistanceCode(System.Int32)">
            <summary>
            Map from a distance to a distance code.
            </summary>
            <remarks> 
            No side effects. _dist_code[256] and _dist_code[257] are never used.
            </remarks>
        </member>
        <member name="M:BestHTTP.Extensions.Extensions.AsciiToString(System.Byte[])">
            <summary>
            On WP8 platform there are no ASCII encoding.
            </summary>
        </member>
        <member name="M:BestHTTP.Extensions.Extensions.GetASCIIBytes(System.String)">
            <summary>
            On WP8 platform there are no ASCII encoding.
            </summary>
        </member>
        <member name="M:BestHTTP.Extensions.Extensions.ReadBuffer(System.IO.Stream,System.Byte[])">
            <summary>
            Will fill the entire buffer from the stream.
            </summary>
        </member>
        <member name="T:BestHTTP.Extensions.HeartbeatManager">
            <summary>
            A manager class that can handle subscribing and unsubscribeing in the same update.
            </summary>
        </member>
        <member name="T:BestHTTP.Extensions.KeyValuePair">
            <summary>
            Used in string parsers. Its Value is optional.
            </summary>
        </member>
        <member name="T:BestHTTP.Extensions.KeyValuePairList">
            <summary>
            Base class for specialized parsers
            </summary>
        </member>
        <member name="T:BestHTTP.Extensions.WWWAuthenticateHeaderParser">
            <summary>
            Used for parsing WWW-Authenticate headers:
            Digest realm="my realm", nonce="4664b327a2963503ba58bbe13ad672c0", qop=auth, opaque="f7e38bdc1c66fce214f9019ffe43117c"
            </summary>
        </member>
        <member name="T:BestHTTP.Forms.HTTPFieldData">
            <summary>
            This class represents a HTTP Form's field.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFieldData.Name">
            <summary>
            The form's field.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFieldData.FileName">
            <summary>
            Filename of the field. Optional.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFieldData.MimeType">
            <summary>
            Mime-type of the field. Optional
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFieldData.Encoding">
            <summary>
            Encoding of the data. Optional
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFieldData.Text">
            <summary>
            The field's textual data.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFieldData.Binary">
            <summary>
            The field's binary data.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFieldData.Payload">
            <summary>
            Will return with the binary data, or if it's not present the textual data will be decoded to binary.
            </summary>
        </member>
        <member name="T:BestHTTP.Forms.HTTPFormBase">
            <summary>
            Base class of a concrete implementation. Don't use it to create a form, use instead one of the already wrote implementation(HTTPMultiPartForm, HTTPUrlEncodedForm), or create a new one by inheriting from this base class.
            </summary>
        </member>
        <member name="M:BestHTTP.Forms.HTTPFormBase.CopyFrom(BestHTTP.Forms.HTTPFormBase)">
            <summary>
            It should 'clone' all the data from the given HTTPFormBase object.
            Called after the form-implementation created.
            </summary>
        </member>
        <member name="M:BestHTTP.Forms.HTTPFormBase.PrepareRequest(BestHTTP.HTTPRequest)">
            <summary>
            Prepares the request to sending a form. It should set only the headers.
            </summary>
        </member>
        <member name="M:BestHTTP.Forms.HTTPFormBase.GetData">
            <summary>
            Prepares and returns with the form's raw data.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFormBase.Fields">
            <summary>
            A list that holds the form's fields.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFormBase.IsEmpty">
            <summary>
            Returns true if the Fields has no element.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFormBase.IsChanged">
            <summary>
            True if new fields has been added to our list.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFormBase.HasBinary">
            <summary>
            True if there are at least one form-field with binary data.
            </summary>
        </member>
        <member name="P:BestHTTP.Forms.HTTPFormBase.HasLongValue">
            <summary>
            True if there are at least one form-field with a long textual data.
            </summary>
        </member>
        <member name="F:BestHTTP.Forms.HTTPFormUsage.Automatic">
            <summary>
            The plugin will try to choose the best form sending method.
            </summary>
        </member>
        <member name="F:BestHTTP.Forms.HTTPFormUsage.UrlEncoded">
            <summary>
            The plugin will use the Url-Encoded form sending.
            </summary>
        </member>
        <member name="F:BestHTTP.Forms.HTTPFormUsage.Multipart">
            <summary>
            The plugin will use the Multipart form sending.
            </summary>
        </member>
        <member name="F:BestHTTP.Forms.HTTPFormUsage.Unity">
            <summary>
            The legacy, Unity-based form sending.
            </summary>
        </member>
        <member name="T:BestHTTP.Forms.HTTPMultiPartForm">
            <summary>
            A HTTP Form implementation to send textual and binary values.
            </summary>
        </member>
        <member name="F:BestHTTP.Forms.HTTPMultiPartForm.Boundary">
            <summary>
            A random boundary generated in the constructor.
            </summary>
        </member>
        <member name="F:BestHTTP.Forms.HTTPMultiPartForm.CachedData">
            <summary>
            
            </summary>
        </member>
        <member name="T:BestHTTP.Forms.HTTPUrlEncodedForm">
            <summary>
            A HTTP Form implementation to send textual values.
            </summary>
        </member>
        <member name="T:BestHTTP.Forms.UnityForm">
            <summary>
            For backward compatibility.
            </summary>
        </member>
        <member name="T:BestHTTP.HTTPConnection">
            <summary>
            Represents and manages a connection to a server.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnection.RetryCauses.None">
            <summary>
            The request processed without any special case.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnection.RetryCauses.Reconnect">
            <summary>
            If the server closed the connection while we sending a request we should reconnect and send the request again. But we will try it once.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnection.RetryCauses.Authenticate">
            <summary>
            We need an another try with Authorization header set.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnection.RetryCauses.ProxyAuthenticate">
            <summary>
            The proxy needs authentication.
            </summary>
        </member>
        <member name="T:BestHTTP.HTTPConnectionStates">
            <summary>
            Possible states of a Http Connection.
            The ideal lifecycle of a connection that has KeepAlive is the following: Initial => [Processing => WaitForRecycle => Free] => Closed.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.Initial">
            <summary>
            This Connection instance is just created.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.Processing">
            <summary>
            This Connection is processing a request
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.Redirected">
            <summary>
            The request redirected.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.Upgraded">
            <summary>
            The connection is upgraded from http.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.WaitForProtocolShutdown">
            <summary>
            Wait for the upgraded protocol to shut down.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.WaitForRecycle">
            <summary>
            The Connection is finished processing the request, it's waiting now to deliver it's result.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.Free">
            <summary>
            The request result's delivered, it's now up to processing again.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.AbortRequested">
            <summary>
            A request from outside of the plugin to abort the connection.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.TimedOut">
            <summary>
            The request is not finished in the given time.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPConnectionStates.Closed">
            <summary>
            If it's not a KeepAlive connection, or something happend, then we close this connection and remove from the pool.
            </summary>
        </member>
        <member name="T:BestHTTP.HTTPManager">
            <summary>
            
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPManager.Connections">
            <summary>
            All connection has a reference in this Dictionary untill it's removed completly.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPManager.ActiveConnections">
            <summary>
            Active connections. These connections all has a request to process.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPManager.FreeConnections">
            <summary>
            Free connections. They can be removed completly after a specified time.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPManager.RecycledConnections">
            <summary>
            Connections that recycled in the Update loop. If they are not used in the same loop to process a request, they will be transferred to the FreeConnections list.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPManager.RequestQueue">
            <summary>
            List of request that have to wait until there is a free connection to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPManager.CreateConnection(BestHTTP.HTTPRequest,System.String)">
            <summary>
            Factory method to create a concrete connection object.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPManager.CanProcessFromQueue">
            <summary>
            Will return with true when there at least one request that can be processed from the RequestQueue.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPManager.GetConnectionWith(BestHTTP.HTTPRequest)">
            <summary>
            Will return the ConnectionBase object that processing the given request.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPManager.GetRootCacheFolder">
            <summary>
            Will return where the various caches should be saved.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPManager.OnUpdate">
            <summary>
            Update function that should be called regularly from a Unity event(Update, LateUpdate). Callbacks are dispatched from this function.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.MaxConnectionPerServer">
            <summary>
            The maximum active tcp connections that the client will maintain to a server. Default value is 4. Minimum value is 1.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.KeepAliveDefaultValue">
            <summary>
            Default value of a http request's IsKeepAlive value. Default value is true. If you make rare request to the server it's should be changed to false.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.IsCachingDisabled">
            <summary>
            Set to true, if caching is prohibited.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.MaxConnectionIdleTime">
            <summary>
            How many time must be passed to destroy that connection after a connection finished it's last request. It's default value is 30 seconds.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.IsCookiesEnabled">
            <summary>
            Set to false to disable all Cookie. It's default value is true.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.CookieJarSize">
            <summary>
            Size of the Cookie Jar in bytes. It's default value is 10485760 (10 MB).
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.EnablePrivateBrowsing">
            <summary>
            If this property is set to true, then new cookies treated as session cookies and these cookies are not saved to disk. It's default value is false;
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.ConnectTimeout">
            <summary>
            Global, default value of the HTTPRequest's ConnectTimeout property. Default value is 20 seconds.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.RequestTimeout">
            <summary>
            Global, default value of the HTTPRequest's Timeout property. Default value is 60 seconds.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.RootCacheFolderProvider">
            <summary>
            By default the plugin will save all cache and cookie data under the path returned by Application.persistentDataPath.
            You can assign a function to this delegate to return a custom root path to define a new path.
            <remarks>This delegate will be called on a non Unity thread!</remarks>
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.Proxy">
            <summary>
            The global, default proxy for all HTTPRequests. The HTTPRequest's Proxy still can be changed per-request. Default value is null.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.Heartbeats">
            <summary>
            Heartbeat manager to use less threads in the plugin. The heartbeat updates are called from the OnUpdate function.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.Logger">
            <summary>
            A basic ILogger implementation to be able to log intelligently additional informations about the plugin's internal mechanism.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.DefaultCertificateVerifyer">
            <summary>
            The default ICertificateVerifyer implementation that the plugin will use when the request's UseAlternateSSL property is set to true.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.UseAlternateSSLDefaultValue">
            <summary>
            The default value for the HTTPRequest's UseAlternateSSL property.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPManager.MaxPathLength">
            <summary>
            On most systems the maximum length of a path is around 255 character. If a cache entity's path is longer than this value it doesn't get cached. There no patform independent API to query the exact value on the current system, but it's 
            exposed here and can be overridden. It's default value is 255.
            </summary>
        </member>
        <member name="T:BestHTTP.HTTPMethods">
            <summary>
            Some supported methods described in the rfc: http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPMethods.Get">
            <summary>
            The GET method means retrieve whatever information (in the form of an entity) is identified by the Request-URI.
            If the Request-URI refers to a data-producing process, it is the produced data which shall be returned as the 
            entity in the response and not the source text of the process, unless that text happens to be the output of the process.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPMethods.Head">
            <summary>
            The HEAD method is identical to GET except that the server MUST NOT return a message-body in the response.
            The metainformation contained in the HTTP headers in response to a HEAD request SHOULD be identical to the information sent in response to a GET request.
            This method can be used for obtaining metainformation about the entity implied by the request without transferring the entity-body itself.
            This method is often used for testing hypertext links for validity, accessibility, and recent modification. 
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPMethods.Post">
            <summary>
            The POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line.
            POST is designed to allow a uniform method to cover the following functions:
            <list type="bullet">
                <item><description>Annotation of existing resources;</description></item>
                <item><description>Posting a message to a bulletin board, newsgroup, mailing list, or similar group of articles;</description></item>
                <item><description>Providing a block of data, such as the result of submitting a form, to a data-handling process;</description></item>
                <item><description>Extending a database through an append operation.</description></item>
            </list>
            The actual function performed by the POST method is determined by the server and is usually dependent on the Request-URI. 
            The posted entity is subordinate to that URI in the same way that a file is subordinate to a directory containing it, 
            a news article is subordinate to a newsgroup to which it is posted, or a record is subordinate to a database. 
            The action performed by the POST method might not result in a resource that can be identified by a URI. In this case, 
            either 200 (OK) or 204 (No Content) is the appropriate response status, depending on whether or not the response includes an entity that describes the result.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPMethods.Put">
            <summary>
            The PUT method requests that the enclosed entity be stored under the supplied Request-URI. 
            If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. 
            If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, 
            the origin server can create the resource with that URI. If a new resource is created, the origin server MUST inform the user agent via the 201 (Created) response. 
            If an existing resource is modified, either the 200 (OK) or 204 (No Content) response codes SHOULD be sent to indicate successful completion of the request. 
            If the resource could not be created or modified with the Request-URI, an appropriate error response SHOULD be given that reflects the nature of the problem. 
            The recipient of the entity MUST NOT ignore any Content-* (e.g. Content-Range) headers that it does not understand or implement and MUST return a 501 (Not Implemented) response in such cases.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPMethods.Delete">
            <summary>
            The DELETE method requests that the origin server delete the resource identified by the Request-URI. This method MAY be overridden by human intervention (or other means) on the origin server. 
            The client cannot be guaranteed that the operation has been carried out, even if the status code returned from the origin server indicates that the action has been completed successfully. 
            However, the server SHOULD NOT indicate success unless, at the time the response is given, it intends to delete the resource or move it to an inaccessible location. 
            A successful response SHOULD be 200 (OK) if the response includes an entity describing the status, 202 (Accepted) if the action has not yet been enacted, or 204 (No Content) 
            if the action has been enacted but the response does not include an entity.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPMethods.Patch">
            <summary>
            http://tools.ietf.org/html/rfc5789
            The PATCH method requests that a set of changes described in the request entity be applied to the resource identified by the Request-URI.
            The set of changes is represented in a format called a "patchdocument" identified by a media type. If the Request-URI does not point to an existing resource, 
            the server MAY create a new resource, depending on the patch document type (whether it can logically modify a null resource) and permissions, etc.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPProxy.Address">
            <summary>
            Address of the proxy server. It has to be in the http://proxyaddress:port form.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPProxy.Credentials">
            <summary>
            Credentials of the proxy
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPProxy.IsTransparent">
            <summary>
            True if the proxy can act as a transparent proxy
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPProxy.SendWholeUri">
            <summary>
            Some non-transparent proxies are except only the path and query of the request uri. Default value is true
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPProxy.NonTransparentForHTTPS">
            <summary>
            Regardless of the value of IsTransparent, for secure protocols(HTTPS://, WSS://) the plugin will use the proxy as an explicit proxy(will issue a CONNECT request to the proxy)
            </summary>
        </member>
        <member name="T:BestHTTP.HTTPRange">
            <summary>
            
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRange.FirstBytePos">
            <summary>
            The first byte's position that the server sent.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRange.LastBytePos">
            <summary>
            The last byte's position that the server sent.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRange.ContentLength">
            <summary>
            Indicates the total length of the full entity-body on the server, -1 if this length is unknown or difficult to determine.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRange.IsValid">
            <summary>
            
            </summary>
        </member>
        <member name="T:BestHTTP.HTTPRequestStates">
            <summary>
            Possible logical states of a HTTTPRequest object.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequestStates.Initial">
            <summary>
            Initial status of a request. No callback will be called with this status.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequestStates.Queued">
            <summary>
            Waiting in a queue to be processed. No callback will be called with this status.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequestStates.Processing">
            <summary>
            Processing of the request started. In this state the client will send the request, and parse the response. No callback will be called with this status.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequestStates.Finished">
            <summary>
            The request finished without problem. Parsing the response done, the result can be used. The user defined callback will be called with a valid response object. The requests Exception property will be null.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequestStates.Error">
            <summary>
            The request finished with an unexpected error. The user defined callback will be called with a null response object. The request's Exception property may contain more info about the error, but it can be null.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequestStates.Aborted">
            <summary>
            The request aborted by the client(HTTPRequests Abort() function). The user defined callback will be called with a null response. The requests Exception property will be null.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequestStates.ConnectionTimedOut">
            <summary>
            Connecting to the server timed out. The user defined callback will be called with a null response. The requests Exception property will be null.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequestStates.TimedOut">
            <summary>
            The request didn't finished in the given time. The user defined callback will be called with a null response. The requests Exception property will be null.
            </summary>
        </member>
        <member name="T:BestHTTP.HTTPRequest">
            <summary>
            
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequest.MethodNames">
            <summary>
            Cached uppercase values to save some cpu cycles and GC alloc per request.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequest.UploadChunkSize">
            <summary>
            Size of the internal buffer, and upload progress will be fired when this size of data sent to the wire. It's default value is 1024 bytes.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequest.OnUploadProgress">
            <summary>
            Called after data sent out to the wire.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequest.OnProgress">
            <summary>
            Called when new data downloaded from the server.
            The first parameter is the original HTTTPRequest object itself, the secound parameter is the downloaded bytes while the third parameter is the content length.
            <remarks>There are download modes where we can't figure out the exact length of the final content. In these cases we just guarantee that the third parameter will be at least the size of the secound one.</remarks>
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequest.OnUpgraded">
            <summary>
            Called when the current protocol is upgraded to an other. (HTTP => WebSocket for example)
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequest.FieldCollector">
            <summary>
            We will collect the fields and values to the FieldCollector through the AddField and AddBinaryData functions.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPRequest.FormImpl">
            <summary>
            When the request about to send the request we will create a specialised form implementation(url-encoded, multipart, or the legacy WWWForm based).
            And we will use this instance to create the data that we will send to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.AddField(System.String,System.String)">
            <summary>
            Add a field with a given string value.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.AddField(System.String,System.String,System.Text.Encoding)">
            <summary>
            Add a field with a given string value.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.AddBinaryData(System.String,System.Byte[])">
            <summary>
            Add a field with binary content to the form.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.AddBinaryData(System.String,System.Byte[],System.String)">
            <summary>
            Add a field with binary content to the form.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.AddBinaryData(System.String,System.Byte[],System.String,System.String)">
            <summary>
            Add a field with binary content to the form.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.SetFields(UnityEngine.WWWForm)">
            <summary>
            Set or overwrite the internal form. Remarks: on WP8 it doesn't supported!
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.SetForm(BestHTTP.Forms.HTTPFormBase)">
            <summary>
            Manually set a HTTP Form.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.ClearForm">
            <summary>
            Clears all data from the form.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.SelectFormImplementation">
            <summary>
            Will create the form implementation based on the value of the FormUsage property.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.AddHeader(System.String,System.String)">
            <summary>
            Adds a header and value pair to the Headers. Use it to add custom headers to the request.
            </summary>
            <example>AddHeader("User-Agent', "FooBar 1.0")</example>
        </member>
        <member name="M:BestHTTP.HTTPRequest.SetHeader(System.String,System.String)">
            <summary>
            Removes any previously added values, and sets the given one.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.RemoveHeader(System.String)">
            <summary>
            Removes the specified header. Returns true, if the header found and succesfully removed.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:BestHTTP.HTTPRequest.HasHeader(System.String)">
            <summary>
            Returns true if the given head name is already in the Headers.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.GetFirstHeaderValue(System.String)">
            <summary>
            Returns the first header or null for the given header name.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.GetHeaderValues(System.String)">
            <summary>
            Returns all header values for the given header or null.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.SetRangeHeader(System.Int32)">
            <summary>
            Sets the Range header to download the content from the given byte position. See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35
            </summary>
            <param name="firstBytePos">Start position of the download.</param>
        </member>
        <member name="M:BestHTTP.HTTPRequest.SetRangeHeader(System.Int32,System.Int32)">
            <summary>
            Sets the Range header to download the content from the given byte position to the given last position. See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35
            </summary>
            <param name="firstBytePos">Start position of the download.</param>
            <param name="lastBytePos">The end position of the download.</param>
        </member>
        <member name="M:BestHTTP.HTTPRequest.SendHeaders(System.IO.BinaryWriter)">
            <summary>
            Writes out the Headers to the stream.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.DumpHeaders">
            <summary>
            Returns a string representation of the headers.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.Prepare">
            <summary>
            Called on Unity's main thread just before processing it.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.Send">
            <summary>
            Starts processing the request.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.Abort">
            <summary>
            Aborts an already estabilished connection, so no further download or upload are done.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPRequest.Clear">
            <summary>
            Resets the request for a state where switching MethodType is possible.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Uri">
            <summary>
            The original request's Uri.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.MethodType">
            <summary>
            The method that how we want to process our request the server.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.RawData">
            <summary>
            The raw data to send in a POST request. If it set all other fields that added to this request will be ignored.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.UploadStream">
            <summary>
            The stream that the plugin will use to get the data to send out the server. When this property is set, no forms or the RawData property will be used
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.DisposeUploadStream">
            <summary>
            When set to true(its default value) the plugin will call the UploadStream's Dispose() function when finished uploading the data from it. Default value is true.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.UseUploadStreamLength">
            <summary>
            If it's true, the plugin will use the Stream's Length property. Otherwise the plugin will send the data chunked. Default value is true.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.IsKeepAlive">
            <summary>
            Indicates that the connection should be open after the response received. If its true, then the internal tcp connections will be reused if it's possible. Default value is true.
            The default value can be changed in the HTTPManager class. If you make rare request to the server it's should be changed to false.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.DisableCache">
            <summary>
            With this property caching can be enabled/disabled on a per-request basis.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.UseStreaming">
            <summary>
            If it's true, the Callback will be called every time if we can send out at least one fragment.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.StreamFragmentSize">
            <summary>
            Maximum size of a data chunk that we want to receive when streaming is set.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Callback">
            <summary>
            The callback function that will be called when a request is fully processed or when any downloaded fragment is available if UseStreaming is true. Can be null for fire-and-forget requests.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.DisableRetry">
            <summary>
            With this option if reading back the server's response fails, the request will fail and any exceptions can be checked through the Exception property. The default value is True for POST requests, otherwise false.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.IsRedirected">
            <summary>
            Indicates that the request is redirected. If a request is redirected, the connection that served it will be closed regardless of the value of IsKeepAlive.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.RedirectUri">
            <summary>
            The Uri that the request redirected to.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.CurrentUri">
            <summary>
            If redirected it contains the RedirectUri.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Response">
            <summary>
            The response to the query.
            <remarks>If an exception occured during reading of the response stream or can't connect to the server, this will be null!</remarks>
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.ProxyResponse">
            <summary>
            Reponse from the Proxy server. It's null with transparent proxies.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Exception">
            <summary>
            It there is an exception while processing the request or response the Response property will be null, and the Exception will be stored in this property.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Tag">
            <summary>
            Any object can be passed with the request with this property. (eq. it can be identified, etc.)
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Credentials">
            <summary>
            The UserName, Password pair that the plugin will use to authenticate to the remote server.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.HasProxy">
            <summary>
            True, if there is a Proxy object.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Proxy">
            <summary>
            A web proxy's properties where the request must pass through.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.MaxRedirects">
            <summary>
            How many redirection supported for this request. The default is int.MaxValue. 0 or a negative value means no redirection supported.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.UseAlternateSSL">
            <summary>
            Use Bouncy Castle's code to handle the secure protocol instead of Mono's. You can try to set it true if you receive a "System.Security.Cryptography.CryptographicException: Unsupported hash algorithm" exception.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.IsCookiesEnabled">
            <summary>
            If true cookies will be added to the headers (if any), and parsed from the response. If false, all cookie operations will be ignored. It's default value is HTTPManager's IsCookiesEnabled.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Cookies">
            <summary>
            Cookies that are added to this list will be sent to the server alongside withe the server sent ones. If cookies are disabled only these cookies will be sent.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.FormUsage">
            <summary>
            What form should used. Default to Automatic.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.State">
            <summary>
            Current state of this request.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.RedirectCount">
            <summary>
            How many times redirected.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.ConnectTimeout">
            <summary>
            Maximum time we wait to estabilish the connection to the target server. Default value is 20 seconds.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Timeout">
            <summary>
            Maximum time we want to wait to the request to finish after the connection is estabilished. Default value is 60 seconds.
            <remarks>It's disabled for streaming requests! See <see cref="P:BestHTTP.HTTPRequest.EnableTimoutForStreaming"/>.</remarks>
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.EnableTimoutForStreaming">
            <summary>
            Set to true to enable Timeouts on streaming request. Default value is false.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Priority">
            <summary>
            The priority of the request. Higher priority requests will be picked from the request queue sooner than lower priority ones.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.CustomCertificateVerifyer">
            <summary>
            The ICertificateVerifyer implementation that the plugin will use to verify the server certificates when the request's UseAlternateSSL property is set to true.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.ProtocolHandler">
            <summary>
            
            </summary>
        </member>
        <member name="E:BestHTTP.HTTPRequest.OnBeforeRedirection">
            <summary>
            It's called before the plugin will do a new request to the new uri. The return value of this function will control the redirection: if it's false the redirection is aborted.
            This function is called on a thread other than the main Unity thread!
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Downloaded">
            <summary>
            How many bytes downloaded so far.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.DownloadLength">
            <summary>
            The length of the content that we are currently downloading.
            If chunked encoding is used, then it is the size of the sum of all previous chunks plus the current one.
            When no Content-Length present and no chunked encoding is used then its size is the currently downloaded size.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.DownloadProgressChanged">
            <summary>
            Set to true when the downloaded bytes are changed, and set to false when the OnProgress event called.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.UploadStreamLength">
            <summary>
            Will return the length of the UploadStream, or -1 if it's not supported.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.Uploaded">
            <summary>
            How many bytes are sent to the wire
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.UploadLength">
            <summary>
            How many bytes are expected we are sending. If we are don't know, then it will be -1.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPRequest.UploadProgressChanged">
            <summary>
            Set to true when the uploaded bytes are changed, and set to false when the OnUploadProgress event called.
            </summary>
        </member>
        <member name="T:BestHTTP.HTTPResponse">
            <summary>
            
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPResponse.dataAsText">
            <summary>
            Cached, converted data.
            </summary>
        </member>
        <member name="F:BestHTTP.HTTPResponse.texture">
            <summary>
            Cached converted data.
            </summary>
        </member>
        <member name="M:BestHTTP.HTTPResponse.GetHeaderValues(System.String)">
            <summary>
            Returns the list of values that received from the server for the given header name.
            <remarks>Remarks: All headers converted to lowercase while reading the response.</remarks>
            </summary>
            <param name="name">Name of the header</param>
            <returns>If no header found with the given name or there are no values in the list (eg. Count == 0) returns null.</returns>
        </member>
        <member name="M:BestHTTP.HTTPResponse.GetFirstHeaderValue(System.String)">
            <summary>
            Returns the first value in the header list or null if there are no header or value.
            </summary>
            <param name="name">Name of the header</param>
            <returns>If no header found with the given name or there are no values in the list (eg. Count == 0) returns null.</returns>
        </member>
        <member name="M:BestHTTP.HTTPResponse.HasHeaderWithValue(System.String,System.String)">
            <summary>
            Checks if there is a header with the given name and value.
            </summary>
            <param name="headerName">Name of the header.</param>
            <param name="value"></param>
            <returns>Returns true if there is a header with the given name and value.</returns>
        </member>
        <member name="M:BestHTTP.HTTPResponse.HasHeader(System.String)">
            <summary>
            Checks if there is a header with the given name.
            </summary>
            <param name="headerName">Name of the header.</param>
            <returns>Returns true if there is a header with the given name.</returns>
        </member>
        <member name="M:BestHTTP.HTTPResponse.GetRange">
            <summary>
            Parses the 'Content-Range' header's value and returns a HTTPRange object.
            </summary>
            <remarks>If the server ignores a byte-range-spec because it is syntactically invalid, the server SHOULD treat the request as if the invalid Range header field did not exist.
            (Normally, this means return a 200 response containing the full entity). In this case becouse of there are no 'Content-Range' header, this function will return null!</remarks>
            <returns>Returns null if no 'Content-Range' header found.</returns>
        </member>
        <member name="M:BestHTTP.HTTPResponse.FeedStreamFragment(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Add data to the fragments list.
            </summary>
            <param name="buffer">The buffer to be added.</param>
            <param name="pos">The position where we start copy the data.</param>
            <param name="length">How many data we want to copy.</param>
        </member>
        <member name="M:BestHTTP.HTTPResponse.GetStreamedFragments">
            <summary>
            If streaming is used, then every time this callback function called we can use this function to
             retrive the downloaded and buffered data. The returned list can be null, if there is no data yet.
            </summary>
            <returns></returns>
        </member>
        <member name="M:BestHTTP.HTTPResponse.Dispose">
            <summary>
            IDisposable implementation.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.StatusCode">
            <summary>
            The status code that sent from the server.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.IsSuccess">
            <summary>
            Returns true if the status code is in the range of [200..300[ or 304 (Not Modified)
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.Message">
            <summary>
            The message that sent along with the StatusCode from the server. You can check it for errors from the server.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.IsStreamed">
            <summary>
            True if it's a streamed response.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.IsStreamingFinished">
            <summary>
            True if the streaming is finished, and no more fragments are coming.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.IsFromCache">
            <summary>
            Indicates that the response body is read from the cache.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.Headers">
            <summary>
            The headers that sent from the server.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.Data">
            <summary>
            The data that donwloaded from the server. All Transfer and Content encodings decoded if any(eg. chunked, gzip, deflate).
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.IsUpgraded">
            <summary>
            The normal HTTP protocol is upgraded to an other.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.Cookies">
            <summary>
            The cookies that the server sent to the client.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.DataAsText">
            <summary>
            The data converted to an UTF8 string.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.DataAsTexture2D">
            <summary>
            The data loaded to a Texture2D.
            </summary>
        </member>
        <member name="P:BestHTTP.HTTPResponse.IsClosedManually">
            <summary>
            True if the connection's stream will be closed manually. Used in custom protocols (WebSocket, EventSource).
            </summary>
        </member>
        <member name="T:BestHTTP.HTTPUpdateDelegator">
            <summary>
            Delegates some U3D calls to the HTTPManager.
            </summary>
        </member>
        <member name="T:BestHTTP.JSON.Json">
             <summary>
             Based on the download from http://techblog.procurios.nl/k/news/view/14605/14863/how-do-i-write-my-own-parser-%28for-json%29.html
             This class encodes and decodes JSON strings.
             Spec. details, see http://www.json.org/
            
             JSON uses Arrays and Objects. These correspond here to the datatypes List and Dictionary.
             All numbers are parsed to doubles.
             </summary>
        </member>
        <member name="M:BestHTTP.JSON.Json.Decode(System.String)">
            <summary>
            Parses the string json into a value
            </summary>
            <param name="json">A JSON string.</param>
            <returns>A List, a Dictionary, a double, a string, null, true, or false</returns>
        </member>
        <member name="M:BestHTTP.JSON.Json.Decode(System.String,System.Boolean@)">
            <summary>
            Parses the string json into a value; and fills 'success' with the successfullness of the parse.
            </summary>
            <param name="json">A JSON string.</param>
            <param name="success">Successful parse?</param>
            <returns>A List, a Dictionary, a double, a string, null, true, or false</returns>
        </member>
        <member name="M:BestHTTP.JSON.Json.Encode(System.Object)">
            <summary>
            Converts a Dictionary / List object into a JSON string
            </summary>
            <param name="json">A Dictionary / List</param>
            <returns>A JSON encoded string, or null if object 'json' is not serializable</returns>
        </member>
        <member name="T:BestHTTP.Logger.DefaultLogger">
            <summary>
            A basic logger implementation to be able to log intelligently additional informations about the plugin's internal mechanism.
            </summary>
        </member>
        <member name="P:BestHTTP.Logger.ILogger.Level">
            <summary>
            The minimum severity to log
            </summary>
        </member>
        <member name="T:BestHTTP.Logger.Loglevels">
            <summary>
            Available logging levels.
            </summary>
        </member>
        <member name="F:BestHTTP.Logger.Loglevels.All">
            <summary>
            All message will be logged.
            </summary>
        </member>
        <member name="F:BestHTTP.Logger.Loglevels.Information">
            <summary>
            Only Informations and above will be logged.
            </summary>
        </member>
        <member name="F:BestHTTP.Logger.Loglevels.Warning">
            <summary>
            Only Warnings and above will be logged.
            </summary>
        </member>
        <member name="F:BestHTTP.Logger.Loglevels.Error">
            <summary>
            Only Errors and above will be logged.
            </summary>
        </member>
        <member name="F:BestHTTP.Logger.Loglevels.Exception">
            <summary>
            Only Exceptions will be logged.
            </summary>
        </member>
        <member name="F:BestHTTP.Logger.Loglevels.None">
            <summary>
            No logging will be occur.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the X9ECParameters object for the named curve represented by
             the passed in object identifier. Null if the curve isn't present.
            
             @param oid an object identifier representing a named curve, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves.GetOid(System.String)">
             return the object identifier signified by the passed in name. Null
             if there is no object identifier associated with name.
            
             @return the object identifier associated with name, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return the named curve name represented by the given object identifier.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Anssi.AnssiNamedCurves.Names">
            returns an enumeration containing the name strings for curves
            contained in this structure.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Encodable.GetDerEncoded">
             Return the DER encoding of the object, null if the DER encoding can not be made.
            
             @return a DER byte array, null otherwise.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Asn1InputStream">
            a general purpose ASN.1 decoder - note: this class differs from the
            others in that it returns null after it has read the last object in
            the stream. If an ASN.1 Null is encountered a Der/BER Null object is
            returned.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1InputStream.#ctor(System.IO.Stream,System.Int32)">
             Create an ASN1InputStream where no DER object will be longer than limit.
            
             @param input stream containing ASN.1 encoded data.
             @param limit maximum size of a DER encoded object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1InputStream.#ctor(System.Byte[])">
             Create an ASN1InputStream based on the input byte array. The length of DER objects in
             the stream is automatically limited to the length of the input array.
            
             @param input array containing ASN.1 encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1InputStream.BuildObject(System.Int32,System.Int32,System.Int32)">
            build an object given its tag and the number of bytes to construct it from.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Asn1Null">
            A Null object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Object.FromByteArray(System.Byte[])">
            <summary>Create a base ASN.1 object from a byte array.</summary>
            <param name="data">The byte array to parse.</param>
            <returns>The base ASN.1 object represented by the byte array.</returns>
            <exception cref="T:System.IO.IOException">If there is a problem parsing the data.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Object.FromStream(System.IO.Stream)">
            <summary>Read a base ASN.1 object from a stream.</summary>
            <param name="inStr">The stream to parse.</param>
            <returns>The base ASN.1 object represented by the byte array.</returns>
            <exception cref="T:System.IO.IOException">If there is a problem parsing the data.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1OctetString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an Octet string from a tagged object.
            
             @param obj the tagged object holding the object we want.
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                          be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1OctetString.GetInstance(System.Object)">
             return an Octet string from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1OctetString.#ctor(System.Byte[])">
            @param string the octets making up the octet string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Sequence.GetInstance(System.Object)">
             return an Asn1Sequence from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Sequence.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             Return an ASN1 sequence from a tagged object. There is a special
             case here, if an object appears to have been explicitly tagged on
             reading but we were expecting it to be implicitly tagged in the
             normal course of events it indicates that we lost the surrounding
             sequence - so we need to add it back (this will happen if the tagged
             object is a sequence that contains other sequences). If you are
             dealing with implicitly tagged sequences you really <b>should</b>
             be using this method.
            
             @param obj the tagged object.
             @param explicitly true if the object is meant to be explicitly tagged,
                      false otherwise.
             @exception ArgumentException if the tagged object cannot
                      be converted.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Asn1Sequence.Item(System.Int32)">
             return the object at the sequence position indicated by index.
            
             @param index the sequence number (starting at zero) of the object
             @return the object at the sequence position indicated by index.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Set.GetInstance(System.Object)">
             return an ASN1Set from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Set.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             Return an ASN1 set from a tagged object. There is a special
             case here, if an object appears to have been explicitly tagged on
             reading but we were expecting it to be implicitly tagged in the
             normal course of events it indicates that we lost the surrounding
             set - so we need to add it back (this will happen if the tagged
             object is a sequence that contains other sequences). If you are
             dealing with implicitly tagged sets you really <b>should</b>
             be using this method.
            
             @param obj the tagged object.
             @param explicitly true if the object is meant to be explicitly tagged
                      false otherwise.
             @exception ArgumentException if the tagged object cannot
                      be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1Set.LessThanOrEqual(System.Byte[],System.Byte[])">
            return true if a &lt;= b (arrays are assumed padded with zeros).
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Asn1Set.Item(System.Int32)">
             return the object at the set position indicated by index.
            
             @param index the set number (starting at zero) of the object
             @return the object at the set position indicated by index.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Asn1TaggedObject">
            ASN.1 TaggedObject - in ASN.1 notation this is any object preceded by
            a [n] where n is some number - these are assumed to follow the construction
            rules (as with sequences).
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.#ctor(System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.#ctor(System.Boolean,System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param explicitly true if the object is explicitly tagged.
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.IsExplicit">
            return whether or not the object may be explicitly tagged.
            <p>
            Note: if the object has been read from an input stream, the only
            time you can be sure if isExplicit is returning the true state of
            affairs is if it returns false. An implicitly tagged object may appear
            to be explicitly tagged, so you need to understand the context under
            which the reading was done as well, see GetObject below.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.GetObject">
            return whatever was following the tag.
            <p>
            Note: tagged objects are generally context dependent if you're
            trying to extract a tagged object you should be going via the
            appropriate GetInstance method.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Asn1TaggedObject.GetObjectParser(System.Int32,System.Boolean)">
            Return the object held in this tagged object as a parser assuming it has
            the type of the passed in tag. If the object doesn't have a parser
            associated with it, the base object is returned.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerApplicationSpecific">
            Base class for an application specific object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerApplicationSpecific.GetObject">
             Return the enclosed object assuming explicit tagging.
            
             @return  the resulting object
             @throws IOException if reconstruction fails.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerApplicationSpecific.GetObject(System.Int32)">
             Return the enclosed object assuming implicit tagging.
            
             @param derTagNo the type tag that should be applied to the object's contents.
             @return  the resulting object
             @throws IOException if reconstruction fails.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerOctetString.#ctor(System.Byte[])">
            <param name="str">The octets making up the octet string.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerOctetString.ToBytes(System.Collections.IEnumerable)">
            convert a vector of octet strings into a single byte string
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerOctetString.#ctor(System.Byte[])">
            <param name="str">The octets making up the octet string.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerOctetString.GetEnumerator">
            return the DER octets that make up this string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSequence.#ctor">
            create an empty sequence
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSequence.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable)">
            create a sequence containing one object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSequence.#ctor(Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            create a sequence containing a vector of objects.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSequence.#ctor">
            create an empty sequence
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSequence.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable)">
            create a sequence containing one object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSequence.#ctor(Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            create a sequence containing a vector of objects.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerSet">
            A Der encoded set object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSet.#ctor">
            create an empty set
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSet.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param obj - a single object that makes up the set.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerSet.#ctor(Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            @param v - a vector of objects making up the set.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSet.#ctor">
            create an empty sequence
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSet.#ctor(Org.BouncyCastle.Asn1.Asn1Encodable)">
            create a set containing one object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerSet.#ctor(Org.BouncyCastle.Asn1.Asn1EncodableVector)">
            create a set containing a vector of objects.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.BerTaggedObject">
            BER TaggedObject - in ASN.1 notation this is any object preceded by
            a [n] where n is some number - these are assumed to follow the construction
            rules (as with sequences).
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerTaggedObject">
            DER TaggedObject - in ASN.1 notation this is any object preceded by
            a [n] where n is some number - these are assumed to follow the construction
            rules (as with sequences).
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerTaggedObject.#ctor(System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerTaggedObject.#ctor(System.Boolean,System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param explicitly true if an explicitly tagged object.
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerTaggedObject.#ctor(System.Int32)">
            create an implicitly tagged object that contains a zero
            length sequence.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerTaggedObject.#ctor(System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerTaggedObject.#ctor(System.Boolean,System.Int32,Org.BouncyCastle.Asn1.Asn1Encodable)">
            @param explicitly true if an explicitly tagged object.
            @param tagNo the tag number for this object.
            @param obj the tagged object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.BerTaggedObject.#ctor(System.Int32)">
            create an implicitly tagged object that contains a zero
            length sequence.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves">
            table of the available named parameters for GOST 3410-2001.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the ECDomainParameters object for the given OID, null if it
             isn't present.
            
             @param oid an object identifier representing a named parameters, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return the named curve name represented by the given object identifier.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.CryptoPro.ECGost3410NamedCurves.Names">
            returns an enumeration containing the name strings for curves
            contained in this structure.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.CryptoPro.Gost3410NamedParameters">
            table of the available named parameters for GOST 3410-94.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.CryptoPro.Gost3410NamedParameters.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the GOST3410ParamSetParameters object for the given OID, null if it
             isn't present.
            
             @param oid an object identifier representing a named parameters, if present.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.CryptoPro.Gost3410NamedParameters.Names">
            returns an enumeration containing the name strings for parameters
            contained in this structure.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IAsn1String">
            basic interface for Der string objects.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBitString.GetPadBits(System.Int32)">
            return the correct number of pad bits for a bit string defined in
            a 32 bit constant
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBitString.GetBytes(System.Int32)">
            return the correct number of bytes for a bit string defined in
            a 32 bit constant
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBitString.GetInstance(System.Object)">
             return a Bit string from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBitString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Bit string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBitString.#ctor(System.Byte[],System.Int32)">
            @param data the octets making up the bit string.
            @param padBits the number of extra bits at the end of the string.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerBitString.IntValue">
            @return the value of the bit string as an int (truncating if necessary)
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerBmpString">
            Der BMPString object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBmpString.GetInstance(System.Object)">
             return a BMP string from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBmpString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a BMP string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                          be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBmpString.#ctor(System.Byte[])">
            basic constructor - byte encoded string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBmpString.#ctor(System.String)">
            basic constructor
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBoolean.GetInstance(System.Object)">
             return a bool from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBoolean.GetInstance(System.Boolean)">
            return a DerBoolean from the passed in bool.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerBoolean.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Boolean from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerEnumerated.GetInstance(System.Object)">
             return an integer from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerEnumerated.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an Enumerated from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerExternal">
            Class representing the DER-type External
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerExternal.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.DerInteger,Org.BouncyCastle.Asn1.Asn1Object,Org.BouncyCastle.Asn1.DerTaggedObject)">
            Creates a new instance of DerExternal
            See X.690 for more informations about the meaning of these parameters
            @param directReference The direct reference or <code>null</code> if not set.
            @param indirectReference The indirect reference or <code>null</code> if not set.
            @param dataValueDescriptor The data value descriptor or <code>null</code> if not set.
            @param externalData The external data in its encoded form.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerExternal.#ctor(Org.BouncyCastle.Asn1.DerObjectIdentifier,Org.BouncyCastle.Asn1.DerInteger,Org.BouncyCastle.Asn1.Asn1Object,System.Int32,Org.BouncyCastle.Asn1.Asn1Object)">
            Creates a new instance of DerExternal.
            See X.690 for more informations about the meaning of these parameters
            @param directReference The direct reference or <code>null</code> if not set.
            @param indirectReference The indirect reference or <code>null</code> if not set.
            @param dataValueDescriptor The data value descriptor or <code>null</code> if not set.
            @param encoding The encoding to be used for the external data
            @param externalData The external data
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerExternal.Encoding">
            The encoding of the content. Valid values are
            <ul>
            <li><code>0</code> single-ASN1-type</li>
            <li><code>1</code> OCTET STRING</li>
            <li><code>2</code> BIT STRING</li>
            </ul>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerGeneralizedTime">
            Generalized time object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGeneralizedTime.GetInstance(System.Object)">
             return a generalized time from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGeneralizedTime.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Generalized Time object from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGeneralizedTime.#ctor(System.String)">
             The correct format for this is YYYYMMDDHHMMSS[.f]Z, or without the Z
             for local time, or Z+-HHMM on the end, for difference between local
             time and UTC time. The fractional second amount f must consist of at
             least one number with trailing zeroes removed.
            
             @param time the time string.
             @exception ArgumentException if string is an illegal format.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGeneralizedTime.#ctor(System.DateTime)">
            base constructor from a local time object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerGeneralizedTime.GetTime">
            return the time - always in the form of
             YYYYMMDDhhmmssGMT(+hh:mm|-hh:mm).
            <p>
            Normally in a certificate we would expect "Z" rather than "GMT",
            however adding the "GMT" means we can just use:
            <pre>
                dateF = new SimpleDateFormat("yyyyMMddHHmmssz");
            </pre>
            To read in the time and Get a date which is compatible with our local
            time zone.</p>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerGeneralizedTime.TimeString">
            Return the time.
            @return The time string as it appeared in the encoded object.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerIA5String">
            Der IA5String object - this is an ascii string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.GetInstance(System.Object)">
             return a IA5 string from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an IA5 string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.#ctor(System.Byte[])">
            basic constructor - with bytes.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.#ctor(System.String)">
            basic constructor - without validation.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.#ctor(System.String,System.Boolean)">
             Constructor with optional validation.
            
             @param string the base string to wrap.
             @param validate whether or not to check the string.
             @throws ArgumentException if validate is true and the string
             contains characters that should not be in an IA5String.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerIA5String.IsIA5String(System.String)">
             return true if the passed in String can be represented without
             loss as an IA5String, false otherwise.
            
             @return true if in printable set, false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerInteger.GetInstance(System.Object)">
             return an integer from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerInteger.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an Integer from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param isExplicit true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerInteger.PositiveValue">
            in some cases positive values Get crammed into a space,
            that's not quite big enough...
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerNull">
            A Null object.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerNumericString">
            Der NumericString object - this is an ascii string of characters {0,1,2,3,4,5,6,7,8,9, }.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.GetInstance(System.Object)">
             return a Numeric string from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an Numeric string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.#ctor(System.Byte[])">
            basic constructor - with bytes.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.#ctor(System.String)">
            basic constructor -  without validation..
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.#ctor(System.String,System.Boolean)">
             Constructor with optional validation.
            
             @param string the base string to wrap.
             @param validate whether or not to check the string.
             @throws ArgumentException if validate is true and the string
             contains characters that should not be in a NumericString.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerNumericString.IsNumericString(System.String)">
             Return true if the string can be represented as a NumericString ('0'..'9', ' ')
            
             @param str string to validate.
             @return true if numeric, fale otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerObjectIdentifier.GetInstance(System.Object)">
             return an Oid from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerObjectIdentifier.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an object Identifier from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerObjectIdentifier.On(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            Return  true if this oid is an extension of the passed in branch, stem.
            @param stem the arc or branch that is a possible parent.
            @return  true if the branch is on the passed in stem, false otherwise.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerPrintableString">
            Der PrintableString object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.GetInstance(System.Object)">
             return a printable string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Printable string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.#ctor(System.Byte[])">
            basic constructor - byte encoded string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.#ctor(System.String)">
            basic constructor - this does not validate the string
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.#ctor(System.String,System.Boolean)">
             Constructor with optional validation.
            
             @param string the base string to wrap.
             @param validate whether or not to check the string.
             @throws ArgumentException if validate is true and the string
             contains characters that should not be in a PrintableString.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerPrintableString.IsPrintableString(System.String)">
             return true if the passed in String can be represented without
             loss as a PrintableString, false otherwise.
            
             @return true if in printable set, false otherwise.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerT61String">
            Der T61String (also the teletex string) - 8-bit characters
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerT61String.GetInstance(System.Object)">
             return a T61 string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerT61String.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an T61 string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerT61String.#ctor(System.Byte[])">
            basic constructor - with bytes.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerT61String.#ctor(System.String)">
            basic constructor - with string.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerUniversalString">
            Der UniversalString object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUniversalString.GetInstance(System.Object)">
             return a Universal string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUniversalString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Universal string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUniversalString.#ctor(System.Byte[])">
            basic constructor - byte encoded string.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerUtcTime">
            UTC time object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.GetInstance(System.Object)">
             return an UTC Time from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an UTC Time from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.#ctor(System.String)">
            The correct format for this is YYMMDDHHMMSSZ (it used to be that seconds were
            never encoded. When you're creating one of these objects from scratch, that's
            what you want to use, otherwise we'll try to deal with whatever Gets read from
            the input stream... (this is why the input format is different from the GetTime()
            method output).
            <p>
            @param time the time string.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.#ctor(System.DateTime)">
            base constructor from a DateTime object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.ToDateTime">
             return the time as a date based on whatever a 2 digit year will return. For
             standardised processing use ToAdjustedDateTime().
            
             @return the resulting date
             @exception ParseException if the date string cannot be parsed.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtcTime.ToAdjustedDateTime">
             return the time as an adjusted date
             in the range of 1950 - 2049.
            
             @return a date in the range of 1950 to 2049.
             @exception ParseException if the date string cannot be parsed.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerUtcTime.TimeString">
            return the time - always in the form of
             YYMMDDhhmmssGMT(+hh:mm|-hh:mm).
            <p>
            Normally in a certificate we would expect "Z" rather than "GMT",
            however adding the "GMT" means we can just use:
            <pre>
                dateF = new SimpleDateFormat("yyMMddHHmmssz");
            </pre>
            To read in the time and Get a date which is compatible with our local
            time zone.</p>
            <p>
            <b>Note:</b> In some cases, due to the local date processing, this
            may lead to unexpected results. If you want to stick the normal
            convention of 1950 to 2049 use the GetAdjustedTime() method.</p>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.DerUtcTime.AdjustedTimeString">
            <summary>
            Return a time string as an adjusted date with a 4 digit year.
            This goes in the range of 1950 - 2049.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerUtf8String">
            Der UTF8String object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtf8String.GetInstance(System.Object)">
             return an UTF8 string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtf8String.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return an UTF8 string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtf8String.#ctor(System.Byte[])">
            basic constructor - byte encoded string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerUtf8String.#ctor(System.String)">
            basic constructor
        </member>
        <member name="T:Org.BouncyCastle.Asn1.DerVisibleString">
            Der VisibleString object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVisibleString.GetInstance(System.Object)">
             return a Visible string from the passed in object.
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVisibleString.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             return a Visible string from a tagged object.
            
             @param obj the tagged object holding the object we want
             @param explicitly true if the object is meant to be explicitly
                          tagged false otherwise.
             @exception ArgumentException if the tagged object cannot
                           be converted.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVisibleString.#ctor(System.Byte[])">
            basic constructor - byte encoded string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.DerVisibleString.#ctor(System.String)">
            basic constructor
        </member>
        <member name="T:Org.BouncyCastle.Asn1.IAsn1Choice">
            Marker interface for CHOICE objects - if you implement this in a roll-your-own
            object, any attempt to tag the object implicitly will convert the tag to an
            explicit one as the encoding rules require.
            <p>
            If you use this interface your class should also implement the getInstance
            pattern which takes a tag object and the tagging mode used. 
            </p>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Misc.NetscapeCertType">
            The NetscapeCertType object.
            <pre>
               NetscapeCertType ::= BIT STRING {
                    SSLClient               (0),
                    SSLServer               (1),
                    S/MIME                  (2),
                    Object Signing          (3),
                    Reserved                (4),
                    SSL CA                  (5),
                    S/MIME CA               (6),
                    Object Signing CA       (7) }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Misc.NetscapeCertType.#ctor(System.Int32)">
             Basic constructor.
            
             @param usage - the bitwise OR of the Key Usage flags giving the
             allowed uses for the key.
             e.g. (X509NetscapeCertType.sslCA | X509NetscapeCertType.smimeCA)
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Nist.NistNamedCurves">
            Utility class for fetching curves using their NIST names as published in FIPS-PUB 186-3
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Nist.NistNamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the X9ECParameters object for the named curve represented by
             the passed in object identifier. Null if the curve isn't present.
            
             @param oid an object identifier representing a named curve, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Nist.NistNamedCurves.GetOid(System.String)">
             return the object identifier signified by the passed in name. Null
             if there is no object identifier associated with name.
            
             @return the object identifier associated with name, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Nist.NistNamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return the named curve name represented by the given object identifier.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Nist.NistNamedCurves.Names">
            returns an enumeration containing the name strings for curves
            contained in this structure.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.OcspResponse.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            OcspResponse ::= Sequence {
                responseStatus         OcspResponseStatus,
                responseBytes          [0] EXPLICIT ResponseBytes OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.OcspResponseStatus.#ctor(System.Int32)">
            The OcspResponseStatus enumeration.
            <pre>
            OcspResponseStatus ::= Enumerated {
                successful            (0),  --Response has valid confirmations
                malformedRequest      (1),  --Illegal confirmation request
                internalError         (2),  --Internal error in issuer
                tryLater              (3),  --Try again later
                                            --(4) is not used
                sigRequired           (5),  --Must sign the request
                unauthorized          (6)   --Request unauthorized
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.ResponderID.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ResponderID ::= CHOICE {
                 byName          [1] Name,
                 byKey           [2] KeyHash }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Ocsp.ResponseBytes.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ResponseBytes ::=       Sequence {
                responseType   OBJECT IDENTIFIER,
                response       OCTET STRING }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.OidTokenizer">
            class for breaking up an Oid into it's component tokens, ala
            java.util.StringTokenizer. We need this class as some of the
            lightweight Java environment don't support classes like
            StringTokenizer.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.ContentInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            ContentInfo ::= Sequence {
                     contentType ContentType,
                     content
                     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.RsassaPssParameters.#ctor">
            The default version
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.RsassaPssParameters.ToAsn1Object">
             <pre>
             RSASSA-PSS-params ::= SEQUENCE {
               hashAlgorithm      [0] OAEP-PSSDigestAlgorithms  DEFAULT sha1,
                maskGenAlgorithm   [1] PKCS1MGFAlgorithms  DEFAULT mgf1SHA1,
                saltLength         [2] INTEGER  DEFAULT 20,
                trailerField       [3] TrailerField  DEFAULT trailerFieldBC
              }
            
             OAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
                { OID id-sha1 PARAMETERS NULL   }|
                { OID id-sha256 PARAMETERS NULL }|
                { OID id-sha384 PARAMETERS NULL }|
                { OID id-sha512 PARAMETERS NULL },
                ...  -- Allows for future expansion --
             }
            
             PKCS1MGFAlgorithms    ALGORITHM-IDENTIFIER ::= {
               { OID id-mgf1 PARAMETERS OAEP-PSSDigestAlgorithms },
                ...  -- Allows for future expansion --
             }
            
             TrailerField ::= INTEGER { trailerFieldBC(1) }
             </pre>
             @return the asn1 primitive representing the parameters.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.Pkcs.SignedData">
            a Pkcs#7 signed data object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Pkcs.SignedData.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             SignedData ::= Sequence {
                 version Version,
                 digestAlgorithms DigestAlgorithmIdentifiers,
                 contentInfo ContentInfo,
                 certificates
                     [0] IMPLICIT ExtendedCertificatesAndCertificates
                              OPTIONAL,
                 crls
                     [1] IMPLICIT CertificateRevocationLists OPTIONAL,
                 signerInfos SignerInfos }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Sec.SecNamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the X9ECParameters object for the named curve represented by
             the passed in object identifier. Null if the curve isn't present.
            
             @param oid an object identifier representing a named curve, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Sec.SecNamedCurves.GetOid(System.String)">
             return the object identifier signified by the passed in name. Null
             if there is no object identifier associated with name.
            
             @return the object identifier associated with name, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Sec.SecNamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return the named curve name represented by the given object identifier.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.Sec.SecNamedCurves.Names">
            returns an enumeration containing the name strings for curves
            contained in this structure.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.Sec.SecObjectIdentifiers.EllipticCurve">
            EllipticCurve OBJECT IDENTIFIER ::= {
                  iso(1) identified-organization(3) certicom(132) curve(0)
            }
        </member>
        <member name="T:Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves">
            elliptic curves defined in "ECC Brainpool Standard Curves and Curve Generation"
            http://www.ecc-brainpool.org/download/draft_pkix_additional_ecc_dp.txt
        </member>
        <member name="M:Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the X9ECParameters object for the named curve represented by
             the passed in object identifier. Null if the curve isn't present.
            
             @param oid an object identifier representing a named curve, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.GetOid(System.String)">
             return the object identifier signified by the passed in name. Null
             if there is no object identifier associated with name.
            
             @return the object identifier associated with name, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return the named curve name represented by the given object identifier.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.TeleTrust.TeleTrusTNamedCurves.Names">
            returns an enumeration containing the name strings for curves
            contained in this structure.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Utilities.Asn1Dump.AsString(System.String,System.Boolean,Org.BouncyCastle.Asn1.Asn1Object,System.Text.StringBuilder)">
             dump a Der object as a formatted string with indentation
            
             @param obj the Asn1Object to be dumped out.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Utilities.Asn1Dump.DumpAsString(Org.BouncyCastle.Asn1.Asn1Encodable)">
             dump out a DER object as a formatted string, in non-verbose mode
            
             @param obj the Asn1Encodable to be dumped out.
             @return  the resulting string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.Utilities.Asn1Dump.DumpAsString(Org.BouncyCastle.Asn1.Asn1Encodable,System.Boolean)">
             Dump out the object as a string
            
             @param obj the Asn1Encodable to be dumped out.
             @param verbose  if true, dump out the contents of octet and bit strings.
             @return  the resulting string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.AlgorithmIdentifier.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
                 AlgorithmIdentifier ::= Sequence {
                                       algorithm OBJECT IDENTIFIER,
                                       parameters ANY DEFINED BY algorithm OPTIONAL }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.BasicConstraints.#ctor(System.Int32)">
             create a cA=true object for the given path length constraint.
            
             @param pathLenConstraint
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.BasicConstraints.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            BasicConstraints := Sequence {
               cA                  Boolean DEFAULT FALSE,
               pathLenConstraint   Integer (0..MAX) OPTIONAL
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.CertificateList">
             PKIX RFC-2459
            
             The X.509 v2 CRL syntax is as follows.  For signature calculation,
             the data that is to be signed is ASN.1 Der encoded.
            
             <pre>
             CertificateList  ::=  Sequence  {
                  tbsCertList          TbsCertList,
                  signatureAlgorithm   AlgorithmIdentifier,
                  signatureValue       BIT STRING  }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.CrlDistPoint.GetDistributionPoints">
             Return the distribution points making up the sequence.
            
             @return DistributionPoint[]
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.CrlDistPoint.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            CrlDistPoint ::= Sequence SIZE {1..MAX} OF DistributionPoint
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.CrlNumber">
            The CRLNumber object.
            <pre>
            CRLNumber::= Integer(0..MAX)
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.CrlReason">
            The CRLReason enumeration.
            <pre>
            CRLReason ::= Enumerated {
             unspecified             (0),
             keyCompromise           (1),
             cACompromise            (2),
             affiliationChanged      (3),
             superseded              (4),
             cessationOfOperation    (5),
             certificateHold         (6),
             removeFromCRL           (8),
             privilegeWithdrawn      (9),
             aACompromise           (10)
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.DigestInfo">
            The DigestInfo object.
            <pre>
            DigestInfo::=Sequence{
                     digestAlgorithm  AlgorithmIdentifier,
                     digest OCTET STRING }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.DistributionPoint">
            The DistributionPoint object.
            <pre>
            DistributionPoint ::= Sequence {
                 distributionPoint [0] DistributionPointName OPTIONAL,
                 reasons           [1] ReasonFlags OPTIONAL,
                 cRLIssuer         [2] GeneralNames OPTIONAL
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.DistributionPointName">
            The DistributionPointName object.
            <pre>
            DistributionPointName ::= CHOICE {
                fullName                 [0] GeneralNames,
                nameRelativeToCRLIssuer  [1] RDN
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.GeneralName">
             The GeneralName object.
             <pre>
             GeneralName ::= CHOICE {
                  otherName                       [0]     OtherName,
                  rfc822Name                      [1]     IA5String,
                  dNSName                         [2]     IA5String,
                  x400Address                     [3]     ORAddress,
                  directoryName                   [4]     Name,
                  ediPartyName                    [5]     EDIPartyName,
                  uniformResourceIdentifier       [6]     IA5String,
                  iPAddress                       [7]     OCTET STRING,
                  registeredID                    [8]     OBJECT IDENTIFIER}
            
             OtherName ::= Sequence {
                  type-id    OBJECT IDENTIFIER,
                  value      [0] EXPLICIT ANY DEFINED BY type-id }
            
             EDIPartyName ::= Sequence {
                  nameAssigner            [0]     DirectoryString OPTIONAL,
                  partyName               [1]     DirectoryString }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralName.#ctor(Org.BouncyCastle.Asn1.Asn1Object,System.Int32)">
             When the subjectAltName extension contains an Internet mail address,
             the address MUST be included as an rfc822Name. The format of an
             rfc822Name is an "addr-spec" as defined in RFC 822 [RFC 822].
            
             When the subjectAltName extension contains a domain name service
             label, the domain name MUST be stored in the dNSName (an IA5String).
             The name MUST be in the "preferred name syntax," as specified by RFC
             1034 [RFC 1034].
            
             When the subjectAltName extension contains a URI, the name MUST be
             stored in the uniformResourceIdentifier (an IA5String). The name MUST
             be a non-relative URL, and MUST follow the URL syntax and encoding
             rules specified in [RFC 1738].  The name must include both a scheme
             (e.g., "http" or "ftp") and a scheme-specific-part.  The scheme-
             specific-part must include a fully qualified domain name or IP
             address as the host.
            
             When the subjectAltName extension contains a iPAddress, the address
             MUST be stored in the octet string in "network byte order," as
             specified in RFC 791 [RFC 791]. The least significant bit (LSB) of
             each octet is the LSB of the corresponding byte in the network
             address. For IP Version 4, as specified in RFC 791, the octet string
             MUST contain exactly four octets.  For IP Version 6, as specified in
             RFC 1883, the octet string MUST contain exactly sixteen octets [RFC
             1883].
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralName.#ctor(System.Int32,System.String)">
             Create a GeneralName for the given tag from the passed in string.
             <p>
             This constructor can handle:
             <ul>
             <li>rfc822Name</li>
             <li>iPAddress</li>
             <li>directoryName</li>
             <li>dNSName</li>
             <li>uniformResourceIdentifier</li>
             <li>registeredID</li>
             </ul>
             For x400Address, otherName and ediPartyName there is no common string
             format defined.
             </p><p>
             Note: A directory name can be encoded in different ways into a byte
             representation. Be aware of this if the byte representation is used for
             comparing results.
             </p>
            
             @param tag tag number
             @param name string representation of name
             @throws ArgumentException if the string encoding is not correct or
                         not supported.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralNames.#ctor(Org.BouncyCastle.Asn1.X509.GeneralName)">
            <summary>Construct a GeneralNames object containing one GeneralName.</summary>
            <param name="name">The name to be contained.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.GeneralNames.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            GeneralNames ::= Sequence SIZE {1..MAX} OF GeneralName
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint">
            <pre>
            IssuingDistributionPoint ::= SEQUENCE { 
              distributionPoint          [0] DistributionPointName OPTIONAL, 
              onlyContainsUserCerts      [1] BOOLEAN DEFAULT FALSE, 
              onlyContainsCACerts        [2] BOOLEAN DEFAULT FALSE, 
              onlySomeReasons            [3] ReasonFlags OPTIONAL, 
              indirectCRL                [4] BOOLEAN DEFAULT FALSE,
              onlyContainsAttributeCerts [5] BOOLEAN DEFAULT FALSE }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint.#ctor(Org.BouncyCastle.Asn1.X509.DistributionPointName,System.Boolean,System.Boolean,Org.BouncyCastle.Asn1.X509.ReasonFlags,System.Boolean,System.Boolean)">
            Constructor from given details.
            
            @param distributionPoint
                       May contain an URI as pointer to most current CRL.
            @param onlyContainsUserCerts Covers revocation information for end certificates.
            @param onlyContainsCACerts Covers revocation information for CA certificates.
            
            @param onlySomeReasons
                       Which revocation reasons does this point cover.
            @param indirectCRL
                       If <code>true</code> then the CRL contains revocation
                       information about certificates ssued by other CAs.
            @param onlyContainsAttributeCerts Covers revocation information for attribute certificates.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
            Constructor from Asn1Sequence
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint.DistributionPoint">
            @return Returns the distributionPoint.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.IssuingDistributionPoint.OnlySomeReasons">
            @return Returns the onlySomeReasons.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.KeyUsage">
             The KeyUsage object.
             <pre>
                id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }
            
                KeyUsage ::= BIT STRING {
                     digitalSignature        (0),
                     nonRepudiation          (1),
                     keyEncipherment         (2),
                     dataEncipherment        (3),
                     keyAgreement            (4),
                     keyCertSign             (5),
                     cRLSign                 (6),
                     encipherOnly            (7),
                     decipherOnly            (8) }
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.KeyUsage.#ctor(System.Int32)">
             Basic constructor.
            
             @param usage - the bitwise OR of the Key Usage flags giving the
             allowed uses for the key.
             e.g. (KeyUsage.keyEncipherment | KeyUsage.dataEncipherment)
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.ReasonFlags">
            The ReasonFlags object.
            <pre>
            ReasonFlags ::= BIT STRING {
               unused(0),
               keyCompromise(1),
               cACompromise(2),
               affiliationChanged(3),
               superseded(4),
               cessationOfOperation(5),
               certficateHold(6)
            }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.ReasonFlags.#ctor(System.Int32)">
            @param reasons - the bitwise OR of the Key Reason flags giving the
            allowed uses for the key.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.RsaPublicKeyStructure.ToAsn1Object">
            This outputs the key in Pkcs1v2 format.
            <pre>
                 RSAPublicKey ::= Sequence {
                                     modulus Integer, -- n
                                     publicExponent Integer, -- e
                                 }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo">
            The object that contains the public key stored in a certficate.
            <p>
            The GetEncoded() method in the public keys in the JCE produces a DER
            encoded one of these.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo.GetPublicKey">
             for when the public key is an encoded object - if the bitstring
             can't be decoded this routine raises an IOException.
            
             @exception IOException - if the bit string doesn't represent a Der
             encoded object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            SubjectPublicKeyInfo ::= Sequence {
                                     algorithm AlgorithmIdentifier,
                                     publicKey BIT STRING }
            </pre>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.SubjectPublicKeyInfo.PublicKeyData">
            for when the public key is raw bits...
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.TbsCertificateStructure">
            The TbsCertificate object.
            <pre>
            TbsCertificate ::= Sequence {
                 version          [ 0 ]  Version DEFAULT v1(0),
                 serialNumber            CertificateSerialNumber,
                 signature               AlgorithmIdentifier,
                 issuer                  Name,
                 validity                Validity,
                 subject                 Name,
                 subjectPublicKeyInfo    SubjectPublicKeyInfo,
                 issuerUniqueID    [ 1 ] IMPLICIT UniqueIdentifier OPTIONAL,
                 subjectUniqueID   [ 2 ] IMPLICIT UniqueIdentifier OPTIONAL,
                 extensions        [ 3 ] Extensions OPTIONAL
                 }
            </pre>
            <p>
            Note: issuerUniqueID and subjectUniqueID are both deprecated by the IETF. This class
            will parse them, but you really shouldn't be creating new ones.</p>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.TbsCertificateList">
            PKIX RFC-2459 - TbsCertList object.
            <pre>
            TbsCertList  ::=  Sequence  {
                 version                 Version OPTIONAL,
                                              -- if present, shall be v2
                 signature               AlgorithmIdentifier,
                 issuer                  Name,
                 thisUpdate              Time,
                 nextUpdate              Time OPTIONAL,
                 revokedCertificates     Sequence OF Sequence  {
                      userCertificate         CertificateSerialNumber,
                      revocationDate          Time,
                      crlEntryExtensions      Extensions OPTIONAL
                                                    -- if present, shall be v2
                                           }  OPTIONAL,
                 crlExtensions           [0]  EXPLICIT Extensions OPTIONAL
                                                    -- if present, shall be v2
                                           }
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Time.#ctor(System.DateTime)">
            creates a time object from a given date - if the date is between 1950
            and 2049 a UTCTime object is Generated, otherwise a GeneralizedTime
            is used.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Time.ToDateTime">
            <summary>
            Return our time as DateTime.
            </summary>
            <returns>A date time.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.Time.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Time ::= CHOICE {
                        utcTime        UTCTime,
                        generalTime    GeneralizedTime }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509CertificateStructure">
            an X509Certificate structure.
            <pre>
             Certificate ::= Sequence {
                 tbsCertificate          TbsCertificate,
                 signatureAlgorithm      AlgorithmIdentifier,
                 signature               BIT STRING
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509DefaultEntryConverter">
            The default converter for X509 DN entries when going from their
            string value to ASN.1 strings.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509NameEntryConverter">
                 * It turns out that the number of standard ways the fields in a DN should be
                 * encoded into their ASN.1 counterparts is rapidly approaching the
                 * number of machines on the internet. By default the X509Name class
                 * will produce UTF8Strings in line with the current recommendations (RFC 3280).
                 * <p>
                 * An example of an encoder look like below:
                 * <pre>
                 * public class X509DirEntryConverter
                 *     : X509NameEntryConverter
                 * {
                 *     public Asn1Object GetConvertedValue(
                 *         DerObjectIdentifier  oid,
                 *         string               value)
                 *     {
                 *         if (str.Length() != 0 &amp;&amp; str.charAt(0) == '#')
                 *         {
                 *             return ConvertHexEncoded(str, 1);
                 *         }
                 *         if (oid.Equals(EmailAddress))
                 *         {
                 *             return new DerIA5String(str);
                 *         }
                 *         else if (CanBePrintable(str))
                 *         {
                 *             return new DerPrintableString(str);
                 *         }
                 *         else if (CanBeUTF8(str))
                 *         {
                 *             return new DerUtf8String(str);
                 *         }
                 *         else
                 *         {
                 *             return new DerBmpString(str);
                 *         }
                 *     }
                 * }
            	 * </pre>
            	 * </p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509NameEntryConverter.ConvertHexEncoded(System.String,System.Int32)">
             Convert an inline encoded hex string rendition of an ASN.1
             object back into its corresponding ASN.1 object.
            
             @param str the hex encoded object
             @param off the index at which the encoding starts
             @return the decoded object
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509NameEntryConverter.CanBePrintable(System.String)">
            return true if the passed in string can be represented without
            loss as a PrintableString, false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509NameEntryConverter.GetConvertedValue(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.String)">
             Convert the passed in string value into the appropriate ASN.1
             encoded object.
            
             @param oid the oid associated with the value in the DN.
             @param value the value of the particular DN component.
             @return the ASN.1 equivalent for the value.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509DefaultEntryConverter.GetConvertedValue(Org.BouncyCastle.Asn1.DerObjectIdentifier,System.String)">
             Apply default conversion for the given value depending on the oid
             and the character range of the value.
            
             @param oid the object identifier for the DN entry
             @param value the value associated with it
             @return the ASN.1 equivalent for the string value.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509Extension">
            an object for the elements in the X.509 V3 extension block.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extension.ConvertValueToObject(Org.BouncyCastle.Asn1.X509.X509Extension)">
            <sumary>Convert the value of the passed in extension to an object.</sumary>
            <param name="ext">The extension to parse.</param>
            <returns>The object the value string contains.</returns>
            <exception cref="T:System.ArgumentException">If conversion is not possible.</exception>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.SubjectDirectoryAttributes">
            Subject Directory Attributes
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.SubjectKeyIdentifier">
            Subject Key Identifier
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.KeyUsage">
            Key Usage
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.PrivateKeyUsagePeriod">
            Private Key Usage Period
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.SubjectAlternativeName">
            Subject Alternative Name
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.IssuerAlternativeName">
            Issuer Alternative Name
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.BasicConstraints">
            Basic Constraints
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.CrlNumber">
            CRL Number
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.ReasonCode">
            Reason code
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.InstructionCode">
            Hold Instruction Code
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.InvalidityDate">
            Invalidity Date
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.DeltaCrlIndicator">
            Delta CRL indicator
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.IssuingDistributionPoint">
            Issuing Distribution Point
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.CertificateIssuer">
            Certificate Issuer
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.NameConstraints">
            Name Constraints
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.CrlDistributionPoints">
            CRL Distribution Points
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.CertificatePolicies">
            Certificate Policies
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.PolicyMappings">
            Policy Mappings
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.AuthorityKeyIdentifier">
            Authority Key Identifier
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.PolicyConstraints">
            Policy Constraints
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.ExtendedKeyUsage">
            Extended Key Usage
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.FreshestCrl">
            Freshest CRL
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.InhibitAnyPolicy">
            Inhibit Any Policy
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.AuthorityInfoAccess">
            Authority Info Access
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.SubjectInfoAccess">
            Subject Info Access
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.LogoType">
            Logo Type
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.BiometricInfo">
            BiometricInfo
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.QCStatements">
            QCStatements
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.AuditIdentity">
            Audit identity extension in attribute certificates.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.NoRevAvail">
            NoRevAvail extension in attribute certificates.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Extensions.TargetInformation">
            TargetInformation extension in attribute certificates.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence.
            
             the extensions are a list of constructed sequences, either with (Oid, OctetString) or (Oid, Boolean, OctetString)
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(System.Collections.IDictionary)">
            constructor from a table of extensions.
            <p>
            it's is assumed the table contains Oid/string pairs.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(System.Collections.IList,System.Collections.IDictionary)">
            Constructor from a table of extensions with ordering.
            <p>
            It's is assumed the table contains Oid/string pairs.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.#ctor(System.Collections.IList,System.Collections.IList)">
             Constructor from two vectors
            
             @param objectIDs an ArrayList of the object identifiers.
             @param values an ArrayList of the extension values.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.GetExtension(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the extension represented by the object identifier
             passed in.
            
             @return the extension if it's present, null otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Extensions.ToAsn1Object">
             <pre>
                 Extensions        ::=   SEQUENCE SIZE (1..MAX) OF Extension
            
                 Extension         ::=   SEQUENCE {
                    extnId            EXTENSION.&amp;id ({ExtensionSet}),
                    critical          BOOLEAN DEFAULT FALSE,
                    extnValue         OCTET STRING }
             </pre>
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.X509Extensions.ExtensionOids">
            return an Enumeration of the extension field's object ids.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509Name">
             <pre>
                 RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
            
                 RelativeDistinguishedName ::= SET SIZE (1..MAX) OF AttributeTypeAndValue
            
                 AttributeTypeAndValue ::= SEQUENCE {
                                               type  OBJECT IDENTIFIER,
                                               value ANY }
             </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.C">
            country code - StringType(SIZE(2))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.O">
            organization - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.OU">
            organizational unit name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.T">
            Title
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.CN">
            common name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.Street">
            street - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.SerialNumber">
            device serial number name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.L">
            locality name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.ST">
            state, or province name - StringType(SIZE(1..64))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.Surname">
            Naming attributes of type X520name
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.BusinessCategory">
            businessCategory - DirectoryString(SIZE(1..128)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.PostalCode">
            postalCode - DirectoryString(SIZE(1..40)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.DnQualifier">
            dnQualifier - DirectoryString(SIZE(1..64)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.Pseudonym">
            RFC 3039 Pseudonym - DirectoryString(SIZE(1..64)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.DateOfBirth">
            RFC 3039 DateOfBirth - GeneralizedTime - YYYYMMDD000000Z
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.PlaceOfBirth">
            RFC 3039 PlaceOfBirth - DirectoryString(SIZE(1..128)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.Gender">
            RFC 3039 DateOfBirth - PrintableString (SIZE(1)) -- "M", "F", "m" or "f"
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.CountryOfCitizenship">
            RFC 3039 CountryOfCitizenship - PrintableString (SIZE (2)) -- ISO 3166
            codes only
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.CountryOfResidence">
            RFC 3039 CountryOfCitizenship - PrintableString (SIZE (2)) -- ISO 3166
            codes only
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.NameAtBirth">
            ISIS-MTT NameAtBirth - DirectoryString(SIZE(1..64)
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.PostalAddress">
            RFC 3039 PostalAddress - SEQUENCE SIZE (1..6) OF
            DirectoryString(SIZE(1..30))
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.DmdName">
            RFC 2256 dmdName
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.TelephoneNumber">
            id-at-telephoneNumber
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.Name">
            id-at-name
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.EmailAddress">
            Email address (RSA PKCS#9 extension) - IA5String.
            <p>Note: if you're trying to be ultra orthodox, don't use this! It shouldn't be in here.</p>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.UnstructuredName">
            more from PKCS#9
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.E">
            email address in Verisign certificates
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.UID">
            LDAP User id.
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.DefaultSymbols">
            default look up table translating OID values into their common symbols following
            the convention in RFC 2253 with a few extras
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.RFC2253Symbols">
            look up table translating OID values into their common symbols following the convention in RFC 2253
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.RFC1779Symbols">
             look up table translating OID values into their common symbols following the convention in RFC 1779
            
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X509.X509Name.DefaultLookup">
            look up table translating common symbols into their OIDS.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.GetInstance(Org.BouncyCastle.Asn1.Asn1TaggedObject,System.Boolean)">
             Return a X509Name based on the passed in tagged object.
            
             @param obj tag object holding name.
             @param explicitly true if explicitly tagged false otherwise.
             @return the X509Name
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(Org.BouncyCastle.Asn1.Asn1Sequence)">
             Constructor from Asn1Sequence
            
             the principal will be a list of constructed sets, each containing an (OID, string) pair.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Collections.IList,System.Collections.IDictionary)">
            Constructor from a table of attributes with ordering.
            <p>
            it's is assumed the table contains OID/string pairs, and the contents
            of the table are copied into an internal table as part of the
            construction process. The ordering ArrayList should contain the OIDs
            in the order they are meant to be encoded or printed in ToString.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Collections.IList,System.Collections.IDictionary,Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Constructor from a table of attributes with ordering.
            <p>
            it's is assumed the table contains OID/string pairs, and the contents
            of the table are copied into an internal table as part of the
            construction process. The ordering ArrayList should contain the OIDs
            in the order they are meant to be encoded or printed in ToString.</p>
            <p>
            The passed in converter will be used to convert the strings into their
            ASN.1 counterparts.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Collections.IList,System.Collections.IList)">
            Takes two vectors one of the oids and the other of the values.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Collections.IList,System.Collections.IList,Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Takes two vectors one of the oids and the other of the values.
            <p>
            The passed in converter will be used to convert the strings into their
            ASN.1 counterparts.</p>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.String)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.String,Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes with each
            string value being converted to its associated ASN.1 type using the passed
            in converter.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Boolean,System.String)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes. If reverse
            is true, create the encoded version of the sequence starting from the
            last element in the string.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Boolean,System.String,Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes with each
            string value being converted to its associated ASN.1 type using the passed
            in converter. If reverse is true the ASN.1 sequence representing the DN will
            be built by starting at the end of the string, rather than the start.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Boolean,System.Collections.IDictionary,System.String)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes. lookUp
            should provide a table of lookups, indexed by lowercase only strings and
            yielding a DerObjectIdentifier, other than that OID. and numeric oids
            will be processed automatically.
            <br/>
            If reverse is true, create the encoded version of the sequence
            starting from the last element in the string.
            @param reverse true if we should start scanning from the end (RFC 2553).
            @param lookUp table of names and their oids.
            @param dirName the X.500 string to be parsed.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.#ctor(System.Boolean,System.Collections.IDictionary,System.String,Org.BouncyCastle.Asn1.X509.X509NameEntryConverter)">
            Takes an X509 dir name as a string of the format "C=AU, ST=Victoria", or
            some such, converting it into an ordered set of name attributes. lookUp
            should provide a table of lookups, indexed by lowercase only strings and
            yielding a DerObjectIdentifier, other than that OID. and numeric oids
            will be processed automatically. The passed in converter is used to convert the
            string values to the right of each equals sign to their ASN.1 counterparts.
            <br/>
            @param reverse true if we should start scanning from the end, false otherwise.
            @param lookUp table of names and oids.
            @param dirName the string dirName
            @param converter the converter to convert string values into their ASN.1 equivalents
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.GetOidList">
            return an IList of the oids in the name, in the order they were found.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.GetValueList">
            return an IList of the values found in the name, in the order they
            were found.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.GetValueList(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return an IList of the values found in the name, in the order they
            were found, with the DN label corresponding to passed in oid.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.Equivalent(Org.BouncyCastle.Asn1.X509.X509Name,System.Boolean)">
            <param name="other">The X509Name object to test equivalency against.</param>
            <param name="inOrder">If true, the order of elements must be the same,
            as well as the values associated with each element.</param>
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.Equivalent(Org.BouncyCastle.Asn1.X509.X509Name)">
            test for equivalence - note: case is ignored.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X509.X509Name.ToString(System.Boolean,System.Collections.IDictionary)">
             convert the structure to a string - if reverse is true the
             oids and values are listed out starting with the last element
             in the sequence (ala RFC 2253), otherwise the string will begin
             with the first element of the structure. If no string definition
             for the oid is found in oidSymbols the string value of the oid is
             added. Two standard symbol tables are provided DefaultSymbols, and
             RFC2253Symbols as part of this class.
            
             @param reverse if true start at the end of the sequence and work back.
             @param oidSymbols look up table strings for oids.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X509.X509Name.DefaultReverse">
            determines whether or not strings should be processed and printed
            from back to front.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X509.X509NameTokenizer">
            class for breaking up an X500 Name into it's component tokens, ala
            java.util.StringTokenizer. We need this class as some of the
            lightweight Java environment don't support classes like
            StringTokenizer.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.ECNamedCurveTable">
            A general class that reads all X9.62 style EC curve tables.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.ECNamedCurveTable.GetByName(System.String)">
             return a X9ECParameters object representing the passed in named
             curve. The routine returns null if the curve is not present.
            
             @param name the name of the curve requested
             @return an X9ECParameters object or null if the curve is not available.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.ECNamedCurveTable.GetOid(System.String)">
             return the object identifier signified by the passed in name. Null
             if there is no object identifier associated with name.
            
             @return the object identifier associated with name, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.ECNamedCurveTable.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return a X9ECParameters object representing the passed in named
             curve.
            
             @param oid the object id of the curve requested
             @return an X9ECParameters object or null if the curve is not available.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X9.ECNamedCurveTable.Names">
             return an enumeration of the names of the available curves.
            
             @return an enumeration of the names of the available curves.
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X962NamedCurves">
            table of the current named curves defined in X.962 EC-DSA.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X962NamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the X9ECParameters object for the named curve represented by
             the passed in object identifier. Null if the curve isn't present.
            
             @param oid an object identifier representing a named curve, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X962NamedCurves.GetOid(System.String)">
             return the object identifier signified by the passed in name. Null
             if there is no object identifier associated with name.
            
             @return the object identifier associated with name, if present.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X962NamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return the named curve name represented by the given object identifier.
        </member>
        <member name="P:Org.BouncyCastle.Asn1.X9.X962NamedCurves.Names">
            returns an enumeration containing the name strings for curves
            contained in this structure.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X962Parameters.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
            Parameters ::= CHOICE {
               ecParameters ECParameters,
               namedCurve   CURVES.&amp;id({CurveNames}),
               implicitlyCA Null
            }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X9Curve">
            ASN.1 def for Elliptic-Curve Curve structure. See
            X9.62, for further details.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9Curve.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             Curve ::= Sequence {
                 a               FieldElement,
                 b               FieldElement,
                 seed            BIT STRING      OPTIONAL
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X9ECParameters">
            ASN.1 def for Elliptic-Curve ECParameters structure. See
            X9.62, for further details.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9ECParameters.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             ECParameters ::= Sequence {
                 version         Integer { ecpVer1(1) } (ecpVer1),
                 fieldID         FieldID {{FieldTypes}},
                 curve           X9Curve,
                 base            X9ECPoint,
                 order           Integer,
                 cofactor        Integer OPTIONAL
             }
            </pre>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X9ECPoint">
            class for describing an ECPoint as a Der object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9ECPoint.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             ECPoint ::= OCTET STRING
            </pre>
            <p>
            Octet string produced using ECPoint.GetEncoded().</p>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X9FieldElement">
            Class for processing an ECFieldElement as a DER object.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9FieldElement.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             FieldElement ::= OCTET STRING
            </pre>
            <p>
            <ol>
            <li> if <i>q</i> is an odd prime then the field element is
            processed as an Integer and converted to an octet string
            according to x 9.62 4.3.1.</li>
            <li> if <i>q</i> is 2<sup>m</sup> then the bit string
            contained in the field element is converted into an octet
            string with the same ordering padded at the front if necessary.
            </li>
            </ol>
            </p>
        </member>
        <member name="T:Org.BouncyCastle.Asn1.X9.X9FieldID">
            ASN.1 def for Elliptic-Curve Field ID structure. See
            X9.62, for further details.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9FieldID.#ctor(Org.BouncyCastle.Math.BigInteger)">
            Constructor for elliptic curves over prime fields
            <code>F<sub>2</sub></code>.
            @param primeP The prime <code>p</code> defining the prime field.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9FieldID.#ctor(System.Int32,System.Int32)">
            Constructor for elliptic curves over binary fields
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9FieldID.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            Constructor for elliptic curves over binary fields
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>..
        </member>
        <member name="M:Org.BouncyCastle.Asn1.X9.X9FieldID.ToAsn1Object">
            Produce a Der encoding of the following structure.
            <pre>
             FieldID ::= Sequence {
                 fieldType       FIELD-ID.&amp;id({IOSet}),
                 parameters      FIELD-ID.&amp;Type({IOSet}{&#64;fieldType})
             }
            </pre>
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X9.X9ObjectIdentifiers.IdDsaWithSha1">
            id-dsa-with-sha1 OBJECT IDENTIFIER ::=  { iso(1) member-body(2)
                  us(840) x9-57 (10040) x9cm(4) 3 }
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X9.X9ObjectIdentifiers.X9x63Scheme">
            X9.63
        </member>
        <member name="F:Org.BouncyCastle.Asn1.X9.X9ObjectIdentifiers.ansi_x9_42">
            X9.42
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.DHBasicAgreement">
            a Diffie-Hellman key agreement class.
            <p>
            note: This is only the basic algorithm, it doesn't take advantage of
            long term public keys if they are available. See the DHAgreement class
            for a "better" implementation.</p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IBasicAgreement">
            The basic interface that basic Diffie-Hellman implementations
            conforms to.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBasicAgreement.Init(Org.BouncyCastle.Crypto.ICipherParameters)">
            initialise the agreement engine.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBasicAgreement.GetFieldSize">
            return the field size for the agreement algorithm in bytes.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBasicAgreement.CalculateAgreement(Org.BouncyCastle.Crypto.ICipherParameters)">
            given a public key from a given party calculate the next
            message in the agreement sequence.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Agreement.DHBasicAgreement.CalculateAgreement(Org.BouncyCastle.Crypto.ICipherParameters)">
            given a short term public key from a given party calculate the next
            message in the agreement sequence.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Agreement.ECDHBasicAgreement">
             P1363 7.2.1 ECSVDP-DH
            
             ECSVDP-DH is Elliptic Curve Secret Value Derivation Primitive,
             Diffie-Hellman version. It is based on the work of [DH76], [Mil86],
             and [Kob87]. This primitive derives a shared secret value from one
             party's private key and another party's public key, where both have
             the same set of EC domain parameters. If two parties correctly
             execute this primitive, they will produce the same output. This
             primitive can be invoked by a scheme to derive a shared secret key;
             specifically, it may be used with the schemes ECKAS-DH1 and
             DL/ECKAS-DH2. It assumes that the input keys are valid (see also
             Section 7.2.2).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair">
            a holding class for public/private parameter pairs.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair.#ctor(Org.BouncyCastle.Crypto.AsymmetricKeyParameter,Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
             basic constructor.
            
             @param publicParam a public key parameters object.
             @param privateParam the corresponding private key parameters.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair.Public">
             return the public key parameters.
            
             @return the public key parameters.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.AsymmetricCipherKeyPair.Private">
             return the private key parameters.
            
             @return the private key parameters.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.ICipherParameters">
            all parameter classes implement this.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher">
            The AEAD block ciphers already handle buffering internally, so this class
            just takes care of implementing IBufferedCipher methods.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IBufferedCipher">
            <remarks>Block cipher engines are expected to conform to this interface.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBufferedCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">If true the cipher is initialised for encryption,
            if false for decryption.</param>
            <param name="parameters">The key and other data required by the cipher.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBufferedCipher.Reset">
            <summary>
            Reset the cipher. After resetting the cipher is in the same state
            as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IBufferedCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.GetBlockSize">
             return the blocksize for the underlying cipher.
            
             @return the blocksize for the underlying cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.GetOutputSize(System.Int32)">
             return the size of the output buffer required for an update plus a
             doFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update and doFinal
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if necessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param len the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output, or the input is not block size aligned and should be.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if padding is expected and not found.
             @exception DataLengthException if the input is not block size
             aligned.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAeadBlockCipher.Reset">
            Reset the buffer and cipher. After resetting the object is in the same
            state as it was after the last init (if there was one).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher">
            a buffer wrapper for an asymmetric block cipher, allowing input
            to be accumulated in a piecemeal fashion until final processing.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher)">
             base constructor.
            
             @param cipher the cipher this buffering object wraps.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher.GetBufferPosition">
             return the amount of data sitting in the buffer.
            
             @return the amount of data sitting in the buffer.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the buffer and the underlying cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher.DoFinal">
             process the contents of the buffer using the underlying
             cipher.
            
             @return the result of the encryption/decryption process on the
             buffer.
             @exception InvalidCipherTextException if we are given a garbage block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedAsymmetricBlockCipher.Reset">
            <summary>Reset the buffer</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.BufferedBlockCipher">
            A wrapper class that allows block ciphers to be used to process data in
            a piecemeal fashion. The BufferedBlockCipher outputs a block only when the
            buffer is full and more data is being added, or on a doFinal.
            <p>
            Note: in the case where the underlying cipher is either a CFB cipher or an
            OFB one the last block may not be a multiple of the block size.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.#ctor">
            constructor for subclasses
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Create a buffered block cipher without padding.
            
             @param cipher the underlying block cipher this buffering object wraps.
             false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.GetBlockSize">
             return the blocksize for the underlying cipher.
            
             @return the blocksize for the underlying cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.GetOutputSize(System.Int32)">
             return the size of the output buffer required for an update plus a
             doFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update and doFinal
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if necessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param len the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output, or the input is not block size aligned and should be.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if padding is expected and not found.
             @exception DataLengthException if the input is not block size
             aligned.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.BufferedBlockCipher.Reset">
            Reset the buffer and cipher. After resetting the object is in the same
            state as it was after the last init (if there was one).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.CipherKeyGenerator">
            The base class for symmetric, or secret, cipher key generators.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.CipherKeyGenerator.Init(Org.BouncyCastle.Crypto.KeyGenerationParameters)">
             initialise the key generator.
            
             @param param the parameters to be used for key generation
        </member>
        <member name="M:Org.BouncyCastle.Crypto.CipherKeyGenerator.GenerateKey">
             Generate a secret key.
            
             @return a byte array containing the key value.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.DataLengthException">
            this exception is thrown if a buffer that is meant to have output
            copied into it turns out to be too short, or if we've been given
            insufficient input. In general this exception will Get thrown rather
            than an ArrayOutOfBounds exception.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.DataLengthException.#ctor">
            base constructor.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.DataLengthException.#ctor(System.String)">
             create a DataLengthException with the given message.
            
             @param message the message to be carried with the exception.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.GeneralDigest">
            base implementation of MD4 family style digest as outlined in
            "Handbook of Applied Cryptography", pages 344 - 347.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IDigest">
            interface that a message digest conforms to.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.GetDigestSize">
             return the size, in bytes, of the digest produced by this message digest.
            
             @return the size, in bytes, of the digest produced by this message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.GetByteLength">
             return the size, in bytes, of the internal buffer used by this digest.
            
             @return the size, in bytes, of the internal buffer used by this digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.Update(System.Byte)">
             update the message digest with a single byte.
            
             @param inByte the input byte to be entered.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
             update the message digest with a block of bytes.
            
             @param input the byte array containing the data.
             @param inOff the offset into the byte array where the data starts.
             @param len the length of the data.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.DoFinal(System.Byte[],System.Int32)">
             Close the digest, producing the final digest value. The doFinal
             call leaves the digest reset.
            
             @param output the array the digest is to be copied into.
             @param outOff the offset into the out array the digest is to start at.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDigest.Reset">
            reset the digest back to it's initial state.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IDigest.AlgorithmName">
             return the algorithm name
            
             @return the algorithm name
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IMemoable.Copy">
            <summary>
            Produce a copy of this object with its configuration and in its current state.
            </summary>
            <remarks>
            The returned object may be used simply to store the state, or may be used as a similar object
            starting from the copied state.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IMemoable.Reset(Org.BouncyCastle.Utilities.IMemoable)">
            <summary>
            Restore a copied object state into this object.
            </summary>
            <remarks>
            Implementations of this method <em>should</em> try to avoid or minimise memory allocation to perform the reset.
            </remarks>
            <param name="other">an object originally {@link #copy() copied} from an object of the same type as this instance.</param>
            <exception cref="T:System.InvalidCastException">if the provided object is not of the correct type.</exception>
            <exception cref="T:Org.BouncyCastle.Utilities.MemoableResetException">if the <b>other</b> parameter is in some other way invalid.</exception>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Gost3411Digest">
            implementation of GOST R 34.11-94
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Gost3411Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Gost3411Digest.#ctor(System.Byte[])">
            Constructor to allow use of a particular sbox with GOST28147
            @see GOST28147Engine#getSBox(String)
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Gost3411Digest.#ctor(Org.BouncyCastle.Crypto.Digests.Gost3411Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Digests.Gost3411Digest.C2">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.LongDigest">
            Base class for SHA-384 and SHA-512.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.LongDigest.#ctor">
            Constructor for variable length word
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.LongDigest.#ctor(Org.BouncyCastle.Crypto.Digests.LongDigest)">
            Copy constructor.  We are using copy constructors in place
            of the object.Clone() interface as this interface is not
            supported by J2ME.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.LongDigest.AdjustByteCounts">
            adjust the byte counts so that byteCount2 represents the
            upper long (less 3 bits) word of the byte count.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.MD2Digest">
            implementation of MD2
            as outlined in RFC1319 by B.Kaliski from RSA Laboratories April 1992
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD2Digest.DoFinal(System.Byte[],System.Int32)">
             Close the digest, producing the final digest value. The doFinal
             call leaves the digest reset.
            
             @param out the array the digest is to be copied into.
             @param outOff the offset into the out array the digest is to start at.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD2Digest.Reset">
            reset the digest back to it's initial state.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD2Digest.Update(System.Byte)">
             update the message digest with a single byte.
            
             @param in the input byte to be entered.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD2Digest.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
             update the message digest with a block of bytes.
            
             @param in the byte array containing the data.
             @param inOff the offset into the byte array where the data starts.
             @param len the length of the data.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Digests.MD2Digest.AlgorithmName">
             return the algorithm name
            
             @return the algorithm name
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.MD4Digest">
            implementation of MD4 as RFC 1320 by R. Rivest, MIT Laboratory for
            Computer Science and RSA Data Security, Inc.
            <p>
            <b>NOTE</b>: This algorithm is only included for backwards compatibility
            with legacy applications, it's not secure, don't use it for anything new!</p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD4Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD4Digest.#ctor(Org.BouncyCastle.Crypto.Digests.MD4Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD4Digest.Reset">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.MD5Digest">
            implementation of MD5 as outlined in "Handbook of Applied Cryptography", pages 346 - 347.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD5Digest.#ctor(Org.BouncyCastle.Crypto.Digests.MD5Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.MD5Digest.Reset">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.RipeMD128Digest">
            implementation of RipeMD128
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD128Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD128Digest.#ctor(Org.BouncyCastle.Crypto.Digests.RipeMD128Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD128Digest.Reset">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.RipeMD160Digest">
            implementation of RipeMD see,
            http://www.esat.kuleuven.ac.be/~bosselae/ripemd160.html
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD160Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD160Digest.#ctor(Org.BouncyCastle.Crypto.Digests.RipeMD160Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD160Digest.Reset">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.RipeMD256Digest">
            <remarks>
            <p>Implementation of RipeMD256.</p>
            <p><b>Note:</b> this algorithm offers the same level of security as RipeMD128.</p>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD256Digest.#ctor">
            <summary> Standard constructor</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD256Digest.#ctor(Org.BouncyCastle.Crypto.Digests.RipeMD256Digest)">
            <summary> Copy constructor.  This will copy the state of the provided
            message digest.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD256Digest.Reset">
            <summary> reset the chaining variables to the IV values.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.RipeMD320Digest">
            <remarks>
            <p>Implementation of RipeMD 320.</p>
            <p><b>Note:</b> this algorithm offers the same level of security as RipeMD160.</p>
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD320Digest.#ctor">
            <summary> Standard constructor</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD320Digest.#ctor(Org.BouncyCastle.Crypto.Digests.RipeMD320Digest)">
            <summary> Copy constructor.  This will copy the state of the provided
            message digest.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.RipeMD320Digest.Reset">
            <summary> reset the chaining variables to the IV values.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha1Digest">
             implementation of SHA-1 as outlined in "Handbook of Applied Cryptography", pages 346 - 349.
            
             It is interesting to ponder why the, apart from the extra IV, the other difference here from MD5
             is the "endianness" of the word processing!
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha1Digest.#ctor(Org.BouncyCastle.Crypto.Digests.Sha1Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha1Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha224Digest">
            SHA-224 as described in RFC 3874
            <pre>
                    block  word  digest
            SHA-1   512    32    160
            SHA-224 512    32    224
            SHA-256 512    32    256
            SHA-384 1024   64    384
            SHA-512 1024   64    512
            </pre>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha224Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha224Digest.#ctor(Org.BouncyCastle.Crypto.Digests.Sha224Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha224Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha256Digest">
             Draft FIPS 180-2 implementation of SHA-256. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha256Digest.#ctor(Org.BouncyCastle.Crypto.Digests.Sha256Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha256Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha384Digest">
             Draft FIPS 180-2 implementation of SHA-384. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha384Digest.#ctor(Org.BouncyCastle.Crypto.Digests.Sha384Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha384Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha3Digest">
            <summary>
            Implementation of SHA-3 based on following KeccakNISTInterface.c from http://keccak.noekeon.org/
            </summary>
            <remarks>
            Following the naming conventions used in the C source code to enable easy review of the implementation.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha3Digest.GetByteLength">
             Return the size of block that the compression function is applied to in bytes.
            
             @return internal byte length of a block.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha512Digest">
             Draft FIPS 180-2 implementation of SHA-512. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha512Digest.#ctor(Org.BouncyCastle.Crypto.Digests.Sha512Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha512Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.Sha512tDigest">
            FIPS 180-4 implementation of SHA-512/t
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha512tDigest.#ctor(System.Int32)">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha512tDigest.#ctor(Org.BouncyCastle.Crypto.Digests.Sha512tDigest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.Sha512tDigest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.TigerDigest">
            implementation of Tiger based on:
            <a href="http://www.cs.technion.ac.il/~biham/Reports/Tiger">
             http://www.cs.technion.ac.il/~biham/Reports/Tiger</a>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.TigerDigest.#ctor">
            Standard constructor
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.TigerDigest.#ctor(Org.BouncyCastle.Crypto.Digests.TigerDigest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.TigerDigest.Reset">
            reset the chaining variables
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Digests.WhirlpoolDigest">
             Implementation of WhirlpoolDigest, based on Java source published by Barreto
             and Rijmen.
            
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.WhirlpoolDigest.#ctor(Org.BouncyCastle.Crypto.Digests.WhirlpoolDigest)">
            Copy constructor. This will copy the state of the provided message
            digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Digests.WhirlpoolDigest.Reset">
            Reset the chaining variables
        </member>
        <member name="M:Org.BouncyCastle.Crypto.EC.CustomNamedCurves.GetByOid(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the X9ECParameters object for the named curve represented by
             the passed in object identifier. Null if the curve isn't present.
            
             @param oid an object identifier representing a named curve, if present.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.EC.CustomNamedCurves.GetOid(System.String)">
             return the object identifier signified by the passed in name. Null
             if there is no object identifier associated with name.
            
             @return the object identifier associated with name, if present.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.EC.CustomNamedCurves.GetName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            return the named curve name represented by the given object identifier.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.EC.CustomNamedCurves.Names">
            returns an enumeration containing the name strings for curves
            contained in this structure.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding">
            ISO 9796-1 padding. Note in the light of recent results you should
            only use this with RSA (rather than the "simpler" Rabin keys) and you
            should never use it with anything other than a hash (ie. even if the
            message is small don't sign the message, sign it's hash) or some "random"
            value. See your favorite search engine for details.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher">
            <remarks>Base interface for a public/private key block cipher.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">The key or other data required by the cipher.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.GetInputBlockSize">
            <returns>The maximum size, in bytes, an input block may be.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.GetOutputBlockSize">
            <returns>The maximum size, in bytes, an output block will be.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process a block.</summary>
            <param name="inBuf">The input buffer.</param>
            <param name="inOff">The offset into <paramref>inBuf</paramref> that the input block begins.</param>
            <param name="inLen">The length of the input block.</param>
            <exception cref="T:Org.BouncyCastle.Crypto.InvalidCipherTextException">Input decrypts improperly.</exception>
            <exception cref="T:Org.BouncyCastle.Crypto.DataLengthException">Input is too large for the cipher.</exception>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IAsymmetricBlockCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding.GetInputBlockSize">
            return the input block size. The largest message we can process
            is (key_size_in_bits + 3)/16, which in our world comes to
            key_size_in_bytes / 2.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding.GetOutputBlockSize">
            return the maximum possible size for the output.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding.SetPadBits(System.Int32)">
            set the number of bits in the next message to be treated as
            pad bits.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding.GetPadBits">
            retrieve the number of pad bits in the last decoded message.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.ISO9796d1Encoding.DecodeBlock(System.Byte[],System.Int32,System.Int32)">
            @exception InvalidCipherTextException if the decrypted block is not a valid ISO 9796 bit string
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Encodings.OaepEncoding">
            Optimal Asymmetric Encryption Padding (OAEP) - see PKCS 1 V 2.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.OaepEncoding.DecodeBlock(System.Byte[],System.Int32,System.Int32)">
            @exception InvalidCipherTextException if the decrypted block turns out to
            be badly formatted.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.OaepEncoding.ItoOSP(System.Int32,System.Byte[])">
            int to octet string.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.OaepEncoding.maskGeneratorFunction1(System.Byte[],System.Int32,System.Int32,System.Int32)">
            mask generator function, as described in PKCS1v2.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding">
            this does your basic Pkcs 1 v1.5 padding - whether or not you should be using this
            depends on your application - see Pkcs1 Version 2 for details.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.StrictLengthEnabledProperty">
            some providers fail to include the leading zero in PKCS1 encoded blocks. If you need to
            work with one of these set the system property Org.BouncyCastle.Pkcs1.Strict to false.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher)">
            Basic constructor.
            @param cipher
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,System.Int32)">
            Constructor for decryption with a fixed plaintext length.
            
            @param cipher The cipher to use for cryptographic operation.
            @param pLen Length of the expected plaintext.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,System.Byte[])">
            Constructor for decryption with a fixed plaintext length and a fallback
            value that is returned, if the padding is incorrect.
            
            @param cipher
                       The cipher to use for cryptographic operation.
            @param fallback
                       The fallback value, we don't to a arraycopy here.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.CheckPkcs1Encoding(System.Byte[],System.Int32)">
            Checks if the argument is a correctly PKCS#1.5 encoded Plaintext
            for encryption.
            
            @param encoded The Plaintext.
            @param pLen Expected length of the plaintext.
            @return Either 0, if the encoding is correct, or -1, if it is incorrect.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.DecodeBlockOrRandom(System.Byte[],System.Int32,System.Int32)">
            Decode PKCS#1.5 encoding, and return a random value if the padding is not correct.
            
            @param in The encrypted block.
            @param inOff Offset in the encrypted block.
            @param inLen Length of the encrypted block.
            @param pLen Length of the desired output.
            @return The plaintext without padding, or a random value if the padding was incorrect.
            
            @throws InvalidCipherTextException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.DecodeBlock(System.Byte[],System.Int32,System.Int32)">
            @exception InvalidCipherTextException if the decrypted block is not in Pkcs1 format.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Encodings.Pkcs1Encoding.StrictLengthEnabled">
            The same effect can be achieved by setting the static property directly
            <p>
            The static property is checked during construction of the encoding object, it is set to
            true by default.
            </p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.AesEngine">
             an implementation of the AES (Rijndael), from FIPS-197.
             <p>
             For further details see: <a href="http://csrc.nist.gov/encryption/aes/">http://csrc.nist.gov/encryption/aes/</a>.
            
             This implementation is based on optimizations from Dr. Brian Gladman's paper and C code at
             <a href="http://fp.gladman.plus.com/cryptography_technology/rijndael/">http://fp.gladman.plus.com/cryptography_technology/rijndael/</a>
            
             There are three levels of tradeoff of speed vs memory
             Because java has no preprocessor, they are written as three separate classes from which to choose
            
             The fastest uses 8Kbytes of static tables to precompute round calculations, 4 256 word tables for encryption
             and 4 for decryption.
            
             The middle performance version uses only one 256 word table for each, for a total of 2Kbytes,
             adding 12 rotate operations per round to compute the values contained in the other tables from
             the contents of the first.
            
             The slowest version uses no static tables at all and computes the values in each round.
             </p>
             <p>
             This file contains the middle performance version with 2Kbytes of static tables for round precomputation.
             </p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IBlockCipher">
            <remarks>Base interface for a symmetric key block cipher.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">The key or other data required by the cipher.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipher.GetBlockSize">
            <returns>The block size for this cipher, in bytes.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>Process a block.</summary>
            <param name="inBuf">The input buffer.</param>
            <param name="inOff">The offset into <paramref>inBuf</paramref> that the input block begins.</param>
            <param name="outBuf">The output buffer.</param>
            <param name="outOff">The offset into <paramref>outBuf</paramref> to write the output block.</param>
            <exception cref="T:Org.BouncyCastle.Crypto.DataLengthException">If input block is wrong size, or outBuf too small.</exception>
            <returns>The number of bytes processed and produced.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IBlockCipher.Reset">
            <summary>
            Reset the cipher to the same state as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IBlockCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IBlockCipher.IsPartialBlockOkay">
            <summary>Indicates whether this cipher can handle partial blocks.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesEngine.GenerateWorkingKey(System.Byte[],System.Boolean)">
            Calculate the necessary round keys
            The number of calculations depends on key size and block size
            AES specified a fixed block size of 128 bits and key sizes 128/192/256 bits
            This code is written assuming those are the only possible values
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesEngine.#ctor">
            default constructor - 128 bit block size.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise an AES cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.AesFastEngine">
             an implementation of the AES (Rijndael)), from FIPS-197.
             <p>
             For further details see: <a href="http://csrc.nist.gov/encryption/aes/">http://csrc.nist.gov/encryption/aes/</a>.
            
             This implementation is based on optimizations from Dr. Brian Gladman's paper and C code at
             <a href="http://fp.gladman.plus.com/cryptography_technology/rijndael/">http://fp.gladman.plus.com/cryptography_technology/rijndael/</a>
            
             There are three levels of tradeoff of speed vs memory
             Because java has no preprocessor), they are written as three separate classes from which to choose
            
             The fastest uses 8Kbytes of static tables to precompute round calculations), 4 256 word tables for encryption
             and 4 for decryption.
            
             The middle performance version uses only one 256 word table for each), for a total of 2Kbytes),
             adding 12 rotate operations per round to compute the values contained in the other tables from
             the contents of the first
            
             The slowest version uses no static tables at all and computes the values in each round
             </p>
             <p>
             This file contains the fast version with 8Kbytes of static tables for round precomputation
             </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesFastEngine.GenerateWorkingKey(System.Byte[],System.Boolean)">
            Calculate the necessary round keys
            The number of calculations depends on key size and block size
            AES specified a fixed block size of 128 bits and key sizes 128/192/256 bits
            This code is written assuming those are the only possible values
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesFastEngine.#ctor">
            default constructor - 128 bit block size.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.AesFastEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise an AES cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.AesWrapEngine">
            <remarks>
            An implementation of the AES Key Wrapper from the NIST Key Wrap Specification.
            <p/>
            For further details see: <a href="http://csrc.nist.gov/encryption/kms/key-wrap.pdf">http://csrc.nist.gov/encryption/kms/key-wrap.pdf</a>.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.Rfc3394WrapEngine">
            <remarks>
            An implementation of the AES Key Wrapper from the NIST Key Wrap
            Specification as described in RFC 3394.
            <p/>
            For further details see: <a href="http://www.ietf.org/rfc/rfc3394.txt">http://www.ietf.org/rfc/rfc3394.txt</a>
            and  <a href="http://csrc.nist.gov/encryption/kms/key-wrap.pdf">http://csrc.nist.gov/encryption/kms/key-wrap.pdf</a>.
            </remarks>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IWrapper.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.BlowfishEngine">
            A class that provides Blowfish key encryption operations,
            such as encoding data and generating keys.
            All the algorithms herein are from Applied Cryptography
            and implement a simplified cryptography interface.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.BlowfishEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a Blowfish cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.BlowfishEngine.ProcessTable(System.UInt32,System.UInt32,System.UInt32[])">
            apply the encryption cycle to each value pair in the table.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.BlowfishEngine.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            Encrypt the given input starting at the given offset and place
            the result in the provided buffer starting at the given offset.
            The input will be an exact multiple of our blocksize.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.BlowfishEngine.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            Decrypt the given input starting at the given offset and place
            the result in the provided buffer starting at the given offset.
            The input will be an exact multiple of our blocksize.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.CamelliaEngine">
            Camellia - based on RFC 3713.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.CamelliaWrapEngine">
            <remarks>
            An implementation of the Camellia key wrapper based on RFC 3657/RFC 3394.
            <p/>
            For further details see: <a href="http://www.ietf.org/rfc/rfc3657.txt">http://www.ietf.org/rfc/rfc3657.txt</a>.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.Cast5Engine">
             A class that provides CAST key encryption operations,
             such as encoding data and generating keys.
            
             All the algorithms herein are from the Internet RFC's
            
             RFC2144 - Cast5 (64bit block, 40-128bit key)
             RFC2612 - CAST6 (128bit block, 128-256bit key)
            
             and implement a simplified cryptography interface.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast5Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a CAST cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast5Engine.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Encrypt the given input starting at the given offset and place
             the result in the provided buffer starting at the given offset.
            
             @param src        The plaintext buffer
             @param srcIndex    An offset into src
             @param dst        The ciphertext buffer
             @param dstIndex    An offset into dst
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast5Engine.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Decrypt the given input starting at the given offset and place
             the result in the provided buffer starting at the given offset.
            
             @param src        The plaintext buffer
             @param srcIndex    An offset into src
             @param dst        The ciphertext buffer
             @param dstIndex    An offset into dst
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast5Engine.F1(System.UInt32,System.UInt32,System.Int32)">
             The first of the three processing functions for the
             encryption and decryption.
            
             @param D            the input to be processed
             @param Kmi        the mask to be used from Km[n]
             @param Kri        the rotation value to be used
            
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast5Engine.F2(System.UInt32,System.UInt32,System.Int32)">
             The second of the three processing functions for the
             encryption and decryption.
            
             @param D            the input to be processed
             @param Kmi        the mask to be used from Km[n]
             @param Kri        the rotation value to be used
            
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast5Engine.F3(System.UInt32,System.UInt32,System.Int32)">
             The third of the three processing functions for the
             encryption and decryption.
            
             @param D            the input to be processed
             @param Kmi        the mask to be used from Km[n]
             @param Kri        the rotation value to be used
            
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast5Engine.CAST_Encipher(System.UInt32,System.UInt32,System.UInt32[])">
             Does the 16 rounds to encrypt the block.
            
             @param L0    the LH-32bits of the plaintext block
             @param R0    the RH-32bits of the plaintext block
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.Cast6Engine">
             A class that provides CAST6 key encryption operations,
             such as encoding data and generating keys.
            
             All the algorithms herein are from the Internet RFC
            
             RFC2612 - CAST6 (128bit block, 128-256bit key)
            
             and implement a simplified cryptography interface.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast6Engine.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Encrypt the given input starting at the given offset and place
             the result in the provided buffer starting at the given offset.
            
             @param src        The plaintext buffer
             @param srcIndex    An offset into src
             @param dst        The ciphertext buffer
             @param dstIndex    An offset into dst
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast6Engine.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Decrypt the given input starting at the given offset and place
             the result in the provided buffer starting at the given offset.
            
             @param src        The plaintext buffer
             @param srcIndex    An offset into src
             @param dst        The ciphertext buffer
             @param dstIndex    An offset into dst
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast6Engine.CAST_Encipher(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32[])">
             Does the 12 quad rounds rounds to encrypt the block.
            
             @param A    the 00-31  bits of the plaintext block
             @param B    the 32-63  bits of the plaintext block
             @param C    the 64-95  bits of the plaintext block
             @param D    the 96-127 bits of the plaintext block
             @param result the resulting ciphertext
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Cast6Engine.CAST_Decipher(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32[])">
             Does the 12 quad rounds rounds to decrypt the block.
            
             @param A    the 00-31  bits of the ciphertext block
             @param B    the 32-63  bits of the ciphertext block
             @param C    the 64-95  bits of the ciphertext block
             @param D    the 96-127 bits of the ciphertext block
             @param result the resulting plaintext
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.ChaChaEngine">
            <summary>
            Implementation of Daniel J. Bernstein's ChaCha stream cipher.
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.Salsa20Engine">
            <summary>
            Implementation of Daniel J. Bernstein's Salsa20 stream cipher, Snuffle 2005
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IStreamCipher">
            <summary>The interface stream ciphers conform to.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IStreamCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">If true the cipher is initialised for encryption,
            if false for decryption.</param>
            <param name="parameters">The key and other data required by the cipher.</param>
            <exception cref="T:System.ArgumentException">
            If the parameters argument is inappropriate.
            </exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IStreamCipher.ReturnByte(System.Byte)">
            <summary>encrypt/decrypt a single byte returning the result.</summary>
            <param name="input">the byte to be processed.</param>
            <returns>the result of processing the input byte.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IStreamCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Process a block of bytes from <c>input</c> putting the result into <c>output</c>.
            </summary>
            <param name="input">The input byte array.</param>
            <param name="inOff">
            The offset into <c>input</c> where the data to be processed starts.
            </param>
            <param name="length">The number of bytes to be processed.</param>
            <param name="output">The output buffer the processed bytes go into.</param>
            <param name="outOff">
            The offset into <c>output</c> the processed data starts at.
            </param>
            <exception cref="T:Org.BouncyCastle.Crypto.DataLengthException">If the output buffer is too small.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IStreamCipher.Reset">
            <summary>
            Reset the cipher to the same state as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IStreamCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.Salsa20Engine.StateSize">
            Constants 
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Salsa20Engine.#ctor">
            <summary>
            Creates a 20 round Salsa20 engine.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Salsa20Engine.#ctor(System.Int32)">
            <summary>
            Creates a Salsa20 engine with a specific number of rounds.
            </summary>
            <param name="rounds">the number of rounds (must be an even number).</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Salsa20Engine.R(System.UInt32,System.Int32)">
             Rotate left
            
             @param   x   value to rotate
             @param   y   amount to rotate x
            
             @return  rotated x
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ChaChaEngine.#ctor">
            <summary>
            Creates a 20 rounds ChaCha engine.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ChaChaEngine.#ctor(System.Int32)">
            <summary>
            Creates a ChaCha engine with a specific number of rounds.
            </summary>
            <param name="rounds">the number of rounds (must be an even number).</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ChaChaEngine.ChachaCore(System.Int32,System.UInt32[],System.UInt32[])">
            <summary>
            ChacCha function.
            </summary>
            <param name="rounds">The number of ChaCha rounds to execute</param>
            <param name="input">The input words.</param>
            <param name="x">The ChaCha state to modify.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.DesEdeEngine">
            <remarks>A class that provides a basic DESede (or Triple DES) engine.</remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.DesEngine">
            <remarks>A class that provides a basic DES engine.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a DES cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.DesEngine.bytebit">
            what follows is mainly taken from "Applied Cryptography", by
            Bruce Schneier, however it also bears great resemblance to Richard
            Outerbridge's D3DES...
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEngine.GenerateWorkingKey(System.Boolean,System.Byte[])">
             Generate an integer based working key based on our secret key
             and what we processing we are planning to do.
            
             Acknowledgements for this routine go to James Gillogly and Phil Karn.
                     (whoever, and wherever they are!).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEngine.DesFunc(System.Int32[],System.Byte[],System.Int32,System.Byte[],System.Int32)">
            the DES engine.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEdeEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a DESede cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine">
                * Wrap keys according to
                * <a href="http://www.ietf.org/internet-drafts/draft-ietf-smime-key-wrap-01.txt">
                * draft-ietf-smime-key-wrap-01.txt</a>.
                * <p>
                * Note:
                * <ul>
                * <li>this is based on a draft, and as such is subject to change - don't use this class for anything requiring long term storage.</li>
                * <li>if you are using this to wrap triple-des keys you need to set the
                * parity bits on the key and, if it's a two-key triple-des key, pad it
                * yourself.</li>
                * </ul>
            	* </p>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.engine">
            Field engine 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.param">
            Field param 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.paramPlusIV">
            Field paramPlusIV 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.iv">
            Field iv 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.forWrapping">
            Field forWrapping 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.IV2">
            Field IV2           
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Method init
            
             @param forWrapping
             @param param
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.Wrap(System.Byte[],System.Int32,System.Int32)">
             Method wrap
            
             @param in
             @param inOff
             @param inLen
             @return
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.Unwrap(System.Byte[],System.Int32,System.Int32)">
             Method unwrap
            
             @param in
             @param inOff
             @param inLen
             @return
             @throws InvalidCipherTextException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.CalculateCmsKeyChecksum(System.Byte[])">
             Some key wrap algorithms make use of the Key Checksum defined
             in CMS [CMS-Algorithms]. This is used to provide an integrity
             check value for the key being wrapped. The algorithm is
            
             - Compute the 20 octet SHA-1 hash on the key being wrapped.
             - Use the first 8 octets of this hash as the checksum value.
            
             @param key
             @return
             @throws Exception
             @see http://www.w3.org/TR/xmlenc-core/#sec-CMSKeyChecksum
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.CheckCmsKeyChecksum(System.Byte[],System.Byte[])">
            @param key
            @param checksum
            @return
            @see http://www.w3.org/TR/xmlenc-core/#sec-CMSKeyChecksum
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Engines.DesEdeWrapEngine.AlgorithmName">
             Method GetAlgorithmName
            
             @return
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.ElGamalEngine">
            this does your basic ElGamal algorithm.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ElGamalEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the ElGamal engine.
            
             @param forEncryption true if we are encrypting, false otherwise.
             @param param the necessary ElGamal key parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ElGamalEngine.GetInputBlockSize">
             Return the maximum size for an input block to this engine.
             For ElGamal this is always one byte less than the size of P on
             encryption, and twice the length as the size of P on decryption.
            
             @return maximum size for an input block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ElGamalEngine.GetOutputBlockSize">
             Return the maximum size for an output block to this engine.
             For ElGamal this is always one byte less than the size of P on
             decryption, and twice the length as the size of P on encryption.
            
             @return maximum size for an output block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.ElGamalEngine.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
             Process a single block using the basic ElGamal algorithm.
            
             @param in the input array.
             @param inOff the offset into the input buffer where the data starts.
             @param length the length of the data to be processed.
             @return the result of the ElGamal process.
             @exception DataLengthException the input block is too large.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.Gost28147Engine">
            implementation of GOST 28147-89
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Gost28147Engine.#ctor">
            standard constructor.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Gost28147Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise an Gost28147 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.Gost28147Engine.GetSBox(System.String)">
            Return the S-Box associated with SBoxName
            @param sBoxName name of the S-Box
            @return byte array representing the S-Box
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.HC128Engine">
             HC-128 is a software-efficient stream cipher created by Hongjun Wu. It
             generates keystream from a 128-bit secret key and a 128-bit initialization
             vector.
             <p>
             http://www.ecrypt.eu.org/stream/p3ciphers/hc/hc128_p3.pdf
             </p><p>
             It is a third phase candidate in the eStream contest, and is patent-free.
             No attacks are known as of today (April 2007). See
            
             http://www.ecrypt.eu.org/stream/hcp3.html
             </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.HC128Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise a HC-128 cipher.
            
             @param forEncryption whether or not we are for encryption. Irrelevant, as
                                  encryption and decryption are the same.
             @param params        the parameters required to set up the cipher.
             @throws ArgumentException if the params argument is
                                              inappropriate (ie. the key is not 128 bit long).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.HC256Engine">
            HC-256 is a software-efficient stream cipher created by Hongjun Wu. It 
            generates keystream from a 256-bit secret key and a 256-bit initialization 
            vector.
            <p>
            http://www.ecrypt.eu.org/stream/p3ciphers/hc/hc256_p3.pdf
            </p><p>
            Its brother, HC-128, is a third phase candidate in the eStream contest.
            The algorithm is patent-free. No attacks are known as of today (April 2007). 
            See
            
            http://www.ecrypt.eu.org/stream/hcp3.html
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.HC256Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise a HC-256 cipher.
            
             @param forEncryption whether or not we are for encryption. Irrelevant, as
                                  encryption and decryption are the same.
             @param params        the parameters required to set up the cipher.
             @throws ArgumentException if the params argument is
                                              inappropriate (ie. the key is not 256 bit long).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.IdeaEngine">
            A class that provides a basic International Data Encryption Algorithm (IDEA) engine.
            <p>
            This implementation is based on the "HOWTO: INTERNATIONAL DATA ENCRYPTION ALGORITHM"
            implementation summary by Fauzan Mirza (F.U.Mirza@sheffield.ac.uk). (baring 1 typo at the
            end of the mulinv function!).
            </p>
            <p>
            It can be found at ftp://ftp.funet.fi/pub/crypt/cryptography/symmetric/idea/
            </p>
            <p>
            Note 1: This algorithm is patented in the USA, Japan, and Europe including
            at least Austria, France, Germany, Italy, Netherlands, Spain, Sweden, Switzerland
            and the United Kingdom. Non-commercial use is free, however any commercial
            products are liable for royalties. Please see
            <a href="http://www.mediacrypt.com">www.mediacrypt.com</a> for
            further details. This announcement has been included at the request of
            the patent holders.
            </p>
            <p>
            Note 2: Due to the requests concerning the above, this algorithm is now only
            included in the extended assembly. It is not included in the default distributions.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IdeaEngine.#ctor">
            standard constructor.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IdeaEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise an IDEA cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IdeaEngine.Mul(System.Int32,System.Int32)">
             return x = x * y where the multiplication is done modulo
             65537 (0x10001) (as defined in the IDEA specification) and
             a zero input is taken to be 65536 (0x10000).
            
             @param x the x value
             @param y the y value
             @return x = x * y
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IdeaEngine.ExpandKey(System.Byte[])">
            The following function is used to expand the user key to the encryption
            subkey. The first 16 bytes are the user key, and the rest of the subkey
            is calculated by rotating the previous 16 bytes by 25 bits to the left,
            and so on until the subkey is completed.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IdeaEngine.MulInv(System.Int32)">
            This function computes multiplicative inverse using Euclid's Greatest
            Common Divisor algorithm. Zero and one are self inverse.
            <p>
            i.e. x * MulInv(x) == 1 (modulo BASE)
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IdeaEngine.AddInv(System.Int32)">
            Return the additive inverse of x.
            <p>
            i.e. x + AddInv(x) == 0
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IdeaEngine.InvertKey(System.Int32[])">
            The function to invert the encryption subkey to the decryption subkey.
            It also involves the multiplicative inverse and the additive inverse functions.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.IesEngine">
            support class for constructing intergrated encryption ciphers
            for doing basic message exchanges on top of key agreement ciphers
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IesEngine.#ctor(Org.BouncyCastle.Crypto.IBasicAgreement,Org.BouncyCastle.Crypto.IDerivationFunction,Org.BouncyCastle.Crypto.IMac)">
             set up for use with stream mode, where the key derivation function
             is used to provide a stream of bytes to xor with the message.
            
             @param agree the key agreement used as the basis for the encryption
             @param kdf the key derivation function used for byte generation
             @param mac the message authentication code generator for the message
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IesEngine.#ctor(Org.BouncyCastle.Crypto.IBasicAgreement,Org.BouncyCastle.Crypto.IDerivationFunction,Org.BouncyCastle.Crypto.IMac,Org.BouncyCastle.Crypto.BufferedBlockCipher)">
             set up for use in conjunction with a block cipher to handle the
             message.
            
             @param agree the key agreement used as the basis for the encryption
             @param kdf the key derivation function used for byte generation
             @param mac the message authentication code generator for the message
             @param cipher the cipher to used for encrypting the message
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.IesEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters,Org.BouncyCastle.Crypto.ICipherParameters,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the encryptor.
            
             @param forEncryption whether or not this is encryption/decryption.
             @param privParam our private key parameters
             @param pubParam the recipient's/sender's public key parameters
             @param param encoding and derivation parameters.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.NoekeonEngine">
            A Noekeon engine, using direct-key mode.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.NoekeonEngine.#ctor">
            Create an instance of the Noekeon encryption algorithm
            and set some defaults
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.NoekeonEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise
            
             @param forEncryption whether or not we are for encryption.
             @param params the parameters required to set up the cipher.
             @exception ArgumentException if the params argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.NoekeonEngine.setKey(System.Byte[])">
             Re-key the cipher.
            
             @param  key  the key to be used
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RC2Engine">
            an implementation of RC2 as described in RFC 2268
                 "A Description of the RC2(r) Encryption Algorithm" R. Rivest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC2Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a RC2 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC2Engine.RotateWordLeft(System.Int32,System.Int32)">
            return the result rotating the 16 bit number in x left by y
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine">
            Wrap keys according to RFC 3217 - RC2 mechanism
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.engine">
            Field engine 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.parameters">
            Field param 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.paramPlusIV">
            Field paramPlusIV 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.iv">
            Field iv 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.forWrapping">
            Field forWrapping 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.IV2">
            Field IV2           
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Method init
            
             @param forWrapping
             @param param
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.Wrap(System.Byte[],System.Int32,System.Int32)">
             Method wrap
            
             @param in
             @param inOff
             @param inLen
             @return
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.Unwrap(System.Byte[],System.Int32,System.Int32)">
             Method unwrap
            
             @param in
             @param inOff
             @param inLen
             @return
             @throws InvalidCipherTextException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.CalculateCmsKeyChecksum(System.Byte[])">
             Some key wrap algorithms make use of the Key Checksum defined
             in CMS [CMS-Algorithms]. This is used to provide an integrity
             check value for the key being wrapped. The algorithm is
            
             - Compute the 20 octet SHA-1 hash on the key being wrapped.
             - Use the first 8 octets of this hash as the checksum value.
            
             @param key
             @return
             @throws Exception
             @see http://www.w3.org/TR/xmlenc-core/#sec-CMSKeyChecksum
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.CheckCmsKeyChecksum(System.Byte[],System.Byte[])">
            @param key
            @param checksum
            @return
            @see http://www.w3.org/TR/xmlenc-core/#sec-CMSKeyChecksum
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Engines.RC2WrapEngine.AlgorithmName">
             Method GetAlgorithmName
            
             @return
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC4Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a RC4 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RC532Engine">
            The specification for RC5 came from the <code>RC5 Encryption Algorithm</code>
            publication in RSA CryptoBytes, Spring of 1995.
            <em>http://www.rsasecurity.com/rsalabs/cryptobytes</em>.
            <p>
            This implementation has a word size of 32 bits.</p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC532Engine.#ctor">
            Create an instance of the RC5 encryption algorithm
            and set some defaults
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC532Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a RC5-32 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC532Engine.SetKey(System.Byte[])">
             Re-key the cipher.
            
             @param  key  the key to be used
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC532Engine.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Encrypt the given block starting at the given offset and place
             the result in the provided buffer starting at the given offset.
            
             @param  in     in byte buffer containing data to encrypt
             @param  inOff  offset into src buffer
             @param  out     out buffer where encrypted data is written
             @param  outOff  offset into out buffer
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC532Engine.RotateLeft(System.Int32,System.Int32)">
             Perform a left "spin" of the word. The rotation of the given
             word <em>x</em> is rotated left by <em>y</em> bits.
             Only the <em>lg(32)</em> low-order bits of <em>y</em>
             are used to determine the rotation amount. Here it is
             assumed that the wordsize used is a power of 2.
            
             @param  x  word to rotate
             @param  y    number of bits to rotate % 32
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC532Engine.RotateRight(System.Int32,System.Int32)">
             Perform a right "spin" of the word. The rotation of the given
             word <em>x</em> is rotated left by <em>y</em> bits.
             Only the <em>lg(32)</em> low-order bits of <em>y</em>
             are used to determine the rotation amount. Here it is
             assumed that the wordsize used is a power of 2.
            
             @param  x  word to rotate
             @param  y    number of bits to rotate % 32
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RC564Engine">
            The specification for RC5 came from the <code>RC5 Encryption Algorithm</code>
            publication in RSA CryptoBytes, Spring of 1995.
            <em>http://www.rsasecurity.com/rsalabs/cryptobytes</em>.
            <p>
            This implementation is set to work with a 64 bit word size.</p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC564Engine.#ctor">
            Create an instance of the RC5 encryption algorithm
            and set some defaults
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC564Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a RC5-64 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC564Engine.SetKey(System.Byte[])">
             Re-key the cipher.
            
             @param  key  the key to be used
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC564Engine.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Encrypt the given block starting at the given offset and place
             the result in the provided buffer starting at the given offset.
            
             @param  in      in byte buffer containing data to encrypt
             @param  inOff   offset into src buffer
             @param  out     out buffer where encrypted data is written
             @param  outOff  offset into out buffer
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC564Engine.RotateLeft(System.Int64,System.Int64)">
             Perform a left "spin" of the word. The rotation of the given
             word <em>x</em> is rotated left by <em>y</em> bits.
             Only the <em>lg(wordSize)</em> low-order bits of <em>y</em>
             are used to determine the rotation amount. Here it is
             assumed that the wordsize used is a power of 2.
            
             @param  x  word to rotate
             @param  y    number of bits to rotate % wordSize
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC564Engine.RotateRight(System.Int64,System.Int64)">
             Perform a right "spin" of the word. The rotation of the given
             word <em>x</em> is rotated left by <em>y</em> bits.
             Only the <em>lg(wordSize)</em> low-order bits of <em>y</em>
             are used to determine the rotation amount. Here it is
             assumed that the wordsize used is a power of 2.
            
             @param x word to rotate
             @param y number of bits to rotate % wordSize
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RC6Engine">
            An RC6 engine.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC6Engine.#ctor">
            Create an instance of the RC6 encryption algorithm
            and set some defaults
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC6Engine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a RC5-32 cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC6Engine.SetKey(System.Byte[])">
             Re-key the cipher.
            
             @param inKey the key to be used
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC6Engine.RotateLeft(System.Int32,System.Int32)">
             Perform a left "spin" of the word. The rotation of the given
             word <em>x</em> is rotated left by <em>y</em> bits.
             Only the <em>lg(wordSize)</em> low-order bits of <em>y</em>
             are used to determine the rotation amount. Here it is
             assumed that the wordsize used is a power of 2.
            
             @param x word to rotate
             @param y number of bits to rotate % wordSize
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RC6Engine.RotateRight(System.Int32,System.Int32)">
             Perform a right "spin" of the word. The rotation of the given
             word <em>x</em> is rotated left by <em>y</em> bits.
             Only the <em>lg(wordSize)</em> low-order bits of <em>y</em>
             are used to determine the rotation amount. Here it is
             assumed that the wordsize used is a power of 2.
            
             @param x word to rotate
             @param y number of bits to rotate % wordSize
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.Rfc3211WrapEngine">
            an implementation of the RFC 3211 Key Wrap
            Specification.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RijndaelEngine">
            an implementation of Rijndael, based on the documentation and reference implementation
            by Paulo Barreto, Vincent Rijmen, for v2.0 August '99.
            <p>
            Note: this implementation is based on information prior to readonly NIST publication.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.Mul0x2(System.Int32)">
            multiply two elements of GF(2^m)
            needed for MixColumn and InvMixColumn
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.KeyAddition(System.Int64[])">
            xor corresponding text input and round key input bytes
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.ShiftRow(System.Byte[])">
            Row 0 remains unchanged
            The other three rows are shifted a variable amount
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.Substitution(System.Byte[])">
            Replace every byte of the input by the byte at that place
            in the nonlinear S-box
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.MixColumn">
            Mix the bytes of every column in a linear way
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.InvMixColumn">
            Mix the bytes of every column in a linear way
            This is the opposite operation of Mixcolumn
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.GenerateWorkingKey(System.Byte[])">
            Calculate the necessary round keys
            The number of calculations depends on keyBits and blockBits
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.#ctor">
            default constructor - 128 bit block size.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.#ctor(System.Int32)">
             basic constructor - set the cipher up for a given blocksize
            
             @param blocksize the blocksize in bits, must be 128, 192, or 256.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RijndaelEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a Rijndael cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine">
            this does your basic RSA algorithm with blinding
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the RSA engine.
            
             @param forEncryption true if we are encrypting, false otherwise.
             @param param the necessary RSA key parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine.GetInputBlockSize">
             Return the maximum size for an input block to this engine.
             For RSA this is always one byte less than the key size on
             encryption, and the same length as the key size on decryption.
            
             @return maximum size for an input block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine.GetOutputBlockSize">
             Return the maximum size for an output block to this engine.
             For RSA this is always one byte less than the key size on
             decryption, and the same length as the key size on encryption.
            
             @return maximum size for an output block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaBlindedEngine.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
             Process a single block using the basic RSA algorithm.
            
             @param inBuf the input array.
             @param inOff the offset into the input buffer where the data starts.
             @param inLen the length of the data to be processed.
             @return the result of the RSA process.
             @exception DataLengthException the input block is too large.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.RsaCoreEngine">
            this does your basic RSA algorithm.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaCoreEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the RSA engine.
            
             @param forEncryption true if we are encrypting, false otherwise.
             @param param the necessary RSA key parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaCoreEngine.GetInputBlockSize">
             Return the maximum size for an input block to this engine.
             For RSA this is always one byte less than the key size on
             encryption, and the same length as the key size on decryption.
            
             @return maximum size for an input block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.RsaCoreEngine.GetOutputBlockSize">
             Return the maximum size for an output block to this engine.
             For RSA this is always one byte less than the key size on
             decryption, and the same length as the key size on encryption.
            
             @return maximum size for an output block.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.SeedEngine">
            Implementation of the SEED algorithm as described in RFC 4009
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.SeedWrapEngine">
            <remarks>
            An implementation of the SEED key wrapper based on RFC 4010/RFC 3394.
            <p/>
            For further details see: <a href="http://www.ietf.org/rfc/rfc4010.txt">http://www.ietf.org/rfc/rfc4010.txt</a>.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.SerpentEngine">
                * Serpent is a 128-bit 32-round block cipher with variable key lengths,
                * including 128, 192 and 256 bit keys conjectured to be at least as
                * secure as three-key triple-DES.
                * <p>
                * Serpent was designed by Ross Anderson, Eli Biham and Lars Knudsen as a
                * candidate algorithm for the NIST AES Quest.>
            	* </p>
                * <p>
                * For full details see the <a href="http://www.cl.cam.ac.uk/~rja14/serpent.html">The Serpent home page</a>
            	* </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a Serpent cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.MakeWorkingKey(System.Byte[])">
             Expand a user-supplied key material into a session key.
            
             @param key  The user-key bytes (multiples of 4) to use.
             @exception ArgumentException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Encrypt one block of plaintext.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Decrypt one block of ciphertext.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Sb0(System.Int32,System.Int32,System.Int32,System.Int32)">
            S0 - { 3, 8,15, 1,10, 6, 5,11,14,13, 4, 2, 7, 0, 9,12 } - 15 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Ib0(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvSO - {13, 3,11, 0,10, 6, 5,12, 1,14, 4, 7,15, 9, 8, 2 } - 15 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Sb1(System.Int32,System.Int32,System.Int32,System.Int32)">
            S1 - {15,12, 2, 7, 9, 0, 5,10, 1,11,14, 8, 6,13, 3, 4 } - 14 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Ib1(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS1 - { 5, 8, 2,14,15, 6,12, 3,11, 4, 7, 9, 1,13,10, 0 } - 14 steps.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Sb2(System.Int32,System.Int32,System.Int32,System.Int32)">
            S2 - { 8, 6, 7, 9, 3,12,10,15,13, 1,14, 4, 0,11, 5, 2 } - 16 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Ib2(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS2 - {12, 9,15, 4,11,14, 1, 2, 0, 3, 6,13, 5, 8,10, 7 } - 16 steps.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Sb3(System.Int32,System.Int32,System.Int32,System.Int32)">
            S3 - { 0,15,11, 8,12, 9, 6, 3,13, 1, 2, 4,10, 7, 5,14 } - 16 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Ib3(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS3 - { 0, 9,10, 7,11,14, 6,13, 3, 5,12, 2, 4, 8,15, 1 } - 15 terms
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Sb4(System.Int32,System.Int32,System.Int32,System.Int32)">
            S4 - { 1,15, 8, 3,12, 0,11, 6, 2, 5, 4,10, 9,14, 7,13 } - 15 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Ib4(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS4 - { 5, 0, 8, 3,10, 9, 7,14, 2,12,11, 6, 4,15,13, 1 } - 15 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Sb5(System.Int32,System.Int32,System.Int32,System.Int32)">
            S5 - {15, 5, 2,11, 4,10, 9,12, 0, 3,14, 8,13, 6, 7, 1 } - 16 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Ib5(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS5 - { 8,15, 2, 9, 4, 1,13,14,11, 6, 5, 3, 7,12,10, 0 } - 16 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Sb6(System.Int32,System.Int32,System.Int32,System.Int32)">
            S6 - { 7, 2,12, 5, 8, 4, 6,11,14, 9, 1,15,13, 3,10, 0 } - 15 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Ib6(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS6 - {15,10, 1,13, 5, 3, 6, 0, 4, 9,14, 7, 2,12, 8,11 } - 15 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Sb7(System.Int32,System.Int32,System.Int32,System.Int32)">
            S7 - { 1,13,15, 0,14, 8, 2,11, 7, 4,12,10, 9, 3, 5, 6 } - 16 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.Ib7(System.Int32,System.Int32,System.Int32,System.Int32)">
            InvS7 - { 3, 0, 6,13, 9,14,15, 8, 5,12,11, 7,10, 1, 4, 2 } - 17 terms.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.LT">
            Apply the linear transformation to the register set.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SerpentEngine.InverseLT">
            Apply the inverse of the linear transformation to the register set.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.SkipjackEngine">
            a class that provides a basic SKIPJACK engine.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SkipjackEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a SKIPJACK cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SkipjackEngine.G(System.Int32,System.Int32)">
            The G permutation
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.SkipjackEngine.H(System.Int32,System.Int32)">
            the inverse of the G permutation.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.TeaEngine">
            An TEA engine.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TeaEngine.#ctor">
            Create an instance of the TEA encryption algorithm
            and set some defaults
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TeaEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise
            
             @param forEncryption whether or not we are for encryption.
             @param params the parameters required to set up the cipher.
             @exception ArgumentException if the params argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TeaEngine.setKey(System.Byte[])">
             Re-key the cipher.
            
             @param  key  the key to be used
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.TwofishEngine">
             A class that provides Twofish encryption operations.
            
             This Java implementation is based on the Java reference
             implementation provided by Bruce Schneier and developed
             by Raif S. Naffah.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.TwofishEngine.P_00">
            Define the fixed p0/p1 permutations used in keyed S-box lookup.
            By changing the following constant definitions, the S-boxes will
            automatically Get changed in the Twofish engine.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Engines.TwofishEngine.gSubKeys">
            gSubKeys[] and gSBox[] are eventually used in the
            encryption and decryption methods.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TwofishEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise a Twofish cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TwofishEngine.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Encrypt the given input starting at the given offset and place
             the result in the provided buffer starting at the given offset.
             The input will be an exact multiple of our blocksize.
            
             encryptBlock uses the pre-calculated gSBox[] and subKey[]
             arrays.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TwofishEngine.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            Decrypt the given input starting at the given offset and place
            the result in the provided buffer starting at the given offset.
            The input will be an exact multiple of our blocksize.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TwofishEngine.RS_MDS_Encode(System.Int32,System.Int32)">
             Use (12, 8) Reed-Solomon code over GF(256) to produce
             a key S-box 32-bit entity from 2 key material 32-bit
             entities.
            
             @param    k0 first 32-bit entity
             @param    k1 second 32-bit entity
             @return     Remainder polynomial Generated using RS code
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.TwofishEngine.RS_rem(System.Int32)">
                    * Reed-Solomon code parameters: (12,8) reversible code:
            		* <p>
                    * <pre>
                    * G(x) = x^4 + (a+1/a)x^3 + ax^2 + (a+1/a)x + 1
                    * </pre>
                    * where a = primitive root of field generator 0x14D
            		* </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.VmpcEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            initialise a VMPC cipher.
            
            @param forEncryption
               whether or not we are for encryption.
            @param params
               the parameters required to set up the cipher.
            @exception ArgumentException
               if the params argument is inappropriate.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Engines.XteaEngine">
            An XTEA engine.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.XteaEngine.#ctor">
            Create an instance of the TEA encryption algorithm
            and set some defaults
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.XteaEngine.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise
            
             @param forEncryption whether or not we are for encryption.
             @param params the parameters required to set up the cipher.
             @exception ArgumentException if the params argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Engines.XteaEngine.setKey(System.Byte[])">
             Re-key the cipher.
            
             @param  key  the key to be used
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.DHBasicKeyPairGenerator">
             a basic Diffie-Hellman key pair generator.
            
             This generates keys consistent for use with the basic algorithm for
             Diffie-Hellman.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IAsymmetricCipherKeyPairGenerator">
            interface that a public/private key pair generator should conform to.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricCipherKeyPairGenerator.Init(Org.BouncyCastle.Crypto.KeyGenerationParameters)">
             intialise the key pair generator.
            
             @param the parameters the key pair is to be initialised with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IAsymmetricCipherKeyPairGenerator.GenerateKeyPair">
             return an AsymmetricCipherKeyPair containing the Generated keys.
            
             @return an AsymmetricCipherKeyPair containing the Generated keys.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.DHKeyPairGenerator">
             a Diffie-Hellman key pair generator.
            
             This generates keys consistent for use in the MTI/A0 key agreement protocol
             as described in "Handbook of Applied Cryptography", Pages 516-519.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.DsaKeyPairGenerator">
             a DSA key pair generator.
            
             This Generates DSA keys in line with the method described
             in <i>FIPS 186-3 B.1 FFC Key Pair Generation</i>.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.ECKeyPairGenerator.GenerateKeyPair">
            Given the domain parameters this routine generates an EC key
            pair in accordance with X9.62 section 5.2.1 pages 26, 27.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.ElGamalKeyPairGenerator">
            a ElGamal key pair generator.
            <p>
            This Generates keys consistent for use with ElGamal as described in
            page 164 of "Handbook of Applied Cryptography".</p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.Poly1305KeyGenerator">
            <summary>
            Generates keys for the Poly1305 MAC.
            </summary>
            <remarks>
            Poly1305 keys are 256 bit keys consisting of a 128 bit secret key used for the underlying block
            cipher followed by a 128 bit {@code r} value used for the polynomial portion of the Mac. <br/>
            The {@code r} value has a specific format with some bits required to be cleared, resulting in an
            effective 106 bit key. <br/>
            A separately generated 256 bit key can be modified to fit the Poly1305 key format by using the
            {@link #clamp(byte[])} method to clear the required bits.
            </remarks>
            <seealso cref="T:Org.BouncyCastle.Crypto.Macs.Poly1305"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Poly1305KeyGenerator.engineInit(Org.BouncyCastle.Crypto.KeyGenerationParameters)">
            <summary>
            Initialises the key generator.
            </summary>
            <remarks>
            Poly1305 keys are always 256 bits, so the key length in the provided parameters is ignored.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Poly1305KeyGenerator.engineGenerateKey">
            <summary>
            Generates a 256 bit key in the format required for Poly1305 - e.g.
            <code>k[0] ... k[15], r[0] ... r[15]</code> with the required bits in <code>r</code> cleared
            as per <see cref="M:Org.BouncyCastle.Crypto.Generators.Poly1305KeyGenerator.Clamp(System.Byte[])"/>.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Poly1305KeyGenerator.Clamp(System.Byte[])">
            <summary>
            Modifies an existing 32 byte key value to comply with the requirements of the Poly1305 key by
            clearing required bits in the <code>r</code> (second 16 bytes) portion of the key.<br/>
            Specifically:
            <ul>
            <li>r[3], r[7], r[11], r[15] have top four bits clear (i.e., are {0, 1, . . . , 15})</li>
            <li>r[4], r[8], r[12] have bottom two bits clear (i.e., are in {0, 4, 8, . . . , 252})</li>
            </ul>
            </summary>
            <param name="key">a 32 byte key value <code>k[0] ... k[15], r[0] ... r[15]</code></param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.Poly1305KeyGenerator.CheckKey(System.Byte[])">
            <summary>
            Checks a 32 byte key for compliance with the Poly1305 key requirements, e.g.
            <code>k[0] ... k[15], r[0] ... r[15]</code> with the required bits in <code>r</code> cleared
            as per <see cref="M:Org.BouncyCastle.Crypto.Generators.Poly1305KeyGenerator.Clamp(System.Byte[])"/>.
            </summary>
            <param name="key">Key.</param>
            <exception cref="T:System.ArgumentException">if the key is of the wrong length, or has invalid bits set
                      in the <code>r</code> portion of the key.</exception>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Generators.RsaKeyPairGenerator">
            an RSA key pair generator.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Generators.RsaKeyPairGenerator.ChooseRandomPrime(System.Int32,Org.BouncyCastle.Math.BigInteger)">
            <summary>Choose a random prime value for use with RSA</summary>
            <param name="bitlength">the bit-length of the returned prime</param>
            <param name="e">the RSA public exponent</param>
            <returns>a prime p, with (p-1) relatively prime to e</returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IDerivationFunction">
            base interface for general purpose byte derivation functions.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IDerivationFunction.Digest">
            return the message digest used as the basis for the function
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IDerivationParameters">
            Parameters for key/byte stream derivation classes
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IDsa">
            interface for classes implementing the Digital Signature Algorithm
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDsa.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the signer for signature generation or signature
             verification.
            
             @param forSigning true if we are generating a signature, false
             otherwise.
             @param param key parameters for signature generation.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDsa.GenerateSignature(System.Byte[])">
             sign the passed in message (usually the output of a hash function).
            
             @param message the message to be signed.
             @return two big integers representing the r and s values respectively.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IDsa.VerifySignature(System.Byte[],Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
             verify the message message against the signature values r and s.
            
             @param message the message that was supposed to have been signed.
             @param r the r signature value.
             @param s the s signature value.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.IMac">
            The base interface for implementations of message authentication codes (MACs).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.Init(Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the MAC.
            
             @param param the key and other data required by the MAC.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.GetMacSize">
             Return the block size for this MAC (in bytes).
            
             @return the block size for this MAC in bytes.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.Update(System.Byte)">
             add a single byte to the mac for processing.
            
             @param in the byte to be processed.
             @exception InvalidOperationException if the MAC is not initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            @param in the array containing the input.
            @param inOff the index in the array the data begins at.
            @param len the length of the input starting at inOff.
            @exception InvalidOperationException if the MAC is not initialised.
            @exception DataLengthException if there isn't enough data in in.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.DoFinal(System.Byte[],System.Int32)">
            Compute the final stage of the MAC writing the output to the out
            parameter.
            <p>
            doFinal leaves the MAC in the same state it was after the last init.
            </p>
            @param out the array the MAC is to be output to.
            @param outOff the offset into the out buffer the output is to start at.
            @exception DataLengthException if there isn't enough space in out.
            @exception InvalidOperationException if the MAC is not initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.IMac.Reset">
            Reset the MAC. At the end of resetting the MAC should be in the
            in the same state it was after the last init (if there was one).
        </member>
        <member name="P:Org.BouncyCastle.Crypto.IMac.AlgorithmName">
             Return the name of the algorithm the MAC implements.
            
             @return the name of the algorithm the MAC implements.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.InvalidCipherTextException">
            this exception is thrown whenever we find something we don't expect in a
            message.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.InvalidCipherTextException.#ctor">
            base constructor.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.InvalidCipherTextException.#ctor(System.String)">
             create a InvalidCipherTextException with the given message.
            
             @param message the message to be carried with the exception.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the signer for signing or verification.
            
             @param forSigning true if for signing, false otherwise
             @param param necessary parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.Update(System.Byte)">
            update the internal digest with the byte b
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            update the internal digest with the byte array in
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.GenerateSignature">
            Generate a signature for the message we've been loaded with using
            the key we were initialised with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.VerifySignature(System.Byte[])">
            return true if the internal state represents the signature described
            in the passed in array.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISigner.Reset">
            reset the internal state
        </member>
        <member name="P:Org.BouncyCastle.Crypto.ISigner.AlgorithmName">
             Return the name of the algorithm the signer implements.
            
             @return the name of the algorithm the signer implements.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.ISignerWithRecovery">
            Signer with message recovery.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISignerWithRecovery.HasFullMessage">
             Returns true if the signer has recovered the full message as
             part of signature verification.
            
             @return true if full message recovered.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISignerWithRecovery.GetRecoveredMessage">
             Returns a reference to what message was recovered (if any).
            
             @return full/partial message, null if nothing.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.ISignerWithRecovery.UpdateWithRecoveredMessage(System.Byte[])">
             Perform an update with the recovered message before adding any other data. This must
             be the first update method called, and calling it will result in the signer assuming
             that further calls to update will include message content past what is recoverable.
            
             @param signature the signature that we are in the process of verifying.
             @throws IllegalStateException
        </member>
        <member name="T:Org.BouncyCastle.Crypto.KeyGenerationParameters">
            The base class for parameters to key generators.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.KeyGenerationParameters.#ctor(Org.BouncyCastle.Security.SecureRandom,System.Int32)">
             initialise the generator with a source of randomness
             and a strength (in bits).
            
             @param random the random byte source.
             @param strength the size, in bits, of the keys we want to produce.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.KeyGenerationParameters.Random">
             return the random source associated with this
             generator.
            
             @return the generators random source.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.KeyGenerationParameters.Strength">
             return the bit strength for keys produced by this generator,
            
             @return the strength of the keys this generator produces (in bits).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac">
            standard CBC Block Cipher MAC - if no padding is specified the default of
            pad of zeroes is used.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             create a standard MAC based on a CBC block cipher. This will produce an
             authentication code half the length of the block size of the cipher.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
             create a standard MAC based on a CBC block cipher. This will produce an
             authentication code half the length of the block size of the cipher.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
             @param padding the padding to be used to complete the last block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
            create a standard MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses CBC mode as the basis for the
            MAC generation.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
            create a standard MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses CBC mode as the basis for the
            MAC generation.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
            @param padding the padding to be used to complete the last block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CbcBlockCipherMac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.MacCFBBlockCipher">
            implements a Cipher-FeedBack (CFB) mode on top of a simple cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.MacCFBBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of the
             feedback mode.
             @param blockSize the block size in bits (note: a multiple of 8)
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.MacCFBBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
             An IV which is too short is handled in FIPS compliant fashion.
            
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.MacCFBBlockCipher.GetBlockSize">
             return the block size we are operating at.
            
             @return the block size we are operating at (in bytes).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.MacCFBBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.MacCFBBlockCipher.Reset">
            reset the chaining vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Macs.MacCFBBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/CFB"
             and the block size in bits.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CfbBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             create a standard MAC based on a CFB block cipher. This will produce an
             authentication code half the length of the block size of the cipher, with
             the CFB mode set to 8 bits.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CfbBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
             create a standard MAC based on a CFB block cipher. This will produce an
             authentication code half the length of the block size of the cipher, with
             the CFB mode set to 8 bits.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
             @param padding the padding to be used.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CfbBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32,System.Int32)">
            create a standard MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses CFB mode as the basis for the
            MAC generation.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param cfbBitSize the size of an output block produced by the CFB mode.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CfbBlockCipherMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32,System.Int32,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
            create a standard MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses CFB mode as the basis for the
            MAC generation.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param cfbBitSize the size of an output block produced by the CFB mode.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
            @param padding a padding to be used.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CfbBlockCipherMac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.CMac">
            CMAC - as specified at www.nuee.nagoya-u.ac.jp/labs/tiwata/omac/omac.html
            <p>
            CMAC is analogous to OMAC1 - see also en.wikipedia.org/wiki/CMAC
            </p><p>
            CMAC is a NIST recomendation - see 
            csrc.nist.gov/CryptoToolkit/modes/800-38_Series_Publications/SP800-38B.pdf
            </p><p>
            CMAC/OMAC1 is a blockcipher-based message authentication code designed and
            analyzed by Tetsu Iwata and Kaoru Kurosawa.
            </p><p>
            CMAC/OMAC1 is a simple variant of the CBC MAC (Cipher Block Chaining Message 
            Authentication Code). OMAC stands for One-Key CBC MAC.
            </p><p>
            It supports 128- or 64-bits block ciphers, with any key size, and returns
            a MAC with dimension less or equal to the block size of the underlying 
            cipher.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             create a standard MAC based on a CBC block cipher (64 or 128 bit block).
             This will produce an authentication code the length of the block size
             of the cipher.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CMac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
             create a standard MAC based on a block cipher with the size of the
             MAC been given in bits.
             <p/>
             Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
             or 16 bits if being used as a data authenticator (FIPS Publication 113),
             and in general should be less than the size of the block cipher as it reduces
             the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            
             @param cipher        the cipher to be used as the basis of the MAC generation.
             @param macSizeInBits the size of the MAC in bits, must be a multiple of 8 and @lt;= 128.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.CMac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.Gost28147Mac">
            implementation of GOST 28147-89 MAC
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.HMac">
             HMAC implementation based on RFC2104
            
             H(K XOR opad, H(K XOR ipad, text))
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.HMac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac">
             DES based CBC Block Cipher MAC according to ISO9797, algorithm 3 (ANSI X9.19 Retail MAC)
            
             This could as well be derived from CBCBlockCipherMac, but then the property mac in the base
             class must be changed to protected
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             create a Retail-MAC based on a CBC block cipher. This will produce an
             authentication code of the length of the block size of the cipher.
            
             @param cipher the cipher to be used as the basis of the MAC generation. This must
             be DESEngine.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
             create a Retail-MAC based on a CBC block cipher. This will produce an
             authentication code of the length of the block size of the cipher.
            
             @param cipher the cipher to be used as the basis of the MAC generation.
             @param padding the padding to be used to complete the last block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
            create a Retail-MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses single DES CBC mode as the basis for the
            MAC generation.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
            create a standard MAC based on a block cipher with the size of the
            MAC been given in bits. This class uses single DES CBC mode as the basis for the
            MAC generation. The final block is decrypted and then encrypted using the
            middle and right part of the key.
            <p>
            Note: the size of the MAC must be at least 24 bits (FIPS Publication 81),
            or 16 bits if being used as a data authenticator (FIPS Publication 113),
            and in general should be less than the size of the block cipher as it reduces
            the chance of an exhaustive attack (see Handbook of Applied Cryptography).
            </p>
            @param cipher the cipher to be used as the basis of the MAC generation.
            @param macSizeInBits the size of the MAC in bits, must be a multiple of 8.
            @param padding the padding to be used to complete the last block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.ISO9797Alg3Mac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.Poly1305">
            <summary>
            Poly1305 message authentication code, designed by D. J. Bernstein.
            </summary>
            <remarks>
            Poly1305 computes a 128-bit (16 bytes) authenticator, using a 128 bit nonce and a 256 bit key
            consisting of a 128 bit key applied to an underlying cipher, and a 128 bit key (with 106
            effective key bits) used in the authenticator.
            
            The polynomial calculation in this implementation is adapted from the public domain <a href="https://github.com/floodyberry/poly1305-donna">poly1305-donna-unrolled</a> C implementation
            by Andrew M (@floodyberry).
            </remarks>
            <seealso cref="T:Org.BouncyCastle.Crypto.Generators.Poly1305KeyGenerator"/>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.r0">
            Polynomial key 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.r1">
            Polynomial key 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.r2">
            Polynomial key 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.r3">
            Polynomial key 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.r4">
            Polynomial key 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.s1">
            Precomputed 5 * r[1..4] 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.s2">
            Precomputed 5 * r[1..4] 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.s3">
            Precomputed 5 * r[1..4] 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.s4">
            Precomputed 5 * r[1..4] 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.k0">
            Encrypted nonce 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.k1">
            Encrypted nonce 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.k2">
            Encrypted nonce 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.k3">
            Encrypted nonce 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.currentBlock">
            Current block of buffered input 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.currentBlockOffset">
            Current offset in input buffer 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.h0">
            Polynomial accumulator 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.h1">
            Polynomial accumulator 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.h2">
            Polynomial accumulator 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.h3">
            Polynomial accumulator 
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Macs.Poly1305.h4">
            Polynomial accumulator 
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.Poly1305.#ctor">
            Constructs a Poly1305 MAC, where the key passed to init() will be used directly.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.Poly1305.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
            Constructs a Poly1305 MAC, using a 128 bit block cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.Poly1305.Init(Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>
            Initialises the Poly1305 MAC.
            </summary>
            <param name="parameters">a {@link ParametersWithIV} containing a 128 bit nonce and a {@link KeyParameter} with
                     a 256 bit key complying to the {@link Poly1305KeyGenerator Poly1305 key format}.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Macs.SipHash">
            <summary>
            Implementation of SipHash as specified in "SipHash: a fast short-input PRF", by Jean-Philippe
            Aumasson and Daniel J. Bernstein (https://131002.net/siphash/siphash.pdf).
            </summary>
            <remarks>
            "SipHash is a family of PRFs SipHash-c-d where the integer parameters c and d are the number of
            compression rounds and the number of finalization rounds. A compression round is identical to a
            finalization round and this round function is called SipRound. Given a 128-bit key k and a
            (possibly empty) byte string m, SipHash-c-d returns a 64-bit value..."
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.SipHash.#ctor">
            <summary>SipHash-2-4</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Macs.SipHash.#ctor(System.Int32,System.Int32)">
            <summary>SipHash-c-d</summary>
            <param name="c">the number of compression rounds</param>
            <param name="d">the number of finalization rounds</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.MaxBytesExceededException">
            <summary>
            This exception is thrown whenever a cipher requires a change of key, iv
            or similar after x amount of bytes enciphered
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher">
            implements Cipher-Block-Chaining (CBC) mode on top of a simple cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of chaining.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.GetUnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.GetBlockSize">
             return the block size of the underlying cipher.
            
             @return the block size of the underlying cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.Reset">
            reset the chaining vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Do the appropriate chaining step for CBC mode encryption.
            
             @param in the array containing the data to be encrypted.
             @param inOff offset into the in array the data starts at.
             @param out the array the encrypted data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Do the appropriate chaining step for CBC mode decryption.
            
             @param in the array containing the data to be decrypted.
             @param inOff offset into the in array the data starts at.
             @param out the array the decrypted data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.CbcBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/CBC".
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.CcmBlockCipher">
            Implements the Counter with Cipher Block Chaining mode (CCM) detailed in
            NIST Special Publication 800-38C.
            <p>
            <b>Note</b>: this mode is a packet mode - it needs all the data up front.
            </p>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher">
            <summary>
            A block cipher mode that includes authenticated encryption with a streaming mode
            and optional associated data.</summary>
            <see cref="T:Org.BouncyCastle.Crypto.Parameters.AeadParameters"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.GetUnderlyingCipher">
            <summary>The block cipher underlying this algorithm.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <remarks>Parameter can either be an AeadParameters or a ParametersWithIV object.</remarks>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">The key or other data required by the cipher.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.GetBlockSize">
            <returns>The block size for this cipher, in bytes.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.ProcessAadByte(System.Byte)">
            <summary>Add a single byte to the associated data check.</summary>
            <remarks>If the implementation supports it, this will be an online operation and will not retain the associated data.</remarks>
            <param name="input">The byte to be processed.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.ProcessAadBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Add a sequence of bytes to the associated data check.</summary>
            <remarks>If the implementation supports it, this will be an online operation and will not retain the associated data.</remarks>
            <param name="inBytes">The input byte array.</param>
            <param name="inOff">The offset into the input array where the data to be processed starts.</param>
            <param name="len">The number of bytes to be processed.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             Encrypt/decrypt a single byte.
            
             @param input the byte to be processed.
             @param outBytes the output buffer the processed byte goes into.
             @param outOff the offset into the output byte array the processed data starts at.
             @return the number of bytes written to out.
             @exception DataLengthException if the output buffer is too small.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             Process a block of bytes from in putting the result into out.
            
             @param inBytes the input byte array.
             @param inOff the offset into the in array where the data to be processed starts.
             @param len the number of bytes to be processed.
             @param outBytes the output buffer the processed bytes go into.
             @param outOff the offset into the output byte array the processed data starts at.
             @return the number of bytes written to out.
             @exception DataLengthException if the output buffer is too small.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Finish the operation either appending or verifying the MAC at the end of the data.
            
             @param outBytes space for any resulting output data.
             @param outOff offset into out to start copying the data at.
             @return number of bytes written into out.
             @throws InvalidOperationException if the cipher is in an inappropriate state.
             @throws InvalidCipherTextException if the MAC fails to match.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.GetMac">
             Return the value of the MAC associated with the last stream processed.
            
             @return MAC for plaintext data.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.GetUpdateOutputSize(System.Int32)">
             Return the size of the output buffer required for a ProcessBytes
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to ProcessBytes
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.GetOutputSize(System.Int32)">
             Return the size of the output buffer required for a ProcessBytes plus a
             DoFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to ProcessBytes and DoFinal
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.Reset">
            <summary>
            Reset the cipher to the same state as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CcmBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param cipher the block cipher to be used.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CcmBlockCipher.GetUnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CcmBlockCipher.GetMac">
             Returns a byte array containing the mac calculated as part of the
             last encrypt or decrypt operation.
            
             @return the last mac calculated.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CcmBlockCipher.ProcessPacket(System.Byte[],System.Int32,System.Int32)">
             Process a packet of data for either CCM decryption or encryption.
            
             @param in data for processing.
             @param inOff offset at which data starts in the input array.
             @param inLen length of the data in the input array.
             @return a byte array containing the processed input..
             @throws IllegalStateException if the cipher is not appropriately set up.
             @throws InvalidCipherTextException if the input data is truncated or the mac check fails.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CcmBlockCipher.ProcessPacket(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             Process a packet of data for either CCM decryption or encryption.
            
             @param in data for processing.
             @param inOff offset at which data starts in the input array.
             @param inLen length of the data in the input array.
             @param output output array.
             @param outOff offset into output array to start putting processed bytes.
             @return the number of bytes added to output.
             @throws IllegalStateException if the cipher is not appropriately set up.
             @throws InvalidCipherTextException if the input data is truncated or the mac check fails.
             @throws DataLengthException if output buffer too short.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher">
            implements a Cipher-FeedBack (CFB) mode on top of a simple cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of the
             feedback mode.
             @param blockSize the block size in bits (note: a multiple of 8)
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.GetUnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
             An IV which is too short is handled in FIPS compliant fashion.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.GetBlockSize">
             return the block size we are operating at.
            
             @return the block size we are operating at (in bytes).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Do the appropriate processing for CFB mode encryption.
            
             @param in the array containing the data to be encrypted.
             @param inOff offset into the in array the data starts at.
             @param out the array the encrypted data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Do the appropriate processing for CFB mode decryption.
            
             @param in the array containing the data to be decrypted.
             @param inOff offset into the in array the data starts at.
             @param out the array the encrypted data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.Reset">
            reset the chaining vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.CfbBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/CFB"
             and the block size in bits.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.CtsBlockCipher">
            A Cipher Text Stealing (CTS) mode cipher. CTS allows block ciphers to
            be used to produce cipher text which is the same outLength as the plain text.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Create a buffered block cipher that uses Cipher Text Stealing
            
             @param cipher the underlying block cipher this buffering object wraps.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update of 'length' bytes.
            
             @param length the outLength of the input.
             @return the space required to accommodate a call to update
             with length bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.GetOutputSize(System.Int32)">
             return the size of the output buffer required for an update plus a
             doFinal with an input of length bytes.
            
             @param length the outLength of the input.
             @return the space required to accommodate a call to update and doFinal
             with length bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if necessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param length the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.CtsBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if cipher text decrypts wrongly (in
             case the exception will never Get thrown).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.EaxBlockCipher">
            A Two-Pass Authenticated-Encryption Scheme Optimized for Simplicity and 
            Efficiency - by M. Bellare, P. Rogaway, D. Wagner.
            
            http://www.cs.ucdavis.edu/~rogaway/papers/eax.pdf
            
            EAX is an AEAD scheme based on CTR and OMAC1/CMAC, that uses a single block 
            cipher to encrypt and authenticate data. It's on-line (the length of a 
            message isn't needed to begin processing it), has good performances, it's
            simple and provably secure (provided the underlying block cipher is secure).
            
            Of course, this implementations is NOT thread-safe.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.EaxBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Constructor that accepts an instance of a block cipher engine.
            
             @param cipher the engine to use
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.GcmBlockCipher">
            <summary>
            Implements the Galois/Counter mode (GCM) detailed in
            NIST Special Publication 800-38D.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.GcmBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
            <remarks>
            MAC sizes from 32 bits to 128 bits (must be a multiple of 8) are supported. The default is 128 bits.
            Sizes less than 96 are not recommended, but are supported for specialized applications.
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher">
            implements the GOST 28147 OFB counter mode (GCTR).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of the
             counter mode (must have a 64 bit block size).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.GetUnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
             An IV which is too short is handled in FIPS compliant fashion.
            
             @param encrypting if true the cipher is initialised for
              encryption, if false for decryption.
             @param parameters the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.GetBlockSize">
             return the block size we are operating at (in bytes).
            
             @return the block size we are operating at (in bytes).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.Reset">
            reset the feedback vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.GOfbBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/GCTR"
             and the block size in bits
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.OcbBlockCipher">
            An implementation of <a href="http://tools.ietf.org/html/rfc7253">RFC 7253 on The OCB
            Authenticated-Encryption Algorithm</a>, licensed per:
            
            <blockquote><p><a href="http://www.cs.ucdavis.edu/~rogaway/ocb/license1.pdf">License for
            Open-Source Software Implementations of OCB</a> (Jan 9, 2013) - 'License 1'<br/>
            Under this license, you are authorized to make, use, and distribute open-source software
            implementations of OCB. This license terminates for you if you sue someone over their open-source
            software implementation of OCB claiming that you have a patent covering their implementation.
            </p><p>
            This is a non-binding summary of a legal document (the link above). The parameters of the license
            are specified in the license document and that document is controlling.</p></blockquote>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher">
            implements a Output-FeedBack (OFB) mode on top of a simple cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,System.Int32)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of the
             feedback mode.
             @param blockSize the block size in bits (note: a multiple of 8)
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.GetUnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
             An IV which is too short is handled in FIPS compliant fashion.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.GetBlockSize">
             return the block size we are operating at (in bytes).
            
             @return the block size we are operating at (in bytes).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.Reset">
            reset the feedback vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.OfbBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/OFB"
             and the block size in bits
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher">
                * Implements OpenPGP's rather strange version of Cipher-FeedBack (CFB) mode
                * on top of a simple cipher. This class assumes the IV has been prepended
                * to the data stream already, and just accomodates the reset after
                * (blockSize + 2) bytes have been read.
                * <p>
                * For further info see <a href="http://www.ietf.org/rfc/rfc2440.html">RFC 2440</a>.
            	* </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param cipher the block cipher to be used as the basis of the
             feedback mode.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.GetUnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.GetBlockSize">
             return the block size we are operating at.
            
             @return the block size we are operating at (in bytes).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Process one block of input from the array in and write it to
             the out array.
            
             @param in the array containing the input data.
             @param inOff offset into the in array the data starts at.
             @param out the array the output data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.Reset">
            reset the chaining vector back to the IV and reset the underlying
            cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the cipher and, possibly, the initialisation vector (IV).
             If an IV isn't passed as part of the parameter, the IV will be all zeros.
             An IV which is too short is handled in FIPS compliant fashion.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param parameters the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.EncryptByte(System.Byte,System.Int32)">
            Encrypt one byte of data according to CFB mode.
            @param data the byte to encrypt
            @param blockOff offset in the current block
            @returns the encrypted byte
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Do the appropriate processing for CFB IV mode encryption.
            
             @param in the array containing the data to be encrypted.
             @param inOff offset into the in array the data starts at.
             @param out the array the encrypted data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
             Do the appropriate processing for CFB IV mode decryption.
            
             @param in the array containing the data to be decrypted.
             @param inOff offset into the in array the data starts at.
             @param out the array the encrypted data will be copied into.
             @param outOff the offset into the out array the output will start at.
             @exception DataLengthException if there isn't enough data in in, or
             space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
             @return the number of bytes processed and produced.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Modes.OpenPgpCfbBlockCipher.AlgorithmName">
             return the algorithm name and mode.
            
             @return the name of the underlying algorithm followed by "/PGPCFB"
             and the block size in bits.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Modes.SicBlockCipher">
            Implements the Segmented Integer Counter (SIC) mode on top of a simple
            block cipher.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.SicBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Basic constructor.
            
             @param c the block cipher to be used.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Modes.SicBlockCipher.GetUnderlyingCipher">
             return the underlying block cipher that we are wrapping.
            
             @return the underlying block cipher that we are wrapping.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding">
            Block cipher padders are expected to conform to this interface
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.Init(Org.BouncyCastle.Security.SecureRandom)">
             Initialise the padder.
            
             @param param parameters, if any required.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.AddPadding(System.Byte[],System.Int32)">
            add the pad bytes to the passed in block, returning the
            number of bytes added.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.PadCount(System.Byte[])">
            return the number of pad bytes present in the block.
            @exception InvalidCipherTextException if the padding is badly formed
            or invalid.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.PaddingName">
             Return the name of the algorithm the cipher implements.
            
             @return the name of the algorithm the cipher implements.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.ISO10126d2Padding">
            A padder that adds ISO10126-2 padding to a block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ISO10126d2Padding.Init(Org.BouncyCastle.Security.SecureRandom)">
             Initialise the padder.
            
             @param random a SecureRandom if available.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ISO10126d2Padding.AddPadding(System.Byte[],System.Int32)">
            add the pad bytes to the passed in block, returning the
            number of bytes added.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ISO10126d2Padding.PadCount(System.Byte[])">
            return the number of pad bytes present in the block.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.ISO10126d2Padding.PaddingName">
             Return the name of the algorithm the cipher implements.
            
             @return the name of the algorithm the cipher implements.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.ISO7816d4Padding">
            A padder that adds the padding according to the scheme referenced in
            ISO 7814-4 - scheme 2 from ISO 9797-1. The first byte is 0x80, rest is 0x00
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ISO7816d4Padding.Init(Org.BouncyCastle.Security.SecureRandom)">
             Initialise the padder.
            
             @param random - a SecureRandom if available.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ISO7816d4Padding.AddPadding(System.Byte[],System.Int32)">
            add the pad bytes to the passed in block, returning the
            number of bytes added.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ISO7816d4Padding.PadCount(System.Byte[])">
            return the number of pad bytes present in the block.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.ISO7816d4Padding.PaddingName">
             Return the name of the algorithm the padder implements.
            
             @return the name of the algorithm the padder implements.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher">
            A wrapper class that allows block ciphers to be used to process data in
            a piecemeal fashion with padding. The PaddedBufferedBlockCipher
            outputs a block only when the buffer is full and more data is being added,
            or on a doFinal (unless the current block in the buffer is a pad block).
            The default padding mechanism used is the one outlined in Pkcs5/Pkcs7.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher,Org.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
             Create a buffered block cipher with the desired padding.
            
             @param cipher the underlying block cipher this buffering object wraps.
             @param padding the padding type.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.#ctor(Org.BouncyCastle.Crypto.IBlockCipher)">
             Create a buffered block cipher Pkcs7 padding
            
             @param cipher the underlying block cipher this buffering object wraps.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.GetOutputSize(System.Int32)">
             return the minimum size of the output buffer required for an update
             plus a doFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update and doFinal
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update
             with len bytes of input.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if necessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param len the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer. If the buffer is currently
             full and padding needs to be added a call to doFinal will produce
             2 * GetBlockSize() bytes.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output or we are decrypting and the input is not block size aligned.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if padding is expected and not found.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding">
            A padder that adds Pkcs7/Pkcs5 padding to a block.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding.Init(Org.BouncyCastle.Security.SecureRandom)">
             Initialise the padder.
            
             @param random - a SecureRandom if available.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding.AddPadding(System.Byte[],System.Int32)">
            add the pad bytes to the passed in block, returning the
            number of bytes added.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding.PadCount(System.Byte[])">
            return the number of pad bytes present in the block.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.Pkcs7Padding.PaddingName">
             Return the name of the algorithm the cipher implements.
            
             @return the name of the algorithm the cipher implements.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.TbcPadding">
            <summary> A padder that adds Trailing-Bit-Compliment padding to a block.
            <p>
            This padding pads the block out compliment of the last bit
            of the plain text.
            </p>
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.TbcPadding.Init(Org.BouncyCastle.Security.SecureRandom)">
            <summary> Initialise the padder.</summary>
            <param name="random">- a SecureRandom if available.
            </param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.TbcPadding.AddPadding(System.Byte[],System.Int32)">
            <summary> add the pad bytes to the passed in block, returning the
            number of bytes added.
            <p>
            Note: this assumes that the last block of plain text is always
            passed to it inside in. i.e. if inOff is zero, indicating the
            entire block is to be overwritten with padding the value of in
            should be the same as the last block of plain text.
            </p>
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.TbcPadding.PadCount(System.Byte[])">
            <summary> return the number of pad bytes present in the block.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.TbcPadding.PaddingName">
            <summary> Return the name of the algorithm the cipher implements.</summary>
            <returns> the name of the algorithm the cipher implements.
            </returns>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.X923Padding">
            A padder that adds X9.23 padding to a block - if a SecureRandom is
            passed in random padding is assumed, otherwise padding with zeros is used.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.X923Padding.Init(Org.BouncyCastle.Security.SecureRandom)">
             Initialise the padder.
            
             @param random a SecureRandom if one is available.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.X923Padding.AddPadding(System.Byte[],System.Int32)">
            add the pad bytes to the passed in block, returning the
            number of bytes added.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.X923Padding.PadCount(System.Byte[])">
            return the number of pad bytes present in the block.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.X923Padding.PaddingName">
             Return the name of the algorithm the cipher implements.
            
             @return the name of the algorithm the cipher implements.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Paddings.ZeroBytePadding">
            <summary> A padder that adds Null byte padding to a block.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ZeroBytePadding.Init(Org.BouncyCastle.Security.SecureRandom)">
             <summary> Initialise the padder.
            
             </summary>
             <param name="random">- a SecureRandom if available.
             </param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ZeroBytePadding.AddPadding(System.Byte[],System.Int32)">
            <summary> add the pad bytes to the passed in block, returning the
            number of bytes added.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Paddings.ZeroBytePadding.PadCount(System.Byte[])">
            <summary> return the number of pad bytes present in the block.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Paddings.ZeroBytePadding.PaddingName">
             <summary> Return the name of the algorithm the cipher implements.
            
             </summary>
             <returns> the name of the algorithm the cipher implements.
             </returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.AeadParameters.#ctor(Org.BouncyCastle.Crypto.Parameters.KeyParameter,System.Int32,System.Byte[])">
             Base constructor.
            
             @param key key to be used by underlying cipher
             @param macSize macSize in bits
             @param nonce nonce to be used
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.AeadParameters.#ctor(Org.BouncyCastle.Crypto.Parameters.KeyParameter,System.Int32,System.Byte[],System.Byte[])">
             Base constructor.
            
             @param key key to be used by underlying cipher
             @param macSize macSize in bits
             @param nonce nonce to be used
             @param associatedText associated text, if any
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.DesParameters.IsWeakKey(System.Byte[],System.Int32)">
            DES has 16 weak keys.  This method will check
            if the given DES key material is weak or semi-weak.
            Key material that is too short is regarded as weak.
            <p>
            See <a href="http://www.counterpane.com/applied.html">"Applied
            Cryptography"</a> by Bruce Schneier for more information.
            </p>
            @return true if the given DES key material is weak or semi-weak,
                false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.DesParameters.SetOddParity(System.Byte[])">
             DES Keys use the LSB as the odd parity bit.  This can
             be used to check for corrupt keys.
            
             @param bytes the byte array to set the parity on.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.DesEdeParameters.IsWeakKey(System.Byte[],System.Int32,System.Int32)">
             return true if the passed in key is a DES-EDE weak key.
            
             @param key bytes making up the key
             @param offset offset into the byte array the key starts at
             @param length number of bytes making up the key
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.DesEdeParameters.IsWeakKey(System.Byte[],System.Int32)">
             return true if the passed in key is a DES-EDE weak key.
            
             @param key bytes making up the key
             @param offset offset into the byte array the key starts at
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.DHParameters.M">
            <summary>The minimum bitlength of the private value.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.DHParameters.L">
            <summary>The bitlength of the private value.</summary>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.ElGamalParameters.G">
            return the generator - g
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Parameters.ElGamalParameters.L">
            return private value limit - l
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.IesParameters">
            parameters for using an integrated cipher in stream mode.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.IesParameters.#ctor(System.Byte[],System.Byte[],System.Int32)">
            @param derivation the derivation parameter for the KDF function.
            @param encoding the encoding parameter for the KDF function.
            @param macKeySize the size of the MAC key (in bits).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Parameters.IesWithCipherParameters.#ctor(System.Byte[],System.Byte[],System.Int32,System.Int32)">
            @param derivation the derivation parameter for the KDF function.
            @param encoding the encoding parameter for the KDF function.
            @param macKeySize the size of the MAC key (in bits).
            @param cipherKeySize the size of the associated Cipher key (in bits).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.Iso18033KdfParameters">
            parameters for Key derivation functions for ISO-18033
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.KdfParameters">
            parameters for Key derivation functions for IEEE P1363a
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Parameters.ParametersWithSalt">
            <summary> Cipher parameters with a fixed salt value associated with them.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.PbeParametersGenerator">
            super class for all Password Based Encyrption (Pbe) parameter generator classes.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.#ctor">
            base constructor.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.Init(System.Byte[],System.Byte[],System.Int32)">
             initialise the Pbe generator.
            
             @param password the password converted into bytes (see below).
             @param salt the salt to be mixed with the password.
             @param iterationCount the number of iterations the "mixing" function
             is to be applied for.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.GetPassword">
             return the password byte array.
            
             @return the password byte array.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.GetSalt">
             return the salt byte array.
            
             @return the salt byte array.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.GenerateDerivedParameters(System.Int32)">
             Generate derived parameters for a key of length keySize.
            
             @param keySize the length, in bits, of the key required.
             @return a parameters object representing a key.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.GenerateDerivedParameters(System.Int32,System.Int32)">
             Generate derived parameters for a key of length keySize, and
             an initialisation vector (IV) of length ivSize.
            
             @param keySize the length, in bits, of the key required.
             @param ivSize the length, in bits, of the iv required.
             @return a parameters object representing a key and an IV.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.GenerateDerivedMacParameters(System.Int32)">
             Generate derived parameters for a key of length keySize, specifically
             for use with a MAC.
            
             @param keySize the length, in bits, of the key required.
             @return a parameters object representing a key.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.Pkcs5PasswordToBytes(System.Char[])">
             converts a password to a byte array according to the scheme in
             Pkcs5 (ascii, no padding)
            
             @param password a character array representing the password.
             @return a byte array representing the password.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.Pkcs5PasswordToUtf8Bytes(System.Char[])">
             converts a password to a byte array according to the scheme in
             PKCS5 (UTF-8, no padding)
            
             @param password a character array representing the password.
             @return a byte array representing the password.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.PbeParametersGenerator.Pkcs12PasswordToBytes(System.Char[])">
             converts a password to a byte array according to the scheme in
             Pkcs12 (unicode, big endian, 2 zero pad bytes at the end).
            
             @param password a character array representing the password.
             @return a byte array representing the password.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.PbeParametersGenerator.IterationCount">
             return the iteration count.
            
             @return the iteration count.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Prng.CryptoApiRandomGenerator">
            <summary>
            Uses Microsoft's RNGCryptoServiceProvider
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Prng.IRandomGenerator">
            <remarks>Generic interface for objects generating random bytes.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.IRandomGenerator.AddSeedMaterial(System.Byte[])">
            <summary>Add more seed material to the generator.</summary>
            <param name="seed">A byte array to be mixed into the generator's state.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.IRandomGenerator.AddSeedMaterial(System.Int64)">
            <summary>Add more seed material to the generator.</summary>
            <param name="seed">A long value to be mixed into the generator's state.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.IRandomGenerator.NextBytes(System.Byte[])">
            <summary>Fill byte array with random values.</summary>
            <param name="bytes">Array to be filled.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Prng.IRandomGenerator.NextBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Fill byte array with random values.</summary>
            <param name="bytes">Array to receive bytes.</param>
            <param name="start">Index to start filling at.</param>
            <param name="len">Length of segment to fill.</param>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Prng.DigestRandomGenerator">
            Random generation based on the digest with counter. Calling AddSeedMaterial will
            always increase the entropy of the hash.
            <p>
            Internal access to the digest is synchronized so a single one of these can be shared.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.DsaDigestSigner.Update(System.Byte)">
            update the internal digest with the byte b
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.DsaDigestSigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            update the internal digest with the byte array in
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.DsaDigestSigner.GenerateSignature">
            Generate a signature for the message we've been loaded with using
            the key we were initialised with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.DsaDigestSigner.VerifySignature(System.Byte[])">
            <returns>true if the internal state represents the signature described in the passed in array.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.DsaDigestSigner.Reset">
            <summary>Reset the internal state</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.DsaSigner">
            The Digital Signature Algorithm - as described in "Handbook of Applied
            Cryptography", pages 452 - 453.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.DsaSigner.#ctor">
            Default configuration, random K values.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.DsaSigner.#ctor(Org.BouncyCastle.Crypto.Signers.IDsaKCalculator)">
             Configuration with an alternate, possibly deterministic calculator of K.
            
             @param kCalculator a K value calculator.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.DsaSigner.GenerateSignature(System.Byte[])">
             Generate a signature for the given message using the key we were
             initialised with. For conventional DSA the message should be a SHA-1
             hash of the message of interest.
            
             @param message the message that will be verified later.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.DsaSigner.VerifySignature(System.Byte[],Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            return true if the value r and s represent a DSA signature for
            the passed in message for standard DSA the message should be a
            SHA-1 hash of the real message to be verified.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.ECDsaSigner">
            EC-DSA as described in X9.62
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECDsaSigner.#ctor">
            Default configuration, random K values.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECDsaSigner.#ctor(Org.BouncyCastle.Crypto.Signers.IDsaKCalculator)">
             Configuration with an alternate, possibly deterministic calculator of K.
            
             @param kCalculator a K value calculator.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECDsaSigner.GenerateSignature(System.Byte[])">
             Generate a signature for the given message using the key we were
             initialised with. For conventional DSA the message should be a SHA-1
             hash of the message of interest.
            
             @param message the message that will be verified later.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECDsaSigner.VerifySignature(System.Byte[],Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            return true if the value r and s represent a DSA signature for
            the passed in message (for standard DSA the message should be
            a SHA-1 hash of the real message to be verified).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.ECGost3410Signer">
            GOST R 34.10-2001 Signature Algorithm
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECGost3410Signer.GenerateSignature(System.Byte[])">
             generate a signature for the given message using the key we were
             initialised with. For conventional GOST3410 the message should be a GOST3411
             hash of the message of interest.
            
             @param message the message that will be verified later.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECGost3410Signer.VerifySignature(System.Byte[],Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            return true if the value r and s represent a GOST3410 signature for
            the passed in message (for standard GOST3410 the message should be
            a GOST3411 hash of the real message to be verified).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.ECNRSigner">
            EC-NR as described in IEEE 1363-2000
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECNRSigner.GenerateSignature(System.Byte[])">
             generate a signature for the given message using the key we were
             initialised with.  Generally, the order of the curve should be at
             least as long as the hash of the message of interest, and with
             ECNR it *must* be at least as long.
            
             @param digest  the digest to be signed.
             @exception DataLengthException if the digest is longer than the key allows
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.ECNRSigner.VerifySignature(System.Byte[],Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
             return true if the value r and s represent a signature for the
             message passed in. Generally, the order of the curve should be at
             least as long as the hash of the message of interest, and with
             ECNR, it *must* be at least as long.  But just in case the signer
             applied mod(n) to the longer digest, this implementation will
             apply mod(n) during verification.
            
             @param digest  the digest to be verified.
             @param r       the r value of the signature.
             @param s       the s value of the signature.
             @exception DataLengthException if the digest is longer than the key allows
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.GenericSigner.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             initialise the signer for signing or verification.
            
             @param forSigning
                        true if for signing, false otherwise
             @param parameters
                        necessary parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.GenericSigner.Update(System.Byte)">
            update the internal digest with the byte b
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.GenericSigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            update the internal digest with the byte array in
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.GenericSigner.GenerateSignature">
            Generate a signature for the message we've been loaded with using the key
            we were initialised with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.GenericSigner.VerifySignature(System.Byte[])">
            return true if the internal state represents the signature described in
            the passed in array.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Gost3410DigestSigner.Update(System.Byte)">
            update the internal digest with the byte b
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Gost3410DigestSigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            update the internal digest with the byte array in
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Gost3410DigestSigner.GenerateSignature">
            Generate a signature for the message we've been loaded with using
            the key we were initialised with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Gost3410DigestSigner.VerifySignature(System.Byte[])">
            <returns>true if the internal state represents the signature described in the passed in array.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Gost3410DigestSigner.Reset">
            <summary>Reset the internal state</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.Gost3410Signer">
            Gost R 34.10-94 Signature Algorithm
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Gost3410Signer.GenerateSignature(System.Byte[])">
             generate a signature for the given message using the key we were
             initialised with. For conventional Gost3410 the message should be a Gost3411
             hash of the message of interest.
            
             @param message the message that will be verified later.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Gost3410Signer.VerifySignature(System.Byte[],Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            return true if the value r and s represent a Gost3410 signature for
            the passed in message for standard Gost3410 the message should be a
            Gost3411 hash of the real message to be verified.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.HMacDsaKCalculator">
            A deterministic K calculator based on the algorithm in section 3.2 of RFC 6979.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.IDsaKCalculator">
            Interface define calculators of K values for DSA/ECDSA.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.IDsaKCalculator.Init(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Security.SecureRandom)">
             Non-deterministic initialiser.
            
             @param n the order of the DSA group.
             @param random a source of randomness.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.IDsaKCalculator.Init(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,System.Byte[])">
             Deterministic initialiser.
            
             @param n the order of the DSA group.
             @param d the DSA private value.
             @param message the message being signed.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.IDsaKCalculator.NextK">
             Return the next valid value of K.
            
             @return a K value.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Signers.IDsaKCalculator.IsDeterministic">
             Return true if this calculator is deterministic, false otherwise.
            
             @return true if deterministic, otherwise false.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.HMacDsaKCalculator.#ctor(Org.BouncyCastle.Crypto.IDigest)">
             Base constructor.
            
             @param digest digest to build the HMAC on.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer">
            <summary> ISO9796-2 - mechanism using a hash function with recovery (scheme 1)</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.GetRecoveredMessage">
            <summary>
            Return a reference to the recoveredMessage message.
            </summary>
            <returns>The full/partial recoveredMessage message.</returns>
            <seealso cref="M:Org.BouncyCastle.Crypto.ISignerWithRecovery.GetRecoveredMessage"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Org.BouncyCastle.Crypto.IDigest,System.Boolean)">
            <summary>
            Generate a signer for the with either implicit or explicit trailers
            for ISO9796-2.
            </summary>
            <param name="cipher">base cipher to use for signature creation/verification</param>
            <param name="digest">digest to use.</param>
            <param name="isImplicit">whether or not the trailer is implicit or gives the hash.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Org.BouncyCastle.Crypto.IDigest)">
             <summary> Constructor for a signer with an explicit digest trailer.
            
             </summary>
             <param name="cipher">cipher to use.
             </param>
             <param name="digest">digest to sign with.
             </param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.IsSameAs(System.Byte[],System.Byte[])">
            <summary> compare two byte arrays - constant time.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.ClearBlock(System.Byte[])">
            <summary> clear possible sensitive data</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.Update(System.Byte)">
            <summary> update the internal digest with the byte b</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary> update the internal digest with the byte array in</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.Reset">
            <summary> reset the internal state</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.GenerateSignature">
            <summary> Generate a signature for the loaded message using the key we were
            initialised with.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.VerifySignature(System.Byte[])">
            <summary> return true if the signature represents a ISO9796-2 signature
            for the passed in message.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.Iso9796d2Signer.HasFullMessage">
            <summary>
            Return true if the full message was recoveredMessage.
            </summary>
            <returns> true on full message recovery, false otherwise.</returns>
            <seealso cref="M:Org.BouncyCastle.Crypto.ISignerWithRecovery.HasFullMessage"/>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.PssSigner">
            <summary> RSA-PSS as described in Pkcs# 1 v 2.1.
            <p>
            Note: the usual value for the salt length is the number of
            bytes in the hash function.</p>
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Org.BouncyCastle.Crypto.IDigest,System.Int32)">
            <summary>Basic constructor</summary>
            <param name="cipher">the asymmetric cipher to use.</param>
            <param name="digest">the digest to use.</param>
            <param name="saltLen">the length of the salt to use (in bytes).</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.ClearBlock(System.Byte[])">
            <summary> clear possible sensitive data</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.Update(System.Byte)">
            <summary> update the internal digest with the byte b</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary> update the internal digest with the byte array in</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.Reset">
            <summary> reset the internal state</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.GenerateSignature">
            <summary> Generate a signature for the message we've been loaded with using
            the key we were initialised with.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.VerifySignature(System.Byte[])">
            <summary> return true if the internal state represents the signature described
            in the passed in array.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.ItoOSP(System.Int32,System.Byte[])">
            <summary> int to octet string.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.PssSigner.MaskGeneratorFunction1(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary> mask generator function, as described in Pkcs1v2.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.RsaDigestSigner.#cctor">
            <summary>
            Load oid table.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.RsaDigestSigner.Init(System.Boolean,Org.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the signer for signing or verification.
            
             @param forSigning true if for signing, false otherwise
             @param param necessary parameters.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.RsaDigestSigner.Update(System.Byte)">
            update the internal digest with the byte b
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.RsaDigestSigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            update the internal digest with the byte array in
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.RsaDigestSigner.GenerateSignature">
            Generate a signature for the message we've been loaded with using
            the key we were initialised with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.RsaDigestSigner.VerifySignature(System.Byte[])">
            return true if the internal state represents the signature described
            in the passed in array.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Signers.X931Signer">
            X9.31-1998 - signing using a hash.
            <p>
            The message digest hash, H, is encapsulated to form a byte string as follows
            </p>
            <pre>
            EB = 06 || PS || 0xBA || H || TRAILER
            </pre>
            where PS is a string of bytes all of value 0xBB of length such that |EB|=|n|, and TRAILER is the ISO/IEC 10118 part number for the digest. The byte string, EB, is converted to an integer value, the message representative, f.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.X931Signer.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Org.BouncyCastle.Crypto.IDigest,System.Boolean)">
             Generate a signer for the with either implicit or explicit trailers
             for ISO9796-2.
            
             @param cipher base cipher to use for signature creation/verification
             @param digest digest to use.
             @param implicit whether or not the trailer is implicit or gives the hash.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.X931Signer.#ctor(Org.BouncyCastle.Crypto.IAsymmetricBlockCipher,Org.BouncyCastle.Crypto.IDigest)">
             Constructor for a signer with an explicit digest trailer.
            
             @param cipher cipher to use.
             @param digest digest to sign with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.X931Signer.ClearBlock(System.Byte[])">
            <summary> clear possible sensitive data</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.X931Signer.Update(System.Byte)">
            update the internal digest with the byte b
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.X931Signer.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            update the internal digest with the byte array in
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.X931Signer.Reset">
            reset the internal state
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.X931Signer.GenerateSignature">
            generate a signature for the loaded message using the key we were
            initialised with.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Signers.X931Signer.VerifySignature(System.Byte[])">
            return true if the signature represents a ISO9796-2 signature
            for the passed in message.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsAgreementCredentials.GenerateAgreement(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.AbstractTlsAgreementCredentials.GenerateAgreement(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsCipherFactory.CreateCipher(Org.BouncyCastle.Crypto.Tls.TlsContext,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.AbstractTlsCipherFactory.CreateCipher(Org.BouncyCastle.Crypto.Tls.TlsContext,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsPeer.ShouldUseGmtUnixTime">
            <summary>
            draft-mathewson-no-gmtunixtime-00 2. "If existing users of a TLS implementation may rely on
            gmt_unix_time containing the current time, we recommend that implementors MAY provide the
            ability to set gmt_unix_time as an option only, off by default."
            </summary>
            <returns>
            <code>true</code> if the current time should be used in the gmt_unix_time field of
            Random, or <code>false</code> if gmt_unix_time should contain a cryptographically
            random value.
            </returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsPeer.NotifySecureRenegotiation(System.Boolean)">
            <summary>
            Report whether the server supports secure renegotiation
            </summary>
            <remarks>
            The protocol handler automatically processes the relevant extensions
            </remarks>
            <param name="secureRenegotiation">
            A <see cref="T:System.Boolean"/>, true if the server supports secure renegotiation
            </param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsPeer.GetCompression">
            <summary>
            Return an implementation of <see cref="T:Org.BouncyCastle.Crypto.Tls.TlsCompression"/> to handle record compression.
            </summary>
            <returns>A <see cref="T:Org.BouncyCastle.Crypto.Tls.TlsCompression"/></returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsPeer.GetCipher">
            <summary>
            Return an implementation of <see cref="T:Org.BouncyCastle.Crypto.Tls.TlsCipher"/> to use for encryption/decryption.
            </summary>
            <returns>A <see cref="T:Org.BouncyCastle.Crypto.Tls.TlsCipher"/></returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsPeer.NotifyAlertRaised(System.Byte,System.Byte,System.String,System.Exception)">
            <summary>This method will be called when an alert is raised by the protocol.</summary>
            <param name="alertLevel"><see cref="T:Org.BouncyCastle.Crypto.Tls.AlertLevel"/></param>
            <param name="alertDescription"><see cref="T:Org.BouncyCastle.Crypto.Tls.AlertDescription"/></param>
            <param name="message">A human-readable message explaining what caused this alert. May be null.</param>
            <param name="cause">The <c>Exception</c> that caused this alert to be raised. May be null.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsPeer.NotifyAlertReceived(System.Byte,System.Byte)">
            <summary>This method will be called when an alert is received from the remote peer.</summary>
            <param name="alertLevel"><see cref="T:Org.BouncyCastle.Crypto.Tls.AlertLevel"/></param>
            <param name="alertDescription"><see cref="T:Org.BouncyCastle.Crypto.Tls.AlertDescription"/></param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsPeer.NotifyHandshakeComplete">
            <summary>Notifies the peer that the handshake has been successfully completed.</summary>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.Init(Org.BouncyCastle.Crypto.Tls.TlsClientContext)">
            <summary>
            Called at the start of a new TLS session, before any other methods.
            </summary>
            <param name="context">
            </param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetSessionToResume">
            <summary>Return the session this client wants to resume, if any.</summary>
            <remarks>Note that the peer's certificate chain for the session (if any) may need to be periodically revalidated.</remarks>
            <returns>
            A <see cref="T:Org.BouncyCastle.Crypto.Tls.TlsSession"/> representing the resumable session to be used for this connection,
            or null to use a new session.
            </returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetCipherSuites">
            <summary>
            Get the list of cipher suites that this client supports.
            </summary>
            <returns>
            An array of <see cref="T:Org.BouncyCastle.Crypto.Tls.CipherSuite"/> values, each specifying a supported cipher suite.
            </returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetCompressionMethods">
            <summary>
            Get the list of compression methods that this client supports.
            </summary>
            <returns>
            An array of <see cref="T:Org.BouncyCastle.Crypto.Tls.CompressionMethod"/> values, each specifying a supported compression method.
            </returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetClientExtensions">
            <summary>
            Get the (optional) table of client extensions to be included in (extended) client hello.
            </summary>
            <returns>
            A <see cref="T:System.Collections.IDictionary"/> (Int32 -&gt; byte[]). May be null.
            </returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.NotifyServerVersion(Org.BouncyCastle.Crypto.Tls.ProtocolVersion)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.NotifySessionID(System.Byte[])">
            <summary>
            Notifies the client of the session_id sent in the ServerHello.
            </summary>
            <param name="sessionID">An array of <see cref="T:System.Byte"/></param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.NotifySelectedCipherSuite(System.Int32)">
            <summary>
            Report the cipher suite that was selected by the server.
            </summary>
            <remarks>
            The protocol handler validates this value against the offered cipher suites
            <seealso cref="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetCipherSuites"/>
            </remarks>
            <param name="selectedCipherSuite">
            A <see cref="T:Org.BouncyCastle.Crypto.Tls.CipherSuite"/>
            </param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.NotifySelectedCompressionMethod(System.Byte)">
            <summary>
            Report the compression method that was selected by the server.
            </summary>
            <remarks>
            The protocol handler validates this value against the offered compression methods
            <seealso cref="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetCompressionMethods"/>
            </remarks>
            <param name="selectedCompressionMethod">
            A <see cref="T:Org.BouncyCastle.Crypto.Tls.CompressionMethod"/>
            </param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.ProcessServerExtensions(System.Collections.IDictionary)">
            <summary>
            Report the extensions from an extended server hello.
            </summary>
            <remarks>
            Will only be called if we returned a non-null result from <see cref="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetClientExtensions"/>.
            </remarks>
            <param name="serverExtensions">
            A <see cref="T:System.Collections.IDictionary"/>  (Int32 -&gt; byte[])
            </param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.ProcessServerSupplementalData(System.Collections.IList)">
            <param name="serverSupplementalData">A <see cref="T:System.Collections.IList">list</see> of <see cref="T:Org.BouncyCastle.Crypto.Tls.SupplementalDataEntry"/></param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetKeyExchange">
            <summary>
            Return an implementation of <see cref="T:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange"/> to negotiate the key exchange
            part of the protocol.
            </summary>
            <returns>
            A <see cref="T:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange"/>
            </returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetAuthentication">
            <summary>
            Return an implementation of <see cref="T:Org.BouncyCastle.Crypto.Tls.TlsAuthentication"/> to handle authentication
            part of the protocol.
            </summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.GetClientSupplementalData">
            <returns>A <see cref="T:System.Collections.IList">list</see> of <see cref="T:Org.BouncyCastle.Crypto.Tls.SupplementalDataEntry"/></returns>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClient.NotifyNewSessionTicket(Org.BouncyCastle.Crypto.Tls.NewSessionTicket)">
            <summary>RFC 5077 3.3. NewSessionTicket Handshake Message</summary>
            <remarks>
            This method will be called (only) when a NewSessionTicket handshake message is received. The
            ticket is opaque to the client and clients MUST NOT examine the ticket under the assumption
            that it complies with e.g. <i>RFC 5077 4. Recommended Ticket Construction</i>.
            </remarks>
            <param name="newSessionTicket">The <see cref="T:Org.BouncyCastle.Crypto.Tls.NewSessionTicket">ticket</see></param>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.AbstractTlsClient.ClientHelloRecordLayerVersion">
            RFC 5246 E.1. "TLS clients that wish to negotiate with older servers MAY send any value
            {03,XX} as the record layer version number. Typical values would be {03,00}, the lowest
            version number supported by the client, and the value of ClientHello.client_version. No
            single value will guarantee interoperability with all old servers, but this is a complex
            topic beyond the scope of this document."
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsContext.ExportKeyingMaterial(System.String,System.Byte[],System.Int32)">
             Export keying material according to RFC 5705: "Keying Material Exporters for TLS".
            
             @param asciiLabel    indicates which application will use the exported keys.
             @param context_value allows the application using the exporter to mix its own data with the TLS PRF for
                                  the exporter output.
             @param length        the number of bytes to generate
             @return a pseudorandom bit string of 'length' bytes generated from the master_secret.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.TlsContext.ResumableSession">
            Used to get the resumable session, if any, used by this connection. Only available after the
            handshake has successfully completed.
            
            @return A {@link TlsSession} representing the resumable session used by this connection, or
                    null if no resumable session available.
            @see TlsPeer#NotifyHandshakeComplete()
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsEncryptionCredentials.DecryptPreMasterSecret(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.AbstractTlsEncryptionCredentials.DecryptPreMasterSecret(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange">
            <summary>
            A generic interface for key exchange implementations in (D)TLS.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.SkipServerCredentials">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.ProcessServerCredentials(Org.BouncyCastle.Crypto.Tls.TlsCredentials)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.ProcessServerCertificate(Org.BouncyCastle.Crypto.Tls.Certificate)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.GenerateServerKeyExchange">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.SkipServerKeyExchange">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.ProcessServerKeyExchange(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.ValidateCertificateRequest(Org.BouncyCastle.Crypto.Tls.CertificateRequest)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.SkipClientCredentials">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.ProcessClientCredentials(Org.BouncyCastle.Crypto.Tls.TlsCredentials)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.ProcessClientCertificate(Org.BouncyCastle.Crypto.Tls.Certificate)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.GenerateClientKeyExchange(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.ProcessClientKeyExchange(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsKeyExchange.GeneratePremasterSecret">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.NotifyClientVersion(Org.BouncyCastle.Crypto.Tls.ProtocolVersion)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.NotifyFallback(System.Boolean)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.NotifyOfferedCipherSuites(System.Int32[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.NotifyOfferedCompressionMethods(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.ProcessClientExtensions(System.Collections.IDictionary)">
            <param name="clientExtensions">A <see cref="T:System.Collections.IDictionary"/> (Int32 -&gt; byte[]). Will never be null.</param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.GetServerVersion">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.GetSelectedCipherSuite">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.GetSelectedCompressionMethod">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.GetServerExtensions">
            <summary>
            Get the (optional) table of server extensions to be included in (extended) server hello.
            </summary>
            <returns>
            A <see cref="T:System.Collections.IDictionary"/> (Int32 -&gt; byte[]). May be null.
            </returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.GetServerSupplementalData">
            <returns>
            A <see cref="T:System.Collections.IList"/> (<see cref="T:Org.BouncyCastle.Crypto.Tls.SupplementalDataEntry"/>). May be null.
            </returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.GetCredentials">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.GetCertificateStatus">
            <remarks>
            This method will be called (only) if the server included an extension of type
            "status_request" with empty "extension_data" in the extended server hello. See <i>RFC 3546
            3.6. Certificate Status Request</i>. If a non-null <see cref="T:Org.BouncyCastle.Crypto.Tls.CertificateStatus"/> is returned, it
            is sent to the client as a handshake message of type "certificate_status".
            </remarks>
            <returns>A <see cref="T:Org.BouncyCastle.Crypto.Tls.CertificateStatus"/> to be sent to the client (or null for none).</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.GetKeyExchange">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.GetCertificateRequest">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.ProcessClientSupplementalData(System.Collections.IList)">
            <param name="clientSupplementalData"><see cref="T:System.Collections.IList"/> (<see cref="T:Org.BouncyCastle.Crypto.Tls.SupplementalDataEntry"/>)</param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.NotifyClientCertificate(Org.BouncyCastle.Crypto.Tls.Certificate)">
            <summary>
            Called by the protocol handler to report the client certificate, only if <c>GetCertificateRequest</c>
            returned non-null.
            </summary>
            <remarks>Note: this method is responsible for certificate verification and validation.</remarks>
            <param name="clientCertificate">the effective client certificate (may be an empty chain).</param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsServer.GetNewSessionTicket">
            <summary>RFC 5077 3.3. NewSessionTicket Handshake Message.</summary>
            <remarks>
            This method will be called (only) if a NewSessionTicket extension was sent by the server. See
            <i>RFC 5077 4. Recommended Ticket Construction</i> for recommended format and protection.
            </remarks>
            <returns>The <see cref="T:Org.BouncyCastle.Crypto.Tls.NewSessionTicket">ticket</see>)</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsSignerCredentials.GenerateCertificateSignature(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.AbstractTlsSignerCredentials.GenerateCertificateSignature(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.AlertDescription">
            <summary>
            RFC 5246 7.2
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.close_notify">
            This message notifies the recipient that the sender will not send any more messages on this
            connection. Note that as of TLS 1.1, failure to properly close a connection no longer
            requires that a session not be resumed. This is a change from TLS 1.0 ("The session becomes
            unresumable if any connection is terminated without proper close_notify messages with level
            equal to warning.") to conform with widespread implementation practice.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.unexpected_message">
            An inappropriate message was received. This alert is always fatal and should never be
            observed in communication between proper implementations.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.bad_record_mac">
            This alert is returned if a record is received with an incorrect MAC. This alert also MUST be
            returned if an alert is sent because a TLSCiphertext decrypted in an invalid way: either it
            wasn't an even multiple of the block length, or its padding values, when checked, weren't
            correct. This message is always fatal and should never be observed in communication between
            proper implementations (except when messages were corrupted in the network).
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.decryption_failed">
            This alert was used in some earlier versions of TLS, and may have permitted certain attacks
            against the CBC mode [CBCATT]. It MUST NOT be sent by compliant implementations.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.record_overflow">
            A TLSCiphertext record was received that had a length more than 2^14+2048 bytes, or a record
            decrypted to a TLSCompressed record with more than 2^14+1024 bytes. This message is always
            fatal and should never be observed in communication between proper implementations (except
            when messages were corrupted in the network).
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.decompression_failure">
            The decompression function received improper input (e.g., data that would expand to excessive
            length). This message is always fatal and should never be observed in communication between
            proper implementations.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.handshake_failure">
            Reception of a handshake_failure alert message indicates that the sender was unable to
            negotiate an acceptable set of security parameters given the options available. This is a
            fatal error.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.no_certificate">
            This alert was used in SSLv3 but not any version of TLS. It MUST NOT be sent by compliant
            implementations.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.bad_certificate">
            A certificate was corrupt, contained signatures that did not verify correctly, etc.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.unsupported_certificate">
            A certificate was of an unsupported type.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.certificate_revoked">
            A certificate was revoked by its signer.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.certificate_expired">
            A certificate has expired or is not currently valid.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.certificate_unknown">
            Some other (unspecified) issue arose in processing the certificate, rendering it
            unacceptable.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.illegal_parameter">
            A field in the handshake was out of range or inconsistent with other fields. This message is
            always fatal.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.unknown_ca">
            A valid certificate chain or partial chain was received, but the certificate was not accepted
            because the CA certificate could not be located or couldn't be matched with a known, trusted
            CA. This message is always fatal.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.access_denied">
            A valid certificate was received, but when access control was applied, the sender decided not
            to proceed with negotiation. This message is always fatal.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.decode_error">
            A message could not be decoded because some field was out of the specified range or the
            length of the message was incorrect. This message is always fatal and should never be
            observed in communication between proper implementations (except when messages were corrupted
            in the network).
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.decrypt_error">
            A handshake cryptographic operation failed, including being unable to correctly verify a
            signature or validate a Finished message. This message is always fatal.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.export_restriction">
            This alert was used in some earlier versions of TLS. It MUST NOT be sent by compliant
            implementations.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.protocol_version">
            The protocol version the client has attempted to negotiate is recognized but not supported.
            (For example, old protocol versions might be avoided for security reasons.) This message is
            always fatal.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.insufficient_security">
            Returned instead of handshake_failure when a negotiation has failed specifically because the
            server requires ciphers more secure than those supported by the client. This message is
            always fatal.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.internal_error">
            An internal error unrelated to the peer or the correctness of the protocol (such as a memory
            allocation failure) makes it impossible to continue. This message is always fatal.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.user_canceled">
            This handshake is being canceled for some reason unrelated to a protocol failure. If the user
            cancels an operation after the handshake is complete, just closing the connection by sending
            a close_notify is more appropriate. This alert should be followed by a close_notify. This
            message is generally a warning.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.no_renegotiation">
            Sent by the client in response to a hello request or by the server in response to a client
            hello after initial handshaking. Either of these would normally lead to renegotiation; when
            that is not appropriate, the recipient should respond with this alert. At that point, the
            original requester can decide whether to proceed with the connection. One case where this
            would be appropriate is where a server has spawned a process to satisfy a request; the
            process might receive security parameters (key length, authentication, etc.) at startup, and
            it might be difficult to communicate changes to these parameters after that point. This
            message is always a warning.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.unsupported_extension">
            Sent by clients that receive an extended server hello containing an extension that they did
            not put in the corresponding client hello. This message is always fatal.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.certificate_unobtainable">
            This alert is sent by servers who are unable to retrieve a certificate chain from the URL
            supplied by the client (see Section 3.3). This message MAY be fatal - for example if client
            authentication is required by the server for the handshake to continue and the server is
            unable to retrieve the certificate chain, it may send a fatal alert.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.unrecognized_name">
            This alert is sent by servers that receive a server_name extension request, but do not
            recognize the server name. This message MAY be fatal.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.bad_certificate_status_response">
            This alert is sent by clients that receive an invalid certificate status response (see
            Section 3.6). This message is always fatal.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.bad_certificate_hash_value">
            This alert is sent by servers when a certificate hash does not match a client provided
            certificate_hash. This message is always fatal.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.unknown_psk_identity">
            If the server does not recognize the PSK identity, it MAY respond with an
            "unknown_psk_identity" alert message.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.AlertDescription.inappropriate_fallback">
            If TLS_FALLBACK_SCSV appears in ClientHello.cipher_suites and the highest protocol version
            supported by the server is higher than the version indicated in ClientHello.client_version,
            the server MUST respond with an inappropriate_fallback alert.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.AlertLevel">
            <summary>
            RFC 5246 7.2
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.AlwaysValidVerifyer">
            <remarks>
            A certificate verifyer, that will always return true.
            <pre>
            DO NOT USE THIS FILE UNLESS YOU KNOW EXACTLY WHAT YOU ARE DOING.
            </pre>
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.ICertificateVerifyer">
            <remarks>
            This should be implemented by any class which can find out, if a given
            certificate chain is being accepted by an client.
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ICertificateVerifyer.IsValid(System.Uri,Org.BouncyCastle.Asn1.X509.X509CertificateStructure[])">
            <param name="certs">The certs, which are part of the chain.</param>
            <param name="targetUri"></param>
            <returns>True, if the chain is accepted, false otherwise</returns>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.AlwaysValidVerifyer.IsValid(System.Uri,Org.BouncyCastle.Asn1.X509.X509CertificateStructure[])">
            <summary>Return true.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.ByteQueue">
            <remarks>
            A queue for bytes.
            <p>
            This file could be more optimized.
            </p>
            </remarks>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.ByteQueue.DefaultCapacity">
            The initial size for our buffer.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ByteQueue.NextTwoPow(System.Int32)">
            <returns>The smallest number which can be written as 2^x which is bigger than i.</returns>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.ByteQueue.databuf">
            The buffer where we store our data.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.ByteQueue.skipped">
            How many bytes at the beginning of the buffer are skipped.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.ByteQueue.available">
            How many bytes in the buffer are valid data.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ByteQueue.Read(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>Read data from the buffer.</summary>
            <param name="buf">The buffer where the read data will be copied to.</param>
            <param name="offset">How many bytes to skip at the beginning of buf.</param>
            <param name="len">How many bytes to read at all.</param>
            <param name="skip">How many bytes from our data to skip.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ByteQueue.AddData(System.Byte[],System.Int32,System.Int32)">
            <summary>Add some data to our buffer.</summary>
            <param name="data">A byte-array to read data from.</param>
            <param name="offset">How many bytes to skip at the beginning of the array.</param>
            <param name="len">How many bytes to read from the array.</param>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ByteQueue.RemoveData(System.Int32)">
            <summary>Remove some bytes from our data from the beginning.</summary>
            <param name="i">How many bytes to remove.</param>
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.ByteQueue.Available">
            <summary>The number of bytes which are available in this buffer.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.Certificate">
             Parsing and encoding of a <i>Certificate</i> struct from RFC 4346.
             <p/>
             <pre>
             opaque ASN.1Cert&lt;2^24-1&gt;;
            
             struct {
                 ASN.1Cert certificate_list&lt;0..2^24-1&gt;;
             } Certificate;
             </pre>
            
             @see Org.BouncyCastle.Asn1.X509.X509CertificateStructure
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.Certificate.mCertificateList">
            The certificates.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.Certificate.GetCertificateList">
            @return an array of {@link org.bouncycastle.asn1.x509.Certificate} representing a certificate
                    chain.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.Certificate.Encode(System.IO.Stream)">
             Encode this {@link Certificate} to a {@link Stream}.
            
             @param output the {@link Stream} to encode to.
             @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.Certificate.Parse(System.IO.Stream)">
             Parse a {@link Certificate} from a {@link Stream}.
            
             @param input the {@link Stream} to parse from.
             @return a {@link Certificate} object.
             @throws IOException
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.Certificate.IsEmpty">
            @return <code>true</code> if this certificate chain contains no certificates, or
                    <code>false</code> otherwise.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.CertificateRequest">
             Parsing and encoding of a <i>CertificateRequest</i> struct from RFC 4346.
             <p/>
             <pre>
             struct {
                 ClientCertificateType certificate_types&lt;1..2^8-1&gt;;
                 DistinguishedName certificate_authorities&lt;3..2^16-1&gt;
             } CertificateRequest;
             </pre>
            
             @see ClientCertificateType
             @see X509Name
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.CertificateRequest.#ctor(System.Byte[],System.Collections.IList,System.Collections.IList)">
            @param certificateTypes       see {@link ClientCertificateType} for valid constants.
            @param certificateAuthorities an {@link IList} of {@link X509Name}.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.CertificateRequest.Encode(System.IO.Stream)">
             Encode this {@link CertificateRequest} to a {@link Stream}.
            
             @param output the {@link Stream} to encode to.
             @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.CertificateRequest.Parse(Org.BouncyCastle.Crypto.Tls.TlsContext,System.IO.Stream)">
            Parse a {@link CertificateRequest} from a {@link Stream}.
            
            @param context
                       the {@link TlsContext} of the current connection.
            @param input
                       the {@link Stream} to parse from.
            @return a {@link CertificateRequest} object.
            @throws IOException
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.CertificateRequest.CertificateTypes">
            @return an array of certificate types
            @see {@link ClientCertificateType}
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.CertificateRequest.SupportedSignatureAlgorithms">
            @return an {@link IList} of {@link SignatureAndHashAlgorithm} (or null before TLS 1.2).
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.CertificateRequest.CertificateAuthorities">
            @return an {@link IList} of {@link X509Name}
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.CertificateStatus.Encode(System.IO.Stream)">
            Encode this {@link CertificateStatus} to a {@link Stream}.
            
            @param output
                       the {@link Stream} to encode to.
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.CertificateStatus.Parse(System.IO.Stream)">
            Parse a {@link CertificateStatus} from a {@link Stream}.
            
            @param input
                       the {@link Stream} to parse from.
            @return a {@link CertificateStatus} object.
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.CertificateStatusRequest.Encode(System.IO.Stream)">
            Encode this {@link CertificateStatusRequest} to a {@link Stream}.
            
            @param output
                       the {@link Stream} to encode to.
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.CertificateStatusRequest.Parse(System.IO.Stream)">
            Parse a {@link CertificateStatusRequest} from a {@link Stream}.
            
            @param input
                       the {@link Stream} to parse from.
            @return a {@link CertificateStatusRequest} object.
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsCipher.EncodePlaintext(System.Int64,System.Byte,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsCipher.DecodeCiphertext(System.Int64,System.Byte,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.Chacha20Poly1305.#ctor(Org.BouncyCastle.Crypto.Tls.TlsContext)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.Chacha20Poly1305.EncodePlaintext(System.Int64,System.Byte,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.Chacha20Poly1305.DecodeCiphertext(System.Int64,System.Byte,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.Chacha20Poly1305.GetAdditionalData(System.Int64,System.Byte,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.CipherSuite">
            <summary>
            RFC 2246 A.5
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.CipherType">
            <summary>RFC 2246</summary>
            <remarks>
            Note that the values here are implementation-specific and arbitrary. It is recommended not to
            depend on the particular values (e.g. serialization).
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.CombinedHash">
            A combined hash, which implements md5(m) || sha1(m).
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.CombinedHash.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            @see org.bouncycastle.crypto.Digest#update(byte[], int, int)
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.CombinedHash.DoFinal(System.Byte[],System.Int32)">
            @see org.bouncycastle.crypto.Digest#doFinal(byte[], int)
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.CombinedHash.Reset">
            @see org.bouncycastle.crypto.Digest#reset()
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.CompressionMethod">
            <summary>
            RFC 2246 6.1
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.ConnectionEnd">
            <summary>RFC 2246</summary>
            <remarks>
            Note that the values here are implementation-specific and arbitrary. It is recommended not to
            depend on the particular values (e.g. serialization).
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.ContentType">
            RFC 2246 6.2.1
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DatagramTransport.GetReceiveLimit">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DatagramTransport.GetSendLimit">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DatagramTransport.Receive(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DatagramTransport.Send(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DatagramTransport.Close">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateCipher(Org.BouncyCastle.Crypto.Tls.TlsContext,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateAESCipher(Org.BouncyCastle.Crypto.Tls.TlsContext,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateCamelliaCipher(Org.BouncyCastle.Crypto.Tls.TlsContext,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateChaCha20Poly1305(Org.BouncyCastle.Crypto.Tls.TlsContext)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateCipher_Aes_Ccm(Org.BouncyCastle.Crypto.Tls.TlsContext,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateCipher_Aes_Gcm(Org.BouncyCastle.Crypto.Tls.TlsContext,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateCipher_Camellia_Gcm(Org.BouncyCastle.Crypto.Tls.TlsContext,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateDesEdeCipher(Org.BouncyCastle.Crypto.Tls.TlsContext,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateNullCipher(Org.BouncyCastle.Crypto.Tls.TlsContext,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateRC4Cipher(Org.BouncyCastle.Crypto.Tls.TlsContext,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateSalsa20Cipher(Org.BouncyCastle.Crypto.Tls.TlsContext,System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateSeedCipher(Org.BouncyCastle.Crypto.Tls.TlsContext,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DefaultTlsCipherFactory.CreateHMacDigest(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.DeferredHash">
            Buffers input until the hash algorithm is determined.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DigitallySigned.Encode(System.IO.Stream)">
            Encode this {@link DigitallySigned} to a {@link Stream}.
            
            @param output
                       the {@link Stream} to encode to.
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.DigitallySigned.Parse(Org.BouncyCastle.Crypto.Tls.TlsContext,System.IO.Stream)">
            Parse a {@link DigitallySigned} from a {@link Stream}.
            
            @param context
                       the {@link TlsContext} of the current connection.
            @param input
                       the {@link Stream} to parse from.
            @return a {@link DigitallySigned} object.
            @throws IOException
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.DigitallySigned.Algorithm">
            @return a {@link SignatureAndHashAlgorithm} (or null before TLS 1.2).
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.ECBasisType">
            <summary>RFC 4492 5.4. (Errata ID: 2389)</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.ECCurveType">
            <summary>
            RFC 4492 5.4
            </summary>
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.ECCurveType.explicit_prime">
            Indicates the elliptic curve domain parameters are conveyed verbosely, and the
            underlying finite field is a prime field.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.ECCurveType.explicit_char2">
            Indicates the elliptic curve domain parameters are conveyed verbosely, and the
            underlying finite field is a characteristic-2 field.
        </member>
        <member name="F:Org.BouncyCastle.Crypto.Tls.ECCurveType.named_curve">
            Indicates that a named curve is used. This option SHOULD be used when applicable.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.ECPointFormat">
            <summary>
            RFC 4492 5.1.2
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.EncryptionAlgorithm">
            <summary>RFC 2246</summary>
            <remarks>
            Note that the values here are implementation-specific and arbitrary. It is recommended not to
            depend on the particular values (e.g. serialization).
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.ExporterLabel">
            <summary>RFC 5705</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.HashAlgorithm">
            <summary>RFC 5246 7.4.1.4.1</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.HeartbeatExtension.Encode(System.IO.Stream)">
            Encode this {@link HeartbeatExtension} to a {@link Stream}.
            
            @param output
                       the {@link Stream} to encode to.
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.HeartbeatExtension.Parse(System.IO.Stream)">
            Parse a {@link HeartbeatExtension} from a {@link Stream}.
            
            @param input
                       the {@link Stream} to parse from.
            @return a {@link HeartbeatExtension} object.
            @throws IOException
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.KeyExchangeAlgorithm">
            <summary>RFC 2246</summary>
            <remarks>
            Note that the values here are implementation-specific and arbitrary. It is recommended not to
            depend on the particular values (e.g. serialization).
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.LegacyTlsAuthentication">
            <summary>
            A temporary class to wrap old CertificateVerifyer stuff for new TlsAuthentication.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsAuthentication.NotifyServerCertificate(Org.BouncyCastle.Crypto.Tls.Certificate)">
            <summary>
            Called by the protocol handler to report the server certificate.
            </summary>
            <remarks>
            This method is responsible for certificate verification and validation
            </remarks>
            <param name="serverCertificate">The server <see cref="T:Org.BouncyCastle.Crypto.Tls.Certificate"/> received</param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsAuthentication.GetClientCredentials(Org.BouncyCastle.Crypto.Tls.CertificateRequest)">
            <summary>
            Return client credentials in response to server's certificate request
            </summary>
            <param name="certificateRequest">
            A <see cref="T:Org.BouncyCastle.Crypto.Tls.CertificateRequest"/> containing server certificate request details
            </param>
            <returns>
            A <see cref="T:Org.BouncyCastle.Crypto.Tls.TlsCredentials"/> to be used for client authentication
            (or <c>null</c> for no client authentication)
            </returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.LegacyTlsClient">
            <summary>
            A temporary class to use LegacyTlsAuthentication 
            </summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.MacAlgorithm">
            <summary>RFC 2246</summary>
            <remarks>
            Note that the values here are implementation-specific and arbitrary. It is recommended not to
            depend on the particular values (e.g. serialization).
            </remarks>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.NamedCurve">
            <summary>
            RFC 4492 5.1.1
            The named curves defined here are those specified in SEC 2 [13]. Note that many of
            these curves are also recommended in ANSI X9.62 [7] and FIPS 186-2 [11]. Values 0xFE00
            through 0xFEFF are reserved for private use. Values 0xFF01 and 0xFF02 indicate that the
            client supports arbitrary prime and characteristic-2 curves, respectively (the curve
            parameters must be encoded explicitly in ECParameters).
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.NewSessionTicket.Encode(System.IO.Stream)">
             Encode this {@link NewSessionTicket} to a {@link Stream}.
            
             @param output the {@link Stream} to encode to.
             @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.NewSessionTicket.Parse(System.IO.Stream)">
             Parse a {@link NewSessionTicket} from a {@link Stream}.
            
             @param input the {@link Stream} to parse from.
             @return a {@link NewSessionTicket} object.
             @throws IOException
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.OcspStatusRequest">
            RFC 3546 3.6
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.OcspStatusRequest.#ctor(System.Collections.IList,Org.BouncyCastle.Asn1.X509.X509Extensions)">
            @param responderIDList
                       an {@link IList} of {@link ResponderID}, specifying the list of trusted OCSP
                       responders. An empty list has the special meaning that the responders are
                       implicitly known to the server - e.g., by prior arrangement.
            @param requestExtensions
                       OCSP request extensions. A null value means that there are no extensions.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.OcspStatusRequest.Encode(System.IO.Stream)">
            Encode this {@link OcspStatusRequest} to a {@link Stream}.
            
            @param output
                       the {@link Stream} to encode to.
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.OcspStatusRequest.Parse(System.IO.Stream)">
            Parse a {@link OcspStatusRequest} from a {@link Stream}.
            
            @param input
                       the {@link Stream} to parse from.
            @return an {@link OcspStatusRequest} object.
            @throws IOException
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.OcspStatusRequest.ResponderIDList">
            @return an {@link IList} of {@link ResponderID}
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.OcspStatusRequest.RequestExtensions">
            @return OCSP request extensions
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.PrfAlgorithm">
            <summary>RFC 5246</summary>
            <remarks>
            Note that the values here are implementation-specific and arbitrary. It is recommended not to
            depend on the particular values (e.g. serialization).
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ProtocolVersion.Get(System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.RecordStream">
            <summary>An implementation of the TLS 1.0/1.1/1.2 record layer, allowing downgrade to SSLv3.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.RecordStream.SetRestrictReadVersion(System.Boolean)">
            RFC 5246 E.1. "Earlier versions of the TLS specification were not fully clear on what the
            record layer version number (TLSPlaintext.version) should contain when sending ClientHello
            (i.e., before it is known which version of the protocol will be employed). Thus, TLS servers
            compliant with this specification MUST accept any value {03,XX} as the record layer version
            number for ClientHello."
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.SecurityParameters.Entity">
            @return {@link ConnectionEnd}
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.SecurityParameters.CipherSuite">
            @return {@link CipherSuite}
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.SecurityParameters.CompressionAlgorithm">
            @return {@link CompressionMethod}
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.SecurityParameters.PrfAlgorithm">
            @return {@link PRFAlgorithm}
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ServerDHParams.Encode(System.IO.Stream)">
            Encode this {@link ServerDHParams} to a {@link Stream}.
            
            @param output
                       the {@link Stream} to encode to.
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ServerDHParams.Parse(System.IO.Stream)">
            Parse a {@link ServerDHParams} from a {@link Stream}.
            
            @param input
                       the {@link Stream} to parse from.
            @return a {@link ServerDHParams} object.
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ServerName.Encode(System.IO.Stream)">
            Encode this {@link ServerName} to a {@link Stream}.
            
            @param output
                       the {@link Stream} to encode to.
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ServerName.Parse(System.IO.Stream)">
            Parse a {@link ServerName} from a {@link Stream}.
            
            @param input
                       the {@link Stream} to parse from.
            @return a {@link ServerName} object.
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ServerNameList.#ctor(System.Collections.IList)">
            @param serverNameList an {@link IList} of {@link ServerName}.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ServerNameList.Encode(System.IO.Stream)">
            Encode this {@link ServerNameList} to a {@link Stream}.
            
            @param output
                       the {@link Stream} to encode to.
            @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.ServerNameList.Parse(System.IO.Stream)">
            Parse a {@link ServerNameList} from a {@link Stream}.
            
            @param input
                       the {@link Stream} to parse from.
            @return a {@link ServerNameList} object.
            @throws IOException
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.ServerNameList.ServerNames">
            @return an {@link IList} of {@link ServerName}.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.SignatureAlgorithm">
            RFC 5246 7.4.1.4.1 (in RFC 2246, there were no specific values assigned)
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.SignatureAndHashAlgorithm">
            RFC 5246 7.4.1.4.1
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.SignatureAndHashAlgorithm.#ctor(System.Byte,System.Byte)">
            @param hash      {@link HashAlgorithm}
            @param signature {@link SignatureAlgorithm}
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.SignatureAndHashAlgorithm.Encode(System.IO.Stream)">
             Encode this {@link SignatureAndHashAlgorithm} to a {@link Stream}.
            
             @param output the {@link Stream} to encode to.
             @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.SignatureAndHashAlgorithm.Parse(System.IO.Stream)">
             Parse a {@link SignatureAndHashAlgorithm} from a {@link Stream}.
            
             @param input the {@link Stream} to parse from.
             @return a {@link SignatureAndHashAlgorithm} object.
             @throws IOException
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.SignatureAndHashAlgorithm.Hash">
            @return {@link HashAlgorithm}
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.SignatureAndHashAlgorithm.Signature">
            @return {@link SignatureAlgorithm}
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.Ssl3Mac">
            HMAC implementation based on original internet draft for HMAC (RFC 2104)
            
            The difference is that padding is concatentated versus XORed with the key
            
            H(K + opad, H(K + ipad, text))
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.Ssl3Mac.#ctor(Org.BouncyCastle.Crypto.IDigest)">
            Base constructor for one of the standard digest algorithms that the byteLength of
            the algorithm is know for. Behaviour is undefined for digests other than MD5 or SHA1.
            
            @param digest the digest.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.Ssl3Mac.Reset">
            Reset the mac generator.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsAeadCipher.#ctor(Org.BouncyCastle.Crypto.Tls.TlsContext,Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher,Org.BouncyCastle.Crypto.Modes.IAeadBlockCipher,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsAeadCipher.EncodePlaintext(System.Int64,System.Byte,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsAeadCipher.DecodeCiphertext(System.Int64,System.Byte,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsAeadCipher.GetAdditionalData(System.Int64,System.Byte,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsBlockCipher">
            <summary>
            A generic TLS 1.0-1.2 / SSLv3 block cipher. This can be used for AES or 3DES for example.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsBlockCipher.#ctor(Org.BouncyCastle.Crypto.Tls.TlsContext,Org.BouncyCastle.Crypto.IBlockCipher,Org.BouncyCastle.Crypto.IBlockCipher,Org.BouncyCastle.Crypto.IDigest,Org.BouncyCastle.Crypto.IDigest,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsBlockCipher.DecodeCiphertext(System.Int64,System.Byte,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocol.ProcessChangeCipherSpec(System.Byte[],System.Int32,System.Int32)">
             This method is called, when a change cipher spec message is received.
            
             @throws IOException If the message has an invalid content or the handshake is not in the correct
             state.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocol.ReadApplicationData(System.Byte[],System.Int32,System.Int32)">
             Read data from the network. The method will return immediately, if there is still some data
             left in the buffer, or block until some application data has been read from the network.
            
             @param buf    The buffer where the data will be copied to.
             @param offset The position where the data will be placed in the buffer.
             @param len    The maximum number of bytes to read.
             @return The number of bytes read.
             @throws IOException If something goes wrong during reading data.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocol.WriteData(System.Byte[],System.Int32,System.Int32)">
             Send some application data to the remote system.
             <p/>
             The method will handle fragmentation internally.
            
             @param buf    The buffer with the data.
             @param offset The position in the buffer where the data is placed.
             @param len    The length of the data.
             @throws IOException If something goes wrong during sending.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocol.FailWithError(System.Byte,System.Byte,System.String,System.Exception)">
            Terminate this connection with an alert. Can be used for normal closure too.
            
            @param alertLevel
                       See {@link AlertLevel} for values.
            @param alertDescription
                       See {@link AlertDescription} for values.
            @throws IOException
                        If alert was fatal.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocol.Close">
             Closes this connection.
            
             @throws IOException If something goes wrong during closing.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocol.AssertEmpty(System.IO.MemoryStream)">
             Make sure the InputStream 'buf' now empty. Fail otherwise.
            
             @param buf The InputStream to check.
             @throws IOException If 'buf' is not empty.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsProtocol.GetCurrentPrfHash(Org.BouncyCastle.Crypto.Tls.TlsContext,Org.BouncyCastle.Crypto.Tls.TlsHandshakeHash,System.Byte[])">
            'sender' only relevant to SSLv3
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.TlsProtocol.Stream">
            <summary>The secure bidirectional stream for this connection</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsClientProtocol.Connect(Org.BouncyCastle.Crypto.Tls.TlsClient)">
             Initiates a TLS handshake in the role of client
            
             @param tlsClient The {@link TlsClient} to use for the handshake.
             @throws IOException If handshake was not successful.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsDHKeyExchange">
            <summary>(D)TLS DH key exchange.</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsECDheKeyExchange">
            <summary>(D)TLS ECDHE key exchange (see RFC 4492).</summary>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsECDHKeyExchange">
            <summary>(D)TLS ECDH key exchange (see RFC 4492).</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.AddHeartbeatExtension(System.Collections.IDictionary,Org.BouncyCastle.Crypto.Tls.HeartbeatExtension)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.AddMaxFragmentLengthExtension(System.Collections.IDictionary,System.Byte)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.AddServerNameExtension(System.Collections.IDictionary,Org.BouncyCastle.Crypto.Tls.ServerNameList)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.AddStatusRequestExtension(System.Collections.IDictionary,Org.BouncyCastle.Crypto.Tls.CertificateStatusRequest)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.GetHeartbeatExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.GetMaxFragmentLengthExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.GetServerNameExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.GetStatusRequestExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.HasEncryptThenMacExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.HasExtendedMasterSecretExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.HasTruncatedHMacExtension(System.Collections.IDictionary)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.CreateHeartbeatExtension(Org.BouncyCastle.Crypto.Tls.HeartbeatExtension)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.CreateMaxFragmentLengthExtension(System.Byte)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.CreateServerNameExtension(Org.BouncyCastle.Crypto.Tls.ServerNameList)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.CreateStatusRequestExtension(Org.BouncyCastle.Crypto.Tls.CertificateStatusRequest)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.ReadEmptyExtensionData(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.ReadEncryptThenMacExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.ReadExtendedMasterSecretExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.ReadHeartbeatExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.ReadMaxFragmentLengthExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.ReadServerNameExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.ReadStatusRequestExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsExtensionsUtilities.ReadTruncatedHMacExtension(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsMac">
            <summary>
            A generic TLS MAC implementation, acting as an HMAC based on some underlying Digest.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsMac.#ctor(Org.BouncyCastle.Crypto.Tls.TlsContext,Org.BouncyCastle.Crypto.IDigest,System.Byte[],System.Int32,System.Int32)">
             Generate a new instance of an TlsMac.
            
             @param context the TLS client context
             @param digest  The digest to use.
             @param key     A byte-array where the key for this MAC is located.
             @param keyOff  The number of bytes to skip, before the key starts in the buffer.
             @param keyLen  The length of the key.
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsMac.CalculateMac(System.Int64,System.Byte,System.Byte[],System.Int32,System.Int32)">
             Calculate the MAC for some given data.
            
             @param type    The message type of the message.
             @param message A byte-buffer containing the message.
             @param offset  The number of bytes to skip, before the message starts.
             @param length  The length of the message.
             @return A new byte-buffer containing the MAC value.
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.TlsMac.MacSecret">
            @return the MAC write secret
        </member>
        <member name="P:Org.BouncyCastle.Crypto.Tls.TlsMac.Size">
            @return The output length of this MAC.
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsNullCipher">
            <summary>
            A NULL CipherSuite, with optional MAC.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsNullCipher.#ctor(Org.BouncyCastle.Crypto.Tls.TlsContext,Org.BouncyCastle.Crypto.IDigest,Org.BouncyCastle.Crypto.IDigest)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsNullCipher.EncodePlaintext(System.Int64,System.Byte,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsNullCipher.DecodeCiphertext(System.Int64,System.Byte,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsRsaKeyExchange">
            <summary>(D)TLS and SSLv3 RSA key exchange.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsRsaUtilities.GenerateEncryptedPreMasterSecret(Org.BouncyCastle.Crypto.Tls.TlsContext,Org.BouncyCastle.Crypto.Parameters.RsaKeyParameters,System.IO.Stream)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsStreamCipher.#ctor(Org.BouncyCastle.Crypto.Tls.TlsContext,Org.BouncyCastle.Crypto.IStreamCipher,Org.BouncyCastle.Crypto.IStreamCipher,Org.BouncyCastle.Crypto.IDigest,Org.BouncyCastle.Crypto.IDigest,System.Int32,System.Boolean)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsStreamCipher.DecodeCiphertext(System.Int64,System.Byte,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsStreamCipher.CheckMac(System.Int64,System.Byte,System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Org.BouncyCastle.Crypto.Tls.TlsUtilities">
            <remarks>Some helper functions for MicroTLS.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsUtilities.AddSignatureAlgorithmsExtension(System.Collections.IDictionary,System.Collections.IList)">
             Add a 'signature_algorithms' extension to existing extensions.
            
             @param extensions                   A {@link Hashtable} to add the extension to.
             @param supportedSignatureAlgorithms {@link Vector} containing at least 1 {@link SignatureAndHashAlgorithm}.
             @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsUtilities.GetSignatureAlgorithmsExtension(System.Collections.IDictionary)">
             Get a 'signature_algorithms' extension from extensions.
            
             @param extensions A {@link Hashtable} to get the extension from, if it is present.
             @return A {@link Vector} containing at least 1 {@link SignatureAndHashAlgorithm}, or null.
             @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsUtilities.CreateSignatureAlgorithmsExtension(System.Collections.IList)">
             Create a 'signature_algorithms' extension value.
            
             @param supportedSignatureAlgorithms A {@link Vector} containing at least 1 {@link SignatureAndHashAlgorithm}.
             @return A byte array suitable for use as an extension value.
             @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Crypto.Tls.TlsUtilities.ReadSignatureAlgorithmsExtension(System.Byte[])">
             Read 'signature_algorithms' extension data.
            
             @param extensionData The extension data.
             @return A {@link Vector} containing at least 1 {@link SignatureAndHashAlgorithm}.
             @throws IOException
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.AddMagnitudes(System.Int32[],System.Int32[])">
            return a = a + b - b preserved.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.CompareTo(System.Int32,System.Int32[],System.Int32,System.Int32[])">
            unsigned comparison on two arrays - note the arrays may
            start with leading zeros.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Divide(System.Int32[],System.Int32[])">
            return z = x / y - done in place (z value preserved, x contains the
            remainder)
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.IsProbablePrime(System.Int32)">
            return whether or not a BigInteger is probably prime with a
            probability of 1 - (1/2)**certainty.
            <p>From Knuth Vol 2, pg 395.</p>
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.ExtEuclid(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger@)">
             Calculate the numbers u1, u2, and u3 such that:
            
             u1 * a + u2 * b = u3
            
             where u3 is the greatest common divider of a and b.
             a and b using the extended Euclid algorithm (refer p. 323
             of The Art of Computer Programming vol 2, 2nd ed).
             This also seems to have the side effect of calculating
             some form of multiplicative inverse.
            
             @param a    First number to calculate gcd for
             @param b    Second number to calculate gcd for
             @param u1Out      the return object for the u1 value
             @return     The greatest common divisor of a and b
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Square(System.Int32[],System.Int32[])">
            return w with w = x * x - w is assumed to have enough space.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Multiply(System.Int32[],System.Int32[],System.Int32[])">
            return x with x = y * z - x is assumed to have enough space.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.GetMQuote">
            Calculate mQuote = -m^(-1) mod b with b = 2^32 (32 = word size)
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.MultiplyMonty(System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.UInt32,System.Boolean)">
            Montgomery multiplication: a = x * y * R^(-1) mod m
            <br/>
            Based algorithm 14.36 of Handbook of Applied Cryptography.
            <br/>
            <li> m, x, y should have length n </li>
            <li> a should have length (n + 1) </li>
            <li> b = 2^32, R = b^n </li>
            <br/>
            The result is put in x
            <br/>
            NOTE: the indices of x, y, m, a different in HAC and in Java
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Remainder(System.Int32[],System.Int32[])">
            return x = x % y - done in place (y value preserved)
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.ShiftLeft(System.Int32[],System.Int32)">
            do a left shift - this returns a new array.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.ShiftRightInPlace(System.Int32,System.Int32[],System.Int32)">
            do a right shift - this does it in place.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.ShiftRightOneInPlace(System.Int32,System.Int32[])">
            do a right shift by one - this does it in place.
        </member>
        <member name="M:Org.BouncyCastle.Math.BigInteger.Subtract(System.Int32,System.Int32[],System.Int32,System.Int32[])">
            returns x = x - y - we assume x is >= y
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal">
            Class representing a simple version of a big decimal. A
            <code>SimpleBigDecimal</code> is basically a
            {@link java.math.BigInteger BigInteger} with a few digits on the right of
            the decimal point. The number of (binary) digits on the right of the decimal
            point is called the <code>scale</code> of the <code>SimpleBigDecimal</code>.
            Unlike in {@link java.math.BigDecimal BigDecimal}, the scale is not adjusted
            automatically, but must be set manually. All <code>SimpleBigDecimal</code>s
            taking part in the same arithmetic operation must have equal scale. The
            result of a multiplication of two <code>SimpleBigDecimal</code>s returns a
            <code>SimpleBigDecimal</code> with double scale.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal.GetInstance(Org.BouncyCastle.Math.BigInteger,System.Int32)">
            Returns a <code>SimpleBigDecimal</code> representing the same numerical
            value as <code>value</code>.
            @param value The value of the <code>SimpleBigDecimal</code> to be
            created. 
            @param scale The scale of the <code>SimpleBigDecimal</code> to be
            created. 
            @return The such created <code>SimpleBigDecimal</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal.#ctor(Org.BouncyCastle.Math.BigInteger,System.Int32)">
            Constructor for <code>SimpleBigDecimal</code>. The value of the
            constructed <code>SimpleBigDecimal</code> Equals <code>bigInt / 
            2<sup>scale</sup></code>.
            @param bigInt The <code>bigInt</code> value parameter.
            @param scale The scale of the constructed <code>SimpleBigDecimal</code>.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Abc.Tnaf">
            Class holding methods for point multiplication based on the window
            &#964;-adic nonadjacent form (WTNAF). The algorithms are based on the
            paper "Improved Algorithms for Arithmetic on Anomalous Binary Curves"
            by Jerome A. Solinas. The paper first appeared in the Proceedings of
            Crypto 1997.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.Tnaf.Width">
            The window width of WTNAF. The standard value of 4 is slightly less
            than optimal for running time, but keeps space requirements for
            precomputation low. For typical curves, a value of 5 or 6 results in
            a better running time. When changing this value, the
            <code>&#945;<sub>u</sub></code>'s must be computed differently, see
            e.g. "Guide to Elliptic Curve Cryptography", Darrel Hankerson,
            Alfred Menezes, Scott Vanstone, Springer-Verlag New York Inc., 2004,
            p. 121-122
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.Tnaf.Pow2Width">
            2<sup>4</sup>
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.Tnaf.Alpha0">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=0</code> as an array
            of <code>ZTauElement</code>s.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.Tnaf.Alpha0Tnaf">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=0</code> as an array
            of TNAFs.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.Tnaf.Alpha1">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=1</code> as an array
            of <code>ZTauElement</code>s.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.Tnaf.Alpha1Tnaf">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=1</code> as an array
            of TNAFs.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.Norm(System.SByte,Org.BouncyCastle.Math.EC.Abc.ZTauElement)">
            Computes the norm of an element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @return The norm of <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.Norm(System.SByte,Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal,Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal)">
            Computes the norm of an element <code>&#955;</code> of
            <code><b>R</b>[&#964;]</code>, where <code>&#955; = u + v&#964;</code>
            and <code>u</code> and <code>u</code> are real numbers (elements of
            <code><b>R</b></code>). 
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param u The real part of the element <code>&#955;</code> of
            <code><b>R</b>[&#964;]</code>.
            @param v The <code>&#964;</code>-adic part of the element
            <code>&#955;</code> of <code><b>R</b>[&#964;]</code>.
            @return The norm of <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.Round(Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal,Org.BouncyCastle.Math.EC.Abc.SimpleBigDecimal,System.SByte)">
            Rounds an element <code>&#955;</code> of <code><b>R</b>[&#964;]</code>
            to an element of <code><b>Z</b>[&#964;]</code>, such that their difference
            has minimal norm. <code>&#955;</code> is given as
            <code>&#955; = &#955;<sub>0</sub> + &#955;<sub>1</sub>&#964;</code>.
            @param lambda0 The component <code>&#955;<sub>0</sub></code>.
            @param lambda1 The component <code>&#955;<sub>1</sub></code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve. Must
            equal 1 or -1.
            @return The rounded element of <code><b>Z</b>[&#964;]</code>.
            @throws ArgumentException if <code>lambda0</code> and
            <code>lambda1</code> do not have same scale.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.ApproximateDivisionByN(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,System.SByte,System.Int32,System.Int32)">
            Approximate division by <code>n</code>. For an integer
            <code>k</code>, the value <code>&#955; = s k / n</code> is
            computed to <code>c</code> bits of accuracy.
            @param k The parameter <code>k</code>.
            @param s The curve parameter <code>s<sub>0</sub></code> or
            <code>s<sub>1</sub></code>.
            @param vm The Lucas Sequence element <code>V<sub>m</sub></code>.
            @param a The parameter <code>a</code> of the elliptic curve.
            @param m The bit length of the finite field
            <code><b>F</b><sub>m</sub></code>.
            @param c The number of bits of accuracy, i.e. the scale of the returned
            <code>SimpleBigDecimal</code>.
            @return The value <code>&#955; = s k / n</code> computed to
            <code>c</code> bits of accuracy.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.TauAdicNaf(System.SByte,Org.BouncyCastle.Math.EC.Abc.ZTauElement)">
            Computes the <code>&#964;</code>-adic NAF (non-adjacent form) of an
            element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @return The <code>&#964;</code>-adic NAF of <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.Tau(Org.BouncyCastle.Math.EC.AbstractF2mPoint)">
            Applies the operation <code>&#964;()</code> to an
            <code>AbstractF2mPoint</code>. 
            @param p The AbstractF2mPoint to which <code>&#964;()</code> is applied.
            @return <code>&#964;(p)</code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.GetMu(Org.BouncyCastle.Math.EC.AbstractF2mCurve)">
            Returns the parameter <code>&#956;</code> of the elliptic curve.
            @param curve The elliptic curve from which to obtain <code>&#956;</code>.
            The curve must be a Koblitz curve, i.e. <code>a</code> Equals
            <code>0</code> or <code>1</code> and <code>b</code> Equals
            <code>1</code>. 
            @return <code>&#956;</code> of the elliptic curve.
            @throws ArgumentException if the given ECCurve is not a Koblitz
            curve.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.GetLucas(System.SByte,System.Int32,System.Boolean)">
            Calculates the Lucas Sequence elements <code>U<sub>k-1</sub></code> and
            <code>U<sub>k</sub></code> or <code>V<sub>k-1</sub></code> and
            <code>V<sub>k</sub></code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param k The index of the second element of the Lucas Sequence to be
            returned.
            @param doV If set to true, computes <code>V<sub>k-1</sub></code> and
            <code>V<sub>k</sub></code>, otherwise <code>U<sub>k-1</sub></code> and
            <code>U<sub>k</sub></code>.
            @return An array with 2 elements, containing <code>U<sub>k-1</sub></code>
            and <code>U<sub>k</sub></code> or <code>V<sub>k-1</sub></code>
            and <code>V<sub>k</sub></code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.GetTw(System.SByte,System.Int32)">
            Computes the auxiliary value <code>t<sub>w</sub></code>. If the width is
            4, then for <code>mu = 1</code>, <code>t<sub>w</sub> = 6</code> and for
            <code>mu = -1</code>, <code>t<sub>w</sub> = 10</code> 
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param w The window width of the WTNAF.
            @return the auxiliary value <code>t<sub>w</sub></code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.GetSi(Org.BouncyCastle.Math.EC.AbstractF2mCurve)">
            Computes the auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code> used for partial modular reduction. 
            @param curve The elliptic curve for which to compute
            <code>s<sub>0</sub></code> and <code>s<sub>1</sub></code>.
            @throws ArgumentException if <code>curve</code> is not a
            Koblitz curve (Anomalous Binary Curve, ABC).
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.PartModReduction(Org.BouncyCastle.Math.BigInteger,System.Int32,System.SByte,Org.BouncyCastle.Math.BigInteger[],System.SByte,System.SByte)">
            Partial modular reduction modulo
            <code>(&#964;<sup>m</sup> - 1)/(&#964; - 1)</code>.
            @param k The integer to be reduced.
            @param m The bitlength of the underlying finite field.
            @param a The parameter <code>a</code> of the elliptic curve.
            @param s The auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code>.
            @param mu The parameter &#956; of the elliptic curve.
            @param c The precision (number of bits of accuracy) of the partial
            modular reduction.
            @return <code>&#961; := k partmod (&#964;<sup>m</sup> - 1)/(&#964; - 1)</code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.MultiplyRTnaf(Org.BouncyCastle.Math.EC.AbstractF2mPoint,Org.BouncyCastle.Math.BigInteger)">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by a <code>BigInteger</code> using the reduced <code>&#964;</code>-adic
            NAF (RTNAF) method.
            @param p The AbstractF2mPoint to Multiply.
            @param k The <code>BigInteger</code> by which to Multiply <code>p</code>.
            @return <code>k * p</code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.MultiplyTnaf(Org.BouncyCastle.Math.EC.AbstractF2mPoint,Org.BouncyCastle.Math.EC.Abc.ZTauElement)">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>
            using the <code>&#964;</code>-adic NAF (TNAF) method.
            @param p The AbstractF2mPoint to Multiply.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @return <code>&#955; * p</code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.MultiplyFromTnaf(Org.BouncyCastle.Math.EC.AbstractF2mPoint,System.SByte[])">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>
            using the <code>&#964;</code>-adic NAF (TNAF) method, given the TNAF
            of <code>&#955;</code>.
            @param p The AbstractF2mPoint to Multiply.
            @param u The the TNAF of <code>&#955;</code>..
            @return <code>&#955; * p</code>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.TauAdicWNaf(System.SByte,Org.BouncyCastle.Math.EC.Abc.ZTauElement,System.SByte,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.EC.Abc.ZTauElement[])">
            Computes the <code>[&#964;]</code>-adic window NAF of an element
            <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>.
            @param mu The parameter &#956; of the elliptic curve.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code> of which to compute the
            <code>[&#964;]</code>-adic NAF.
            @param width The window width of the resulting WNAF.
            @param pow2w 2<sup>width</sup>.
            @param tw The auxiliary value <code>t<sub>w</sub></code>.
            @param alpha The <code>&#945;<sub>u</sub></code>'s for the window width.
            @return The <code>[&#964;]</code>-adic window NAF of
            <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.Tnaf.GetPreComp(Org.BouncyCastle.Math.EC.AbstractF2mPoint,System.SByte)">
            Does the precomputation for WTNAF multiplication.
            @param p The <code>ECPoint</code> for which to do the precomputation.
            @param a The parameter <code>a</code> of the elliptic curve.
            @return The precomputation array for <code>p</code>. 
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Abc.ZTauElement">
            Class representing an element of <code><b>Z</b>[&#964;]</code>. Let
            <code>&#955;</code> be an element of <code><b>Z</b>[&#964;]</code>. Then
            <code>&#955;</code> is given as <code>&#955; = u + v&#964;</code>. The
            components <code>u</code> and <code>v</code> may be used directly, there
            are no accessor methods.
            Immutable class.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.ZTauElement.u">
            The &quot;real&quot; part of <code>&#955;</code>.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Abc.ZTauElement.v">
            The &quot;<code>&#964;</code>-adic&quot; part of <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Abc.ZTauElement.#ctor(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Constructor for an element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @param u The &quot;real&quot; part of <code>&#955;</code>.
            @param v The &quot;<code>&#964;</code>-adic&quot; part of
            <code>&#955;</code>.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.ECCurve">
            <remarks>Base class for an elliptic curve.</remarks>
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECCurve.SetPreCompInfo(Org.BouncyCastle.Math.EC.ECPoint,System.String,Org.BouncyCastle.Math.EC.Multiplier.PreCompInfo)">
            Adds <code>PreCompInfo</code> for a point on this curve, under a given name. Used by
            <code>ECMultiplier</code>s to save the precomputation for this <code>ECPoint</code> for use
            by subsequent multiplication.
            
            @param point
                       The <code>ECPoint</code> to store precomputations for.
            @param name
                       A <code>String</code> used to index precomputations of different types.
            @param preCompInfo
                       The values precomputed by the <code>ECMultiplier</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECCurve.NormalizeAll(Org.BouncyCastle.Math.EC.ECPoint[])">
            Normalization ensures that any projective coordinate is 1, and therefore that the x, y
            coordinates reflect those of the equivalent point in an affine coordinate system. Where more
            than one point is to be normalized, this method will generally be more efficient than
            normalizing each point separately.
            
            @param points
                       An array of points that will be updated in place with their normalized versions,
                       where necessary
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECCurve.NormalizeAll(Org.BouncyCastle.Math.EC.ECPoint[],System.Int32,System.Int32,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Normalization ensures that any projective coordinate is 1, and therefore that the x, y
            coordinates reflect those of the equivalent point in an affine coordinate system. Where more
            than one point is to be normalized, this method will generally be more efficient than
            normalizing each point separately. An (optional) z-scaling factor can be applied; effectively
            each z coordinate is scaled by this value prior to normalization (but only one
            actual multiplication is needed).
            
            @param points
                       An array of points that will be updated in place with their normalized versions,
                       where necessary
            @param off
                       The start of the range of points to normalize
            @param len
                       The length of the range of points to normalize
            @param iso
                       The (optional) z-scaling factor - can be null
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECCurve.GetMultiplier">
            Sets the default <code>ECMultiplier</code>, unless already set. 
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECCurve.DecodePoint(System.Byte[])">
            Decode a point on this curve from its ASN.1 encoding. The different
            encodings are taken account of, including point compression for
            <code>F<sub>p</sub></code> (X9.62 s 4.2.1 pg 17).
            @return The decoded point.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Djb.Curve25519FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.ECPoint">
            base class for points on elliptic curves.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECPoint.Normalize">
            Normalization ensures that any projective coordinate is 1, and therefore that the x, y
            coordinates reflect those of the equivalent point in an affine coordinate system.
            
            @return a new ECPoint instance representing the same point, but with normalized coordinates
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.ECPoint.X">
            Normalizes this point, and then returns the affine x-coordinate.
            
            Note: normalization can be expensive, this method is deprecated in favour
            of caller-controlled normalization.
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.ECPoint.Y">
            Normalizes this point, and then returns the affine y-coordinate.
            
            Note: normalization can be expensive, this method is deprecated in favour
            of caller-controlled normalization.
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.ECPoint.AffineXCoord">
            Returns the affine x-coordinate after checking that this point is normalized.
            
            @return The affine x-coordinate of this point
            @throws IllegalStateException if the point is not normalized
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.ECPoint.AffineYCoord">
            Returns the affine y-coordinate after checking that this point is normalized
            
            @return The affine y-coordinate of this point
            @throws IllegalStateException if the point is not normalized
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.ECPoint.XCoord">
            Returns the x-coordinate.
            
            Caution: depending on the curve's coordinate system, this may not be the same value as in an
            affine coordinate system; use Normalize() to get a point where the coordinates have their
            affine values, or use AffineXCoord if you expect the point to already have been normalized.
            
            @return the x-coordinate of this point
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.ECPoint.YCoord">
            Returns the y-coordinate.
            
            Caution: depending on the curve's coordinate system, this may not be the same value as in an
            affine coordinate system; use Normalize() to get a point where the coordinates have their
            affine values, or use AffineYCoord if you expect the point to already have been normalized.
            
            @return the y-coordinate of this point
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECPointBase.GetEncoded(System.Boolean)">
            return the field element encoded with point compression. (S 4.3.6)
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECPointBase.Multiply(Org.BouncyCastle.Math.BigInteger)">
            Multiplies this <code>ECPoint</code> by the given number.
            @param k The multiplicator.
            @return <code>k * this</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Djb.Curve25519Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Create a point which encodes with point compression.
            
            @param curve the curve to use
            @param x affine x co-ordinate
            @param y affine y co-ordinate
            
            @deprecated Use ECCurve.CreatePoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Djb.Curve25519Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            Create a point that encodes with or without point compresion.
            
            @param curve the curve to use
            @param x affine x co-ordinate
            @param y affine y co-ordinate
            @param withCompression if true encode with point compression
            
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP128R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP128R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Create a point which encodes with point compression.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP128R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            Create a point that encodes with or without point compresion.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            @param withCompression
                       if true encode with point compression
            
            @deprecated per-point compression property will be removed, refer
                        {@link #getEncoded(boolean)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP160K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Create a point which encodes with point compression.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            
            @deprecated Use ECCurve.CreatePoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP160K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            Create a point that encodes with or without point compresion.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            @param withCompression
                       if true encode with point compression
            
            @deprecated per-point compression property will be removed, refer
                        {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Create a point which encodes with point compression.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            
            @deprecated Use ECCurve.CreatePoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            Create a point that encodes with or without point compresion.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            @param withCompression
                       if true encode with point compression
            
            @deprecated per-point compression property will be removed, refer
                        {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R2FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R2Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Create a point which encodes with point compression.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            
            @deprecated Use ECCurve.CreatePoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP160R2Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            Create a point that encodes with or without point compresion.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            @param withCompression
                       if true encode with point compression
            
            @deprecated per-point compression property will be removed, refer
                        {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP192K1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP192K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Create a point which encodes with point compression.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP192K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            Create a point that encodes with or without point compresion.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            @param withCompression
                       if true encode with point compression
            
            @deprecated per-point compression property will be removed, refer
                        {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP192R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP192R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Create a point which encodes with point compression.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP192R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            Create a point that encodes with or without point compresion.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            @param withCompression
                       if true encode with point compression
            
            @deprecated per-point compression property will be removed, refer
                        {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP224K1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP224K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Create a point which encodes with point compression.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP224K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            Create a point that encodes with or without point compresion.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            @param withCompression
                       if true encode with point compression
            
            @deprecated per-point compression property will be removed, refer
                        {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP224R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP224R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Create a point which encodes with point compression.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP224R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            Create a point that encodes with or without point compresion.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            @param withCompression
                       if true encode with point compression
            
            @deprecated per-point compression property will be removed, refer
                        {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP256K1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP256K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Create a point which encodes with point compression.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP256K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            Create a point that encodes with or without point compresion.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            @param withCompression
                       if true encode with point compression
            
            @deprecated per-point compression property will be removed, refer
                        {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP256R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP256R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Create a point which encodes with point compression.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP256R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            Create a point that encodes with or without point compresion.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            @param withCompression
                       if true encode with point compression
            
            @deprecated per-point compression property will be removed, refer
                        {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP384R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP384R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Create a point which encodes with point compression.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP384R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            Create a point that encodes with or without point compresion.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            @param withCompression
                       if true encode with point compression
            
            @deprecated per-point compression property will be removed, refer
                        {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP521R1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP521R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Create a point which encodes with point compression.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecP521R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            Create a point that encodes with or without point compresion.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            @param withCompression
                       if true encode with point compression
            
            @deprecated per-point compression property will be removed, refer
                        {@link #getEncoded(bool)}
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.AbstractF2mCurve.si">
            The auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code> used for partial modular reduction for
            Koblitz curves.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.AbstractF2mCurve.GetSi">
            @return the auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code> used for partial modular reduction for
            Koblitz curves.
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.AbstractF2mCurve.IsKoblitz">
            Returns true if this is a Koblitz curve (ABC curve).
            @return true if this is a Koblitz curve (ABC curve), false otherwise
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT113R1Curve.DecompressPoint(System.Int32,Org.BouncyCastle.Math.BigInteger)">
            Decompresses a compressed point P = (xp, yp) (X9.62 s 4.2.2).
            
            @param yTilde
                       ~yp, an indication bit for the decompression of yp.
            @param X1
                       The field element xp.
            @return the decompressed point.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT113R1Curve.SolveQuadraticEquation(Org.BouncyCastle.Math.EC.ECFieldElement)">
            Solves a quadratic equation <code>z<sup>2</sup> + z = beta</code>(X9.62
            D.1.6) The other solution is <code>z + 1</code>.
            
            @param beta
                       The value to solve the quadratic equation for.
            @return the solution for <code>z<sup>2</sup> + z = beta</code> or
                    <code>null</code> if no solution exists.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT113R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT113R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT113R2Curve.DecompressPoint(System.Int32,Org.BouncyCastle.Math.BigInteger)">
            Decompresses a compressed point P = (xp, yp) (X9.62 s 4.2.2).
            
            @param yTilde
                       ~yp, an indication bit for the decompression of yp.
            @param X1
                       The field element xp.
            @return the decompressed point.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT113R2Curve.SolveQuadraticEquation(Org.BouncyCastle.Math.EC.ECFieldElement)">
            Solves a quadratic equation <code>z<sup>2</sup> + z = beta</code>(X9.62
            D.1.6) The other solution is <code>z + 1</code>.
            
            @param beta
                       The value to solve the quadratic equation for.
            @return the solution for <code>z<sup>2</sup> + z = beta</code> or
                    <code>null</code> if no solution exists.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT113R2Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT113R2Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT131R1Curve.DecompressPoint(System.Int32,Org.BouncyCastle.Math.BigInteger)">
            Decompresses a compressed point P = (xp, yp) (X9.62 s 4.2.2).
            
            @param yTilde
                       ~yp, an indication bit for the decompression of yp.
            @param X1
                       The field element xp.
            @return the decompressed point.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT131R1Curve.SolveQuadraticEquation(Org.BouncyCastle.Math.EC.ECFieldElement)">
            Solves a quadratic equation <code>z<sup>2</sup> + z = beta</code>(X9.62
            D.1.6) The other solution is <code>z + 1</code>.
            
            @param beta
                       The value to solve the quadratic equation for.
            @return the solution for <code>z<sup>2</sup> + z = beta</code> or
                    <code>null</code> if no solution exists.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT131R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT131R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT131R2Curve.DecompressPoint(System.Int32,Org.BouncyCastle.Math.BigInteger)">
            Decompresses a compressed point P = (xp, yp) (X9.62 s 4.2.2).
            
            @param yTilde
                       ~yp, an indication bit for the decompression of yp.
            @param X1
                       The field element xp.
            @return the decompressed point.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT131R2Curve.SolveQuadraticEquation(Org.BouncyCastle.Math.EC.ECFieldElement)">
            Solves a quadratic equation <code>z<sup>2</sup> + z = beta</code>(X9.62
            D.1.6) The other solution is <code>z + 1</code>.
            
            @param beta
                       The value to solve the quadratic equation for.
            @return the solution for <code>z<sup>2</sup> + z = beta</code> or
                    <code>null</code> if no solution exists.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT131R2Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT131R2Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT163K1Curve.DecompressPoint(System.Int32,Org.BouncyCastle.Math.BigInteger)">
            Decompresses a compressed point P = (xp, yp) (X9.62 s 4.2.2).
            
            @param yTilde
                       ~yp, an indication bit for the decompression of yp.
            @param X1
                       The field element xp.
            @return the decompressed point.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT163K1Curve.SolveQuadraticEquation(Org.BouncyCastle.Math.EC.ECFieldElement)">
            Solves a quadratic equation <code>z<sup>2</sup> + z = beta</code>(X9.62
            D.1.6) The other solution is <code>z + 1</code>.
            
            @param beta
                       The value to solve the quadratic equation for.
            @return the solution for <code>z<sup>2</sup> + z = beta</code> or
                    <code>null</code> if no solution exists.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT163K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT163K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT163R1Curve.DecompressPoint(System.Int32,Org.BouncyCastle.Math.BigInteger)">
            Decompresses a compressed point P = (xp, yp) (X9.62 s 4.2.2).
            
            @param yTilde
                       ~yp, an indication bit for the decompression of yp.
            @param X1
                       The field element xp.
            @return the decompressed point.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT163R1Curve.SolveQuadraticEquation(Org.BouncyCastle.Math.EC.ECFieldElement)">
            Solves a quadratic equation <code>z<sup>2</sup> + z = beta</code>(X9.62
            D.1.6) The other solution is <code>z + 1</code>.
            
            @param beta
                       The value to solve the quadratic equation for.
            @return the solution for <code>z<sup>2</sup> + z = beta</code> or
                    <code>null</code> if no solution exists.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT163R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT163R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT163R2Curve.DecompressPoint(System.Int32,Org.BouncyCastle.Math.BigInteger)">
            Decompresses a compressed point P = (xp, yp) (X9.62 s 4.2.2).
            
            @param yTilde
                       ~yp, an indication bit for the decompression of yp.
            @param X1
                       The field element xp.
            @return the decompressed point.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT163R2Curve.SolveQuadraticEquation(Org.BouncyCastle.Math.EC.ECFieldElement)">
            Solves a quadratic equation <code>z<sup>2</sup> + z = beta</code>(X9.62
            D.1.6) The other solution is <code>z + 1</code>.
            
            @param beta
                       The value to solve the quadratic equation for.
            @return the solution for <code>z<sup>2</sup> + z = beta</code> or
                    <code>null</code> if no solution exists.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT163R2Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT163R2Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT233K1Curve.DecompressPoint(System.Int32,Org.BouncyCastle.Math.BigInteger)">
            Decompresses a compressed point P = (xp, yp) (X9.62 s 4.2.2).
            
            @param yTilde
                       ~yp, an indication bit for the decompression of yp.
            @param X1
                       The field element xp.
            @return the decompressed point.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT233K1Curve.SolveQuadraticEquation(Org.BouncyCastle.Math.EC.ECFieldElement)">
            Solves a quadratic equation <code>z<sup>2</sup> + z = beta</code>(X9.62
            D.1.6) The other solution is <code>z + 1</code>.
            
            @param beta
                       The value to solve the quadratic equation for.
            @return the solution for <code>z<sup>2</sup> + z = beta</code> or
                    <code>null</code> if no solution exists.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT233K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT233K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT233R1Curve.DecompressPoint(System.Int32,Org.BouncyCastle.Math.BigInteger)">
            Decompresses a compressed point P = (xp, yp) (X9.62 s 4.2.2).
            
            @param yTilde
                       ~yp, an indication bit for the decompression of yp.
            @param X1
                       The field element xp.
            @return the decompressed point.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT233R1Curve.SolveQuadraticEquation(Org.BouncyCastle.Math.EC.ECFieldElement)">
            Solves a quadratic equation <code>z<sup>2</sup> + z = beta</code>(X9.62
            D.1.6) The other solution is <code>z + 1</code>.
            
            @param beta
                       The value to solve the quadratic equation for.
            @return the solution for <code>z<sup>2</sup> + z = beta</code> or
                    <code>null</code> if no solution exists.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT233R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT233R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT239K1Curve.DecompressPoint(System.Int32,Org.BouncyCastle.Math.BigInteger)">
            Decompresses a compressed point P = (xp, yp) (X9.62 s 4.2.2).
            
            @param yTilde
                       ~yp, an indication bit for the decompression of yp.
            @param X1
                       The field element xp.
            @return the decompressed point.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT239K1Curve.SolveQuadraticEquation(Org.BouncyCastle.Math.EC.ECFieldElement)">
            Solves a quadratic equation <code>z<sup>2</sup> + z = beta</code>(X9.62
            D.1.6) The other solution is <code>z + 1</code>.
            
            @param beta
                       The value to solve the quadratic equation for.
            @return the solution for <code>z<sup>2</sup> + z = beta</code> or
                    <code>null</code> if no solution exists.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT239K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT239K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT283K1Curve.DecompressPoint(System.Int32,Org.BouncyCastle.Math.BigInteger)">
            Decompresses a compressed point P = (xp, yp) (X9.62 s 4.2.2).
            
            @param yTilde
                       ~yp, an indication bit for the decompression of yp.
            @param X1
                       The field element xp.
            @return the decompressed point.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT283K1Curve.SolveQuadraticEquation(Org.BouncyCastle.Math.EC.ECFieldElement)">
            Solves a quadratic equation <code>z<sup>2</sup> + z = beta</code>(X9.62
            D.1.6) The other solution is <code>z + 1</code>.
            
            @param beta
                       The value to solve the quadratic equation for.
            @return the solution for <code>z<sup>2</sup> + z = beta</code> or
                    <code>null</code> if no solution exists.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT283K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT283K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT283R1Curve.DecompressPoint(System.Int32,Org.BouncyCastle.Math.BigInteger)">
            Decompresses a compressed point P = (xp, yp) (X9.62 s 4.2.2).
            
            @param yTilde
                       ~yp, an indication bit for the decompression of yp.
            @param X1
                       The field element xp.
            @return the decompressed point.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT283R1Curve.SolveQuadraticEquation(Org.BouncyCastle.Math.EC.ECFieldElement)">
            Solves a quadratic equation <code>z<sup>2</sup> + z = beta</code>(X9.62
            D.1.6) The other solution is <code>z + 1</code>.
            
            @param beta
                       The value to solve the quadratic equation for.
            @return the solution for <code>z<sup>2</sup> + z = beta</code> or
                    <code>null</code> if no solution exists.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT283R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT283R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT409K1Curve.DecompressPoint(System.Int32,Org.BouncyCastle.Math.BigInteger)">
            Decompresses a compressed point P = (xp, yp) (X9.62 s 4.2.2).
            
            @param yTilde
                       ~yp, an indication bit for the decompression of yp.
            @param X1
                       The field element xp.
            @return the decompressed point.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT409K1Curve.SolveQuadraticEquation(Org.BouncyCastle.Math.EC.ECFieldElement)">
            Solves a quadratic equation <code>z<sup>2</sup> + z = beta</code>(X9.62
            D.1.6) The other solution is <code>z + 1</code>.
            
            @param beta
                       The value to solve the quadratic equation for.
            @return the solution for <code>z<sup>2</sup> + z = beta</code> or
                    <code>null</code> if no solution exists.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT409K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT409K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT409R1Curve.DecompressPoint(System.Int32,Org.BouncyCastle.Math.BigInteger)">
            Decompresses a compressed point P = (xp, yp) (X9.62 s 4.2.2).
            
            @param yTilde
                       ~yp, an indication bit for the decompression of yp.
            @param X1
                       The field element xp.
            @return the decompressed point.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT409R1Curve.SolveQuadraticEquation(Org.BouncyCastle.Math.EC.ECFieldElement)">
            Solves a quadratic equation <code>z<sup>2</sup> + z = beta</code>(X9.62
            D.1.6) The other solution is <code>z + 1</code>.
            
            @param beta
                       The value to solve the quadratic equation for.
            @return the solution for <code>z<sup>2</sup> + z = beta</code> or
                    <code>null</code> if no solution exists.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT409R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT409R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT571K1Curve.DecompressPoint(System.Int32,Org.BouncyCastle.Math.BigInteger)">
            Decompresses a compressed point P = (xp, yp) (X9.62 s 4.2.2).
            
            @param yTilde
                       ~yp, an indication bit for the decompression of yp.
            @param X1
                       The field element xp.
            @return the decompressed point.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT571K1Curve.SolveQuadraticEquation(Org.BouncyCastle.Math.EC.ECFieldElement)">
            Solves a quadratic equation <code>z<sup>2</sup> + z = beta</code>(X9.62
            D.1.6) The other solution is <code>z + 1</code>.
            
            @param beta
                       The value to solve the quadratic equation for.
            @return the solution for <code>z<sup>2</sup> + z = beta</code> or
                    <code>null</code> if no solution exists.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT571K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT571K1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT571R1Curve.DecompressPoint(System.Int32,Org.BouncyCastle.Math.BigInteger)">
            Decompresses a compressed point P = (xp, yp) (X9.62 s 4.2.2).
            
            @param yTilde
                       ~yp, an indication bit for the decompression of yp.
            @param X1
                       The field element xp.
            @return the decompressed point.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT571R1Curve.SolveQuadraticEquation(Org.BouncyCastle.Math.EC.ECFieldElement)">
            Solves a quadratic equation <code>z<sup>2</sup> + z = beta</code>(X9.62
            D.1.6) The other solution is <code>z + 1</code>.
            
            @param beta
                       The value to solve the quadratic equation for.
            @return the solution for <code>z<sup>2</sup> + z = beta</code> or
                    <code>null</code> if no solution exists.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT571R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Custom.Sec.SecT571R1Point.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @deprecated per-point compression property will be removed, refer {@link #getEncoded(bool)}
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.ECAlgorithms.ReferenceMultiply(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger)">
            Simple shift-and-add multiplication. Serves as reference implementation
            to verify (possibly faster) implementations, and for very small scalars.
            
            @param p
                       The point to multiply.
            @param k
                       The multiplier.
            @return The result of the point multiplication <code>kP</code>.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.FpCurve">
            Elliptic curve over Fp
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.F2mCurve">
            Elliptic curves over F2m. The Weierstrass equation is given by
            <code>y<sup>2</sup> + xy = x<sup>3</sup> + ax<sup>2</sup> + b</code>.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mCurve.m">
            The exponent <code>m</code> of <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mCurve.k1">
            TPB: The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction polynomial
            <code>f(z)</code>.<br/>
            PPB: The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mCurve.k2">
            TPB: Always set to <code>0</code><br/>
            PPB: The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mCurve.k3">
            TPB: Always set to <code>0</code><br/>
            PPB: The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mCurve.m_infinity">
            The point at infinity on this curve.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Constructor for Trinomial Polynomial Basis (TPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction
            polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Constructor for Trinomial Polynomial Basis (TPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction
            polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param order The order of the main subgroup of the elliptic curve.
            @param cofactor The cofactor of the elliptic curve, i.e.
            <code>#E<sub>a</sub>(F<sub>2<sup>m</sup></sub>) = h * n</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Constructor for Pentanomial Polynomial Basis (PPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger)">
            Constructor for Pentanomial Polynomial Basis (PPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param order The order of the main subgroup of the elliptic curve.
            @param cofactor The cofactor of the elliptic curve, i.e.
            <code>#E<sub>a</sub>(F<sub>2<sup>m</sup></sub>) = h * n</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mCurve.SolveQuadradicEquation(Org.BouncyCastle.Math.EC.ECFieldElement)">
             Solves a quadratic equation <code>z<sup>2</sup> + z = beta</code>(X9.62
             D.1.6) The other solution is <code>z + 1</code>.
            
             @param beta
                        The value to solve the qradratic equation for.
             @return the solution for <code>z<sup>2</sup> + z = beta</code> or
                     <code>null</code> if no solution exists.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mCurve.IsTrinomial">
             Return true if curve uses a Trinomial basis.
            
             @return true if curve Trinomial, false otherwise.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.FpFieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation
            returns the right value - if none exists it returns null.
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.FpFieldElement.FieldName">
             return the field name for this field.
            
             @return the string "Fp".
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.F2mFieldElement">
            Class representing the Elements of the finite field
            <code>F<sub>2<sup>m</sup></sub></code> in polynomial basis (PB)
            representation. Both trinomial (Tpb) and pentanomial (Ppb) polynomial
            basis representations are supported. Gaussian normal basis (GNB)
            representation is not supported.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.Gnb">
            Indicates gaussian normal basis representation (GNB). Number chosen
            according to X9.62. GNB is not implemented at present.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.Tpb">
            Indicates trinomial basis representation (Tpb). Number chosen
            according to X9.62.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.Ppb">
            Indicates pentanomial basis representation (Ppb). Number chosen
            according to X9.62.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.representation">
            Tpb or Ppb.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.m">
            The exponent <code>m</code> of <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.F2mFieldElement.x">
            The <code>LongArray</code> holding the bits.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mFieldElement.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,Org.BouncyCastle.Math.BigInteger)">
            Constructor for Ppb.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param x The BigInteger representing the value of the field element.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mFieldElement.#ctor(System.Int32,System.Int32,Org.BouncyCastle.Math.BigInteger)">
            Constructor for Tpb.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction
            polynomial <code>f(z)</code>.
            @param x The BigInteger representing the value of the field element.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mFieldElement.CheckFieldElements(Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            Checks, if the ECFieldElements <code>a</code> and <code>b</code>
            are elements of the same field <code>F<sub>2<sup>m</sup></sub></code>
            (having the same representation).
            @param a field element.
            @param b field element to be compared.
            @throws ArgumentException if <code>a</code> and <code>b</code>
            are not elements of the same field
            <code>F<sub>2<sup>m</sup></sub></code> (having the same
            representation).
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.F2mFieldElement.Representation">
            @return the representation of the field
            <code>F<sub>2<sup>m</sup></sub></code>, either of
            {@link F2mFieldElement.Tpb} (trinomial
            basis representation) or
            {@link F2mFieldElement.Ppb} (pentanomial
            basis representation).
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.F2mFieldElement.M">
            @return the degree <code>m</code> of the reduction polynomial
            <code>f(z)</code>.
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.F2mFieldElement.K1">
            @return Tpb: The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction polynomial
            <code>f(z)</code>.<br/>
            Ppb: The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.F2mFieldElement.K2">
            @return Tpb: Always returns <code>0</code><br/>
            Ppb: The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="P:Org.BouncyCastle.Math.EC.F2mFieldElement.K3">
            @return Tpb: Always set to <code>0</code><br/>
            Ppb: The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.FpPoint">
            Elliptic curve points over Fp
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.FpPoint.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
             Create a point which encodes without point compression.
            
             @param curve the curve to use
             @param x affine x co-ordinate
             @param y affine y co-ordinate
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.FpPoint.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
             Create a point that encodes with or without point compression.
            
             @param curve the curve to use
             @param x affine x co-ordinate
             @param y affine y co-ordinate
             @param withCompression if true encode with point compression
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.F2mPoint">
            Elliptic curve points over F2m
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mPoint.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement)">
            @param curve base curve
            @param x x point
            @param y y point
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mPoint.#ctor(Org.BouncyCastle.Math.EC.ECCurve,Org.BouncyCastle.Math.EC.ECFieldElement,Org.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @param curve base curve
            @param x x point
            @param y y point
            @param withCompression true if encode with point compression.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.F2mPoint.#ctor(Org.BouncyCastle.Math.EC.ECCurve)">
            Constructor for point at infinity
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.ECMultiplier">
            Interface for classes encapsulating a point multiplication algorithm
            for <code>ECPoint</code>s.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.ECMultiplier.Multiply(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger)">
            Multiplies the <code>ECPoint p</code> by <code>k</code>, i.e.
            <code>p</code> is added <code>k</code> times to itself.
            @param p The <code>ECPoint</code> to be multiplied.
            @param k The factor by which <code>p</code> is multiplied.
            @return <code>p</code> multiplied by <code>k</code>.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.FixedPointPreCompInfo">
            Class holding precomputation data for fixed-point multiplications.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.PreCompInfo">
            Interface for classes storing precomputation data for multiplication
            algorithms. Used as a Memento (see GOF patterns) for
            <code>WNafMultiplier</code>.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Multiplier.FixedPointPreCompInfo.m_preComp">
            Array holding the precomputed <code>ECPoint</code>s used for a fixed
            point multiplication.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Multiplier.FixedPointPreCompInfo.m_width">
            The width used for the precomputation. If a larger width precomputation
            is already available this may be larger than was requested, so calling
            code should refer to the actual width.
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.WNafL2RMultiplier">
            Class implementing the WNAF (Window Non-Adjacent Form) multiplication
            algorithm.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WNafL2RMultiplier.MultiplyPositive(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger)">
            Multiplies <code>this</code> by an integer <code>k</code> using the
            Window NAF method.
            @param k The integer by which <code>this</code> is multiplied.
            @return A new <code>ECPoint</code> which equals <code>this</code>
            multiplied by <code>k</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WNafL2RMultiplier.GetWindowSize(System.Int32)">
            Determine window width to use for a scalar multiplication of the given size.
            
            @param bits the bit-length of the scalar to multiply by
            @return the window size to use
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo">
            Class holding precomputation data for the WNAF (Window Non-Adjacent Form)
            algorithm.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo.m_preComp">
            Array holding the precomputed <code>ECPoint</code>s used for a Window
            NAF multiplication.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo.m_preCompNeg">
            Array holding the negations of the precomputed <code>ECPoint</code>s used
            for a Window NAF multiplication.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo.m_twice">
            Holds an <code>ECPoint</code> representing Twice(this). Used for the
            Window NAF multiplication to create or extend the precomputed values.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WNafUtilities.GenerateWindowNaf(System.Int32,Org.BouncyCastle.Math.BigInteger)">
            Computes the Window NAF (non-adjacent Form) of an integer.
            @param width The width <code>w</code> of the Window NAF. The width is
            defined as the minimal number <code>w</code>, such that for any
            <code>w</code> consecutive digits in the resulting representation, at
            most one is non-zero.
            @param k The integer of which the Window NAF is computed.
            @return The Window NAF of the given width, such that the following holds:
            <code>k = &amp;sum;<sub>i=0</sub><sup>l-1</sup> k<sub>i</sub>2<sup>i</sup>
            </code>, where the <code>k<sub>i</sub></code> denote the elements of the
            returned <code>byte[]</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WNafUtilities.GetWindowSize(System.Int32)">
            Determine window width to use for a scalar multiplication of the given size.
            
            @param bits the bit-length of the scalar to multiply by
            @return the window size to use
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WNafUtilities.GetWindowSize(System.Int32,System.Int32[])">
            Determine window width to use for a scalar multiplication of the given size.
            
            @param bits the bit-length of the scalar to multiply by
            @param windowSizeCutoffs a monotonically increasing list of bit sizes at which to increment the window width
            @return the window size to use
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier">
            Class implementing the WTNAF (Window
            <code>&#964;</code>-adic Non-Adjacent Form) algorithm.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier.MultiplyPositive(Org.BouncyCastle.Math.EC.ECPoint,Org.BouncyCastle.Math.BigInteger)">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by <code>k</code> using the reduced <code>&#964;</code>-adic NAF (RTNAF)
            method.
            @param p The AbstractF2mPoint to multiply.
            @param k The integer by which to multiply <code>k</code>.
            @return <code>p</code> multiplied by <code>k</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier.MultiplyWTnaf(Org.BouncyCastle.Math.EC.AbstractF2mPoint,Org.BouncyCastle.Math.EC.Abc.ZTauElement,Org.BouncyCastle.Math.EC.Multiplier.PreCompInfo,System.SByte,System.SByte)">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code> using
            the <code>&#964;</code>-adic NAF (TNAF) method.
            @param p The AbstractF2mPoint to multiply.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code> of which to compute the
            <code>[&#964;]</code>-adic NAF.
            @return <code>p</code> multiplied by <code>&#955;</code>.
        </member>
        <member name="M:Org.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier.MultiplyFromWTnaf(Org.BouncyCastle.Math.EC.AbstractF2mPoint,System.SByte[],Org.BouncyCastle.Math.EC.Multiplier.PreCompInfo)">
            Multiplies a {@link org.bouncycastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>
            using the window <code>&#964;</code>-adic NAF (TNAF) method, given the
            WTNAF of <code>&#955;</code>.
            @param p The AbstractF2mPoint to multiply.
            @param u The the WTNAF of <code>&#955;</code>..
            @return <code>&#955; * p</code>
        </member>
        <member name="T:Org.BouncyCastle.Math.EC.Multiplier.WTauNafPreCompInfo">
            Class holding precomputation data for the WTNAF (Window
            <code>&#964;</code>-adic Non-Adjacent Form) algorithm.
        </member>
        <member name="F:Org.BouncyCastle.Math.EC.Multiplier.WTauNafPreCompInfo.m_preComp">
            Array holding the precomputed <code>AbstractF2mPoint</code>s used for the
            WTNAF multiplication in <code>
            {@link org.bouncycastle.math.ec.multiplier.WTauNafMultiplier.multiply()
            WTauNafMultiplier.multiply()}</code>.
        </member>
        <member name="T:Org.BouncyCastle.Security.DigestUtilities">
            <remarks>
             Utility class for creating IDigest objects from their names/Oids
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Security.DigestUtilities.GetObjectIdentifier(System.String)">
            <summary>
            Returns a ObjectIdentifier for a given digest mechanism.
            </summary>
            <param name="mechanism">A string representation of the digest meanism.</param>
            <returns>A DerObjectIdentifier, null if the Oid is not available.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Security.MacUtilities">
            <remarks>
             Utility class for creating HMac object from their names/Oids
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Security.SecureRandom.GetInstance(System.String)">
            <summary>
            Create and auto-seed an instance based on the given algorithm.
            </summary>
            <remarks>Equivalent to GetInstance(algorithm, true)</remarks>
            <param name="algorithm">e.g. "SHA256PRNG"</param>
        </member>
        <member name="M:Org.BouncyCastle.Security.SecureRandom.GetInstance(System.String,System.Boolean)">
            <summary>
            Create an instance based on the given algorithm, with optional auto-seeding
            </summary>
            <param name="algorithm">e.g. "SHA256PRNG"</param>
            <param name="autoSeed">If true, the instance will be auto-seeded.</param>
        </member>
        <member name="M:Org.BouncyCastle.Security.SecureRandom.#ctor(System.Byte[])">
            <remarks>
            To replicate existing predictable output, replace with GetInstance("SHA1PRNG", false), followed by SetSeed(seed)
            </remarks>
        </member>
        <member name="M:Org.BouncyCastle.Security.SecureRandom.#ctor(Org.BouncyCastle.Crypto.Prng.IRandomGenerator)">
            <summary>Use the specified instance of IRandomGenerator as random source.</summary>
            <remarks>
            This constructor performs no seeding of either the <c>IRandomGenerator</c> or the
            constructed <c>SecureRandom</c>. It is the responsibility of the client to provide
            proper seed material as necessary/appropriate for the given <c>IRandomGenerator</c>
            implementation.
            </remarks>
            <param name="generator">The source to generate all random bytes from.</param>
        </member>
        <member name="M:Org.BouncyCastle.Security.SecurityUtilityException.#ctor">
            base constructor.
        </member>
        <member name="M:Org.BouncyCastle.Security.SecurityUtilityException.#ctor(System.String)">
             create a SecurityUtilityException with the given message.
            
             @param message the message to be carried with the exception.
        </member>
        <member name="T:Org.BouncyCastle.Security.SignerUtilities">
            <summary>
             Signer Utility class contains methods that can not be specifically grouped into other classes.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Security.SignerUtilities.GetObjectIdentifier(System.String)">
            <summary>
            Returns an ObjectIdentifier for a given encoding.
            </summary>
            <param name="mechanism">A string representation of the encoding.</param>
            <returns>A DerObjectIdentifier, null if the OID is not available.</returns>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Arrays">
            <summary> General array utilities.</summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Arrays.AreEqual(System.Byte[],System.Byte[])">
            <summary>
            Are two arrays equal.
            </summary>
            <param name="a">Left side.</param>
            <param name="b">Right side.</param>
            <returns>True if equal.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Arrays.ConstantTimeAreEqual(System.Byte[],System.Byte[])">
            <summary>
            A constant time equals comparison - does not terminate early if
            test will fail.
            </summary>
            <param name="a">first array</param>
            <param name="b">second array</param>
            <returns>true if arrays equal, false otherwise.</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Arrays.CopyOfRange(System.Byte[],System.Int32,System.Int32)">
             Make a copy of a range of bytes from the passed in data array. The range can
             extend beyond the end of the input array, in which case the return array will
             be padded with zeroes.
            
             @param data the array from which the data is to be copied.
             @param from the start index at which the copying should take place.
             @param to the final index of the range (exclusive).
            
             @return a new byte array containing the range given.
        </member>
        <member name="T:Org.BouncyCastle.Utilities.BigIntegers">
            BigInteger utilities.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.BigIntegers.AsUnsignedByteArray(Org.BouncyCastle.Math.BigInteger)">
             Return the passed in value as an unsigned byte array.
            
             @param value value to be converted.
             @return a byte array without a leading zero byte if present in the signed encoding.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.BigIntegers.AsUnsignedByteArray(System.Int32,Org.BouncyCastle.Math.BigInteger)">
             Return the passed in value as an unsigned byte array of specified length, zero-extended as necessary.
            
             @param length desired length of result array.
             @param n value to be converted.
             @return a byte array of specified length, with leading zeroes as necessary given the size of n.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.BigIntegers.CreateRandomInRange(Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Math.BigInteger,Org.BouncyCastle.Security.SecureRandom)">
            Return a random BigInteger not less than 'min' and not greater than 'max'
            
            @param min the least value that may be generated
            @param max the greatest value that may be generated
            @param random the source of randomness
            @return a random BigInteger value in the range [min,max]
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Date.DateTimeUtilities.DateTimeToUnixMs(System.DateTime)">
            <summary>
            Return the number of milliseconds since the Unix epoch (1 Jan., 1970 UTC) for a given DateTime value.
            </summary>
            <param name="dateTime">A UTC DateTime value not before epoch.</param>
            <returns>Number of whole milliseconds after epoch.</returns>
            <exception cref="T:System.ArgumentException">'dateTime' is before epoch.</exception>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Date.DateTimeUtilities.UnixMsToDateTime(System.Int64)">
            <summary>
            Create a DateTime value from the number of milliseconds since the Unix epoch (1 Jan., 1970 UTC).
            </summary>
            <param name="unixMs">Number of milliseconds since the epoch.</param>
            <returns>A UTC DateTime value</returns>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Date.DateTimeUtilities.CurrentUnixMs">
            <summary>
            Return the current number of milliseconds since the Unix epoch (1 Jan., 1970 UTC).
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Encode(System.Byte[])">
             encode the input data producing a base 64 encoded byte array.
            
             @return a byte array containing the base 64 encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Encode(System.Byte[],System.Int32,System.Int32)">
             encode the input data producing a base 64 encoded byte array.
            
             @return a byte array containing the base 64 encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Encode(System.Byte[],System.IO.Stream)">
             Encode the byte data to base 64 writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             Encode the byte data to base 64 writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Decode(System.Byte[])">
             decode the base 64 encoded input data. It is assumed the input data is valid.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Decode(System.String)">
             decode the base 64 encoded string data - whitespace will be ignored.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64.Decode(System.String,System.IO.Stream)">
             decode the base 64 encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.IEncoder">
            Encode and decode byte arrays (typically from binary to 7-bit ASCII
            encodings).
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64Encoder.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             encode the input data producing a base 64 output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64Encoder.Decode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             decode the base 64 encoded byte data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Base64Encoder.DecodeString(System.String,System.IO.Stream)">
             decode the base 64 encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Encoders.Hex">
            <summary>
            Class to decode and encode Hex.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[])">
             encode the input data producing a Hex encoded byte array.
            
             @return a byte array containing the Hex encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[],System.Int32,System.Int32)">
             encode the input data producing a Hex encoded byte array.
            
             @return a byte array containing the Hex encoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[],System.IO.Stream)">
             Hex encode the byte data writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             Hex encode the byte data writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Decode(System.Byte[])">
             decode the Hex encoded input data. It is assumed the input data is valid.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Decode(System.String)">
             decode the Hex encoded string data - whitespace will be ignored.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.Hex.Decode(System.String,System.IO.Stream)">
             decode the Hex encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexEncoder.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             encode the input data producing a Hex output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexEncoder.Decode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             decode the Hex encoded byte data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Encoders.HexEncoder.DecodeString(System.String,System.IO.Stream)">
             decode the Hex encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Pem.PemObjectGenerator.Generate">
            <returns>
            A <see cref="T:Org.BouncyCastle.Utilities.IO.Pem.PemObject"/>
            </returns>
            <exception cref="T:Org.BouncyCastle.Utilities.IO.Pem.PemGenerationException"></exception>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Pem.PemReader.ReadPemObject">
            <returns>
            A <see cref="T:Org.BouncyCastle.Utilities.IO.Pem.PemObject"/>
            </returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.IO.Pem.PemWriter">
            A generic PEM writer, based on RFC 1421
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Pem.PemWriter.#ctor(System.IO.TextWriter)">
             Base constructor.
            
             @param out output stream to use.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Pem.PemWriter.GetOutputSize(Org.BouncyCastle.Utilities.IO.Pem.PemObject)">
             Return the number of bytes or characters required to contain the
             passed in object if it is PEM encoded.
            
             @param obj pem object to be output
             @return an estimate of the number of bytes
        </member>
        <member name="M:Org.BouncyCastle.Utilities.IO.Streams.PipeAllLimited(System.IO.Stream,System.Int64,System.IO.Stream)">
            <summary>
            Pipe all bytes from <c>inStr</c> to <c>outStr</c>, throwing <c>StreamFlowException</c> if greater
            than <c>limit</c> bytes in <c>inStr</c>.
            </summary>
            <param name="inStr">
            A <see cref="T:System.IO.Stream"/>
            </param>
            <param name="limit">
            A <see cref="T:System.Int64"/>
            </param>
            <param name="outStr">
            A <see cref="T:System.IO.Stream"/>
            </param>
            <returns>The number of bytes actually transferred, if not greater than <c>limit</c></returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:Org.BouncyCastle.Utilities.MemoableResetException">
            Exception to be thrown on a failure to reset an object implementing Memoable.
            <p>
            The exception extends InvalidCastException to enable users to have a single handling case,
            only introducing specific handling of this one if required.
            </p>
        </member>
        <member name="M:Org.BouncyCastle.Utilities.MemoableResetException.#ctor(System.String)">
             Basic Constructor.
            
             @param msg message to be associated with this exception.
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Net.IPAddress.IsValid(System.String)">
             Validate the given IPv4 or IPv6 address.
            
             @param address the IP address as a string.
            
             @return true if a valid address, false otherwise
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Net.IPAddress.IsValidWithNetMask(System.String)">
             Validate the given IPv4 or IPv6 address and netmask.
            
             @param address the IP address as a string.
            
             @return true if a valid address with netmask, false otherwise
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Net.IPAddress.IsValidIPv4(System.String)">
             Validate the given IPv4 address.
             
             @param address the IP address as a string.
            
             @return true if a valid IPv4 address, false otherwise
        </member>
        <member name="M:Org.BouncyCastle.Utilities.Net.IPAddress.IsValidIPv6(System.String)">
             Validate the given IPv6 address.
            
             @param address the IP address as a string.
            
             @return true if a valid IPv4 address, false otherwise
        </member>
        <member name="T:Org.BouncyCastle.Utilities.Strings">
            <summary> General string utilities.</summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.IX509Extension.GetCriticalExtensionOids">
            <summary>
            Get all critical extension values, by oid
            </summary>
            <returns>IDictionary with string (OID) keys and Asn1OctetString values</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.IX509Extension.GetNonCriticalExtensionOids">
            <summary>
            Get all non-critical extension values, by oid
            </summary>
            <returns>IDictionary with string (OID) keys and Asn1OctetString values</returns>
        </member>
        <member name="T:Org.BouncyCastle.X509.X509Certificate">
            <summary>
            An Object representing an X509 Certificate.
            Has static methods for loading Certificates encoded in many forms that return X509Certificate Objects.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509ExtensionBase.GetNonCriticalExtensionOids">
            <summary>
            Get non critical extensions.
            </summary>
            <returns>A set of non critical extension oids.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509ExtensionBase.GetCriticalExtensionOids">
            <summary>
            Get any critical extensions.
            </summary>
            <returns>A sorted list of critical entension.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509ExtensionBase.GetExtensionValue(System.String)">
            <summary>
            Get the value of a given extension.
            </summary>
            <param name="oid">The object ID of the extension. </param>
            <returns>An Asn1OctetString object if that extension is found or null if not.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.IsValid(System.DateTime)">
            <summary>
            Return true if the nominated time is within the start and end times nominated on the certificate.
            </summary>
            <param name="time">The time to test validity against.</param>
            <returns>True if certificate is valid for nominated time.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.CheckValidity">
            <summary>
            Checks if the current date is within certificate's validity period.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.CheckValidity(System.DateTime)">
            <summary>
            Checks if the given date is within certificate's validity period.
            </summary>
            <exception cref="T:Org.BouncyCastle.Security.Certificates.CertificateExpiredException">if the certificate is expired by given date</exception>
            <exception cref="T:Org.BouncyCastle.Security.Certificates.CertificateNotYetValidException">if the certificate is not yet valid on given date</exception>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetTbsCertificate">
            <summary>
            Return the Der encoded TbsCertificate data.
            This is the certificate component less the signature.
            To Get the whole certificate call the GetEncoded() member.
            </summary>
            <returns>A byte array containing the Der encoded Certificate component.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetSignature">
            <summary>
            The signature.
            </summary>
            <returns>A byte array containg the signature of the certificate.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetSigAlgParams">
            <summary>
            Get the signature algorithms parameters. (EG DSA Parameters)
            </summary>
            <returns>A byte array containing the Der encoded version of the parameters or null if there are none.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetKeyUsage">
            <summary>
            Get a key usage guidlines.
            </summary>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetPublicKey">
            <summary>
            Get the public key of the subject of the certificate.
            </summary>
            <returns>The public key parameters.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.GetEncoded">
            <summary>
            Return a Der encoded version of this certificate.
            </summary>
            <returns>A byte array.</returns>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Certificate.Verify(Org.BouncyCastle.Crypto.AsymmetricKeyParameter)">
            <summary>
            Verify the certificate's signature using the nominated public key.
            </summary>
            <param name="key">An appropriate public key parameter object, RsaPublicKeyParameters, DsaPublicKeyParameters or ECDsaPublicKeyParameters</param>
            <returns>True if the signature is valid.</returns>
            <exception cref="T:System.Exception">If key submitted is not of the above nominated types.</exception>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.IsValidNow">
            <summary>
            Return true if the current time is within the start and end times nominated on the certificate.
            </summary>
            <returns>true id certificate is valid for the current time.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.Version">
            <summary>
            Return the certificate's version.
            </summary>
            <returns>An integer whose value Equals the version of the cerficate.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.SerialNumber">
            <summary>
            Return a <see cref="T:Org.BouncyCastle.Math.BigInteger">BigInteger</see> containing the serial number.
            </summary>
            <returns>The Serial number.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.IssuerDN">
            <summary>
            Get the Issuer Distinguished Name. (Who signed the certificate.)
            </summary>
            <returns>And X509Object containing name and value pairs.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.SubjectDN">
            <summary>
            Get the subject of this certificate.
            </summary>
            <returns>An X509Name object containing name and value pairs.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.NotBefore">
            <summary>
            The time that this certificate is valid from.
            </summary>
            <returns>A DateTime object representing that time in the local time zone.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.NotAfter">
            <summary>
            The time that this certificate is valid up to.
            </summary>
            <returns>A DateTime object representing that time in the local time zone.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.SigAlgName">
            <summary>
            A meaningful version of the Signature Algorithm. (EG SHA1WITHRSA)
            </summary>
            <returns>A sting representing the signature algorithm.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.SigAlgOid">
            <summary>
            Get the Signature Algorithms Object ID.
            </summary>
            <returns>A string containg a '.' separated object id.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.IssuerUniqueID">
            <summary>
            Get the issuers UID.
            </summary>
            <returns>A DerBitString.</returns>
        </member>
        <member name="P:Org.BouncyCastle.X509.X509Certificate.SubjectUniqueID">
            <summary>
            Get the subjects UID.
            </summary>
            <returns>A DerBitString.</returns>
        </member>
        <member name="T:Org.BouncyCastle.X509.X509CertificateParser">
            class for dealing with X509 certificates.
            <p>
            At the moment this will deal with "-----BEGIN CERTIFICATE-----" to "-----END CERTIFICATE-----"
            base 64 encoded certs, as well as the BER binaries of certificates and some classes of PKCS#7
            objects.</p>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CertificateParser.ReadCertificate(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CertificateParser.ReadCertificates(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CertificateParser.ReadCertificate(System.IO.Stream)">
            Generates a certificate object and initializes it with the data
            read from the input stream inStream.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CertificateParser.ReadCertificates(System.IO.Stream)">
            Returns a (possibly empty) collection view of the certificates
            read from the given input stream inStream.
        </member>
        <member name="T:Org.BouncyCastle.X509.X509Crl">
             The following extensions are listed in RFC 2459 as relevant to CRLs
            
             Authority Key Identifier
             Issuer Alternative Name
             CRL Number
             Delta CRL Indicator (critical)
             Issuing Distribution Point (critical)
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Crl.ToString">
             Returns a string representation of this CRL.
            
             @return a string representation of this CRL.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509Crl.IsRevoked(Org.BouncyCastle.X509.X509Certificate)">
             Checks whether the given certificate is on this CRL.
            
             @param cert the certificate to check for.
             @return true if the given certificate is on this CRL,
             false otherwise.
        </member>
        <member name="T:Org.BouncyCastle.X509.X509CrlEntry">
             The following extensions are listed in RFC 2459 as relevant to CRL Entries
            
             ReasonCode Hode Instruction Code Invalidity Date Certificate Issuer
             (critical)
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CrlEntry.#ctor(Org.BouncyCastle.Asn1.X509.CrlEntry,System.Boolean,Org.BouncyCastle.Asn1.X509.X509Name)">
             Constructor for CRLEntries of indirect CRLs. If <code>isIndirect</code>
             is <code>false</code> {@link #getCertificateIssuer()} will always
             return <code>null</code>, <code>previousCertificateIssuer</code> is
             ignored. If this <code>isIndirect</code> is specified and this CrlEntry
             has no certificate issuer CRL entry extension
             <code>previousCertificateIssuer</code> is returned by
             {@link #getCertificateIssuer()}.
            
             @param c
                        TbsCertificateList.CrlEntry object.
             @param isIndirect
                        <code>true</code> if the corresponding CRL is a indirect
                        CRL.
             @param previousCertificateIssuer
                        Certificate issuer of the previous CrlEntry.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CrlParser.ReadCrl(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CrlParser.ReadCrls(System.Byte[])">
            <summary>
            Create loading data from byte array.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CrlParser.ReadCrl(System.IO.Stream)">
            Generates a certificate revocation list (CRL) object and initializes
            it with the data read from the input stream inStream.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509CrlParser.ReadCrls(System.IO.Stream)">
             Returns a (possibly empty) collection view of the CRLs read from
             the given input stream inStream.
            
             The inStream may contain a sequence of DER-encoded CRLs, or
             a PKCS#7 CRL set.  This is a PKCS#7 SignedData object, with the
             only significant field being crls.  In particular the signature
             and the contents are ignored.
        </member>
        <member name="M:Org.BouncyCastle.X509.X509SignatureUtilities.GetDigestAlgName(Org.BouncyCastle.Asn1.DerObjectIdentifier)">
            Return the digest algorithm using one of the standard JCA string
            representations rather than the algorithm identifier (if possible).
        </member>
        <member name="T:BestHTTP.ServerSentEvents.States">
            <summary>
            Possible states of an EventSource object.
            </summary>
        </member>
        <member name="T:BestHTTP.ServerSentEvents.EventSource">
            <summary>
            http://www.w3.org/TR/eventsource/
            </summary>
        </member>
        <member name="F:BestHTTP.ServerSentEvents.EventSource.EventTable">
            <summary>
            A dictionary to store eventName => delegate mapping.
            </summary>
        </member>
        <member name="F:BestHTTP.ServerSentEvents.EventSource.RetryCount">
            <summary>
            Number of retry attempts made.
            </summary>
        </member>
        <member name="F:BestHTTP.ServerSentEvents.EventSource.RetryCalled">
            <summary>
            When we called the Retry function. We will delay the Open call from here.
            </summary>
        </member>
        <member name="M:BestHTTP.ServerSentEvents.EventSource.Open">
            <summary>
            Start to connect to the remote servr.
            </summary>
        </member>
        <member name="M:BestHTTP.ServerSentEvents.EventSource.Close">
            <summary>
            Start to close the connection.
            </summary>
        </member>
        <member name="M:BestHTTP.ServerSentEvents.EventSource.On(System.String,BestHTTP.ServerSentEvents.OnEventDelegate)">
            <summary>
            With this function an event handler can be subscribed for an event name.
            </summary>
        </member>
        <member name="M:BestHTTP.ServerSentEvents.EventSource.Off(System.String)">
            <summary>
            With this function the event handler can be removed for the given event name.
            </summary>
            <param name="eventName"></param>
        </member>
        <member name="M:BestHTTP.ServerSentEvents.EventSource.OnUpgraded(BestHTTP.HTTPRequest,BestHTTP.HTTPResponse)">
            <summary>
            We are successfully upgraded to the EventSource protocol, we can start to receive and parse the incoming data.
            </summary>
        </member>
        <member name="P:BestHTTP.ServerSentEvents.EventSource.Uri">
            <summary>
            Uri of the remote endpoint.
            </summary>
        </member>
        <member name="P:BestHTTP.ServerSentEvents.EventSource.State">
            <summary>
            Current state of the EventSource object.
            </summary>
        </member>
        <member name="P:BestHTTP.ServerSentEvents.EventSource.ReconnectionTime">
            <summary>
            Time to wait to do a reconnect attempt. Default to 2 sec. The server can overwrite this setting.
            </summary>
        </member>
        <member name="P:BestHTTP.ServerSentEvents.EventSource.LastEventId">
            <summary>
            The last successfully received event's id.
            </summary>
        </member>
        <member name="P:BestHTTP.ServerSentEvents.EventSource.InternalRequest">
            <summary>
            The internal request object of the EventSource.
            </summary>
        </member>
        <member name="E:BestHTTP.ServerSentEvents.EventSource.OnOpen">
            <summary>
            Called when successfully connected to the server.
            </summary>
        </member>
        <member name="E:BestHTTP.ServerSentEvents.EventSource.OnMessage">
            <summary>
            Called on every message received from the server.
            </summary>
        </member>
        <member name="E:BestHTTP.ServerSentEvents.EventSource.OnError">
            <summary>
            Called when an error occures.
            </summary>
        </member>
        <member name="E:BestHTTP.ServerSentEvents.EventSource.OnRetry">
            <summary>
            Called when the EventSource will try to do a retry attempt. If this function returns with false, it will cancel the attempt.
            </summary>
        </member>
        <member name="E:BestHTTP.ServerSentEvents.EventSource.OnClosed">
            <summary>
            Called when the EventSource object closed.
            </summary>
        </member>
        <member name="E:BestHTTP.ServerSentEvents.EventSource.OnStateChanged">
            <summary>
            Called every time when the State property changed.
            </summary>
        </member>
        <member name="T:BestHTTP.ServerSentEvents.EventSourceResponse">
            <summary>
            A low-level class to receive and parse an EventSource(http://www.w3.org/TR/eventsource/) stream.
            Higher level protocol reprezentation is implemented in the EventSource class.
            </summary>
        </member>
        <member name="F:BestHTTP.ServerSentEvents.EventSourceResponse.FrameLock">
            <summary>
            Thread sync object
            </summary>
        </member>
        <member name="F:BestHTTP.ServerSentEvents.EventSourceResponse.LineBuffer">
            <summary>
            Buffer for the read data.
            </summary>
        </member>
        <member name="F:BestHTTP.ServerSentEvents.EventSourceResponse.LineBufferPos">
            <summary>
            Buffer position.
            </summary>
        </member>
        <member name="F:BestHTTP.ServerSentEvents.EventSourceResponse.CurrentMessage">
            <summary>
            The currently receiving and parsing message
            </summary>
        </member>
        <member name="F:BestHTTP.ServerSentEvents.EventSourceResponse.CompletedMessages">
            <summary>
            Completed messages that waiting to be dispatched
            </summary>
        </member>
        <member name="P:BestHTTP.ServerSentEvents.Message.Id">
            <summary>
            Event Id of the message. If it's null, then it's not present.
            </summary>
        </member>
        <member name="P:BestHTTP.ServerSentEvents.Message.Event">
            <summary>
            Name of the event, or an empty string.
            </summary>
        </member>
        <member name="P:BestHTTP.ServerSentEvents.Message.Data">
            <summary>
            The actual payload of the message.
            </summary>
        </member>
        <member name="P:BestHTTP.ServerSentEvents.Message.Retry">
            <summary>
            A reconnection time, in milliseconds. This must initially be a user-agent-defined value, probably in the region of a few seconds.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Authentication.IAuthenticationProvider.StartAuthentication">
            <summary>
            This function called once, when the before the SignalR negotiation begins. If IsPreAuthRequired is false, then this step will be skipped.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Authentication.IAuthenticationProvider.PrepareRequest(BestHTTP.HTTPRequest,BestHTTP.SignalR.RequestTypes)">
            <summary>
            This function will be called for every request before sending it.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Authentication.IAuthenticationProvider.IsPreAuthRequired">
            <summary>
            The authentication must be run before any request made to build up the SignalR protocol
            </summary>
        </member>
        <member name="E:BestHTTP.SignalR.Authentication.IAuthenticationProvider.OnAuthenticationSucceded">
            <summary>
            This event must be called when the pre-authentication succeded. When IsPreAuthRequired is false, no-one will subscribe to this event.
            </summary>
        </member>
        <member name="E:BestHTTP.SignalR.Authentication.IAuthenticationProvider.OnAuthenticationFailed">
            <summary>
            This event must be called when the pre-authentication failed. When IsPreAuthRequired is false, no-one will subscribe to this event.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.IConnection">
            <summary>
            Interface to be able to hide internally used functions and properties.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.Connection">
            <summary>
            The main SignalR class. This is the entry point to connect to a SignalR service.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.DefaultEncoder">
            <summary>
            The default Json encode/decoder that will be used to encode/decode the event arguments.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.SyncRoot">
            <summary>
            An object to be able maintain thread safety.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.ClientProtocol">
            <summary>
            The supported client protocol version.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.RequestCounter">
            <summary>
            Request counter sent with all request for easier debugging.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.LastReceivedMessage">
            <summary>
            Instance of the last received message. Used for its MessageId.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.GroupsToken">
            <summary>
            The GroupsToken sent by the server that stores what groups we are joined to.
            We will send it with the reconnect request.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.BufferedMessages">
            <summary>
            Received messages before the Start request finishes.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.LastMessageReceivedAt">
            <summary>
            When the last message received from the server. Used for reconnecting.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.ReconnectStartedAt">
            <summary>
            When we started to reconnect. When too much time passes without a successful reconnect, we will close the connection.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.LastPingSentAt">
            <summary>
            When the last ping request sent out.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.PingInterval">
            <summary>
            How mutch time we have to wait between two pings.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.PingRequest">
            <summary>
            Reference to the ping request.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.TransportConnectionStartedAt">
            <summary>
            When the transport started the connection process
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.queryBuilder">
            <summary>
            Cached StringBuilder instance used in BuildUri
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.BuiltConnectionData">
            <summary>
            The cached value of the result of the ConnectionData property call.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Connection.BuiltQueryParams">
            <summary>
            The cached value of the result of the QueryParams property call.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.Open">
            <summary>
            This function will start to authenticate if required, and the SignalR protocol negotiation.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.OnAuthenticationSucceded(BestHTTP.SignalR.Authentication.IAuthenticationProvider)">
            <summary>
            Called when the authentication succeded.
            </summary>
            <param name="provider"></param>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.OnAuthenticationFailed(BestHTTP.SignalR.Authentication.IAuthenticationProvider,System.String)">
            <summary>
            Called when the authentication failed.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.StartImpl">
            <summary>
            It's the real Start implementation. It will start the negotiation
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.OnNegotiationDataReceived(BestHTTP.SignalR.NegotiationData)">
            <summary>
            Protocol negotiation finished successfully.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.OnNegotiationError(BestHTTP.SignalR.NegotiationData,System.String)">
            <summary>
            Protocol negotiation failed.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.Close">
            <summary>
            Closes the connection and shuts down the transport.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.Reconnect">
            <summary>
            Initiates a reconnect to the SignalR server.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.Send(System.Object)">
            <summary>
            Will encode the argument to a Json string using the Connection's JsonEncoder, then will send it to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.SendJson(System.String)">
            <summary>
            Sends the given json string to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.BestHTTP#SignalR#IConnection#OnMessage(BestHTTP.SignalR.Messages.IServerMessage)">
            <summary>
            Called when we receive a message from the server
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.BestHTTP#SignalR#IConnection#TransportStarted">
            <summary>
            Called from the transport implementations when the Start request finishes successfully.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.BestHTTP#SignalR#IConnection#TransportReconnected">
            <summary>
            Called when the transport sucessfully reconnected to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.BestHTTP#SignalR#IConnection#TransportAborted">
            <summary>
            Called from the transport implementation when the Abort request finishes successfully.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.BestHTTP#SignalR#IConnection#Error(System.String)">
            <summary>
            Called when an error occures. If the connection is in the Connected state, it will start the reconnect process, otherwise it will close the connection.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.BestHTTP#SignalR#IConnection#BuildUri(BestHTTP.SignalR.RequestTypes)">
            <summary>
            Creates an Uri instance for the given request type.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.BestHTTP#SignalR#IConnection#BuildUri(BestHTTP.SignalR.RequestTypes,BestHTTP.SignalR.Transports.TransportBase)">
            <summary>
            Creates an Uri instance from the given parameters.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.BestHTTP#SignalR#IConnection#PrepareRequest(BestHTTP.HTTPRequest,BestHTTP.SignalR.RequestTypes)">
            <summary>
            It's called on every request before sending it out to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.BestHTTP#SignalR#IConnection#ParseResponse(System.String)">
            <summary>
            Will parse a "{ 'Response': 'xyz' }" object and returns with 'xyz'. If it fails to parse, or getting the 'Response' key, it will call the Error function.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.BestHTTP#Extensions#IHeartbeat#OnHeartbeatUpdate(System.TimeSpan)">
            <summary>
            IHeartbeat implementation to manage timeouts.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.InitOnStart">
            <summary>
            Init function to set the connected states and set up other variables.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.FindHub(System.UInt64)">
            <summary>
            Find and return with a Hub that has the message id.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.TryFallbackTransport">
            <summary>
            Try to fall back to next transport. If no more transport to try, it will return false.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.Ping">
            <summary>
            Sends a Ping request to the SignalR server.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Connection.OnPingRequestFinished(BestHTTP.HTTPRequest,BestHTTP.HTTPResponse)">
            <summary>
            Called when the Ping request finished.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.Uri">
            <summary>
            The base url endpoint where the SignalR service can be found.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.State">
            <summary>
            Current State of the SignalR connection.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.NegotiationResult">
            <summary>
            Result of the nogotiation request from the server.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.Hubs">
            <summary>
            The hubs that the client is connected to.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.Transport">
            <summary>
            The transport that is used to send and receive messages.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.AdditionalQueryParams">
            <summary>
            Additional query parameters that will be passed for the handsake uri. If the value is null, or an empty string it will be not appended to the query only the key.
            <remarks>The keys and values must be escaped properly, as the plugin will not escape these. </remarks>
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.QueryParamsOnlyForHandshake">
            <summary>
            If it's false, the parmateres in the AdditionalQueryParams will be passed for all http requests. Its default value is true.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.JsonEncoder">
            <summary>
            The Json encoder that will be used by the connection and the transport.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.AuthenticationProvider">
            <summary>
            An IAuthenticationProvider implementation that will be used to authenticate the connection.
            </summary>
        </member>
        <member name="E:BestHTTP.SignalR.Connection.OnConnected">
            <summary>
            Called when the protocol is open for communication.
            </summary>
        </member>
        <member name="E:BestHTTP.SignalR.Connection.OnClosed">
            <summary>
            Called when the connection is closed, and no further messages are sent or received.
            </summary>
        </member>
        <member name="E:BestHTTP.SignalR.Connection.OnError">
            <summary>
            Called when an error occures. If the connection is already Started, it will try to do a reconnect, otherwise it will close the connection.
            </summary>
        </member>
        <member name="E:BestHTTP.SignalR.Connection.OnReconnecting">
            <summary>
            This event called when a reconnection attempt are started. If fails to reconnect an OnError and OnClosed events are called.
            </summary>
        </member>
        <member name="E:BestHTTP.SignalR.Connection.OnReconnected">
            <summary>
            This event called when the reconnection attempt succeded.
            </summary>
        </member>
        <member name="E:BestHTTP.SignalR.Connection.OnStateChanged">
            <summary>
            Called every time when the connection's state changes.
            </summary>
        </member>
        <member name="E:BestHTTP.SignalR.Connection.OnNonHubMessage">
            <summary>
            It's called when a non-Hub message received. The data can be anything from primitive types to array of complex objects.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.RequestPreparator">
            <summary>
            With this delegate all requests can be further customized.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.Item(System.Int32)">
            <summary>
            Indexer property the access hubs by index.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.Item(System.String)">
            <summary>
            Indexer property the access hubs by name.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.ClientMessageCounter">
            <summary>
            Unique ID for all message sent by the client.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.Timestamp">
            <summary>
            A timestamp that will be sent with all request for easier debugging.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.ConnectionData">
            <summary>
            Builds and returns with the connection data made from the hub names.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Connection.QueryParams">
            <summary>
            Builds the keys and values from the AdditionalQueryParams to an key=value form. If AdditionalQueryParams is null or empty, it will return an empty string.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.TransportTypes">
            <summary>
            Possible transport types.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.TransportTypes.WebSocket">
            <summary>
            Transport using WebSockets.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.TransportTypes.ServerSentEvents">
            <summary>
            Transport using ServerSentEvents protocol.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.TransportTypes.LongPoll">
            <summary>
            Transport using long-polling requests.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.MessageTypes">
            <summary>
            Server sent message types
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.MessageTypes.KeepAlive">
            <summary>
            An empty json object {} sent by the server to check keep alive.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.MessageTypes.Data">
            <summary>
            A no-hub message that contains data.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.MessageTypes.Multiple">
            <summary>
            A message that can hold multiple data message alongside with other information.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.MessageTypes.Result">
            <summary>
            A method call result.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.MessageTypes.Failure">
            <summary>
            A message about a failed method call.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.MessageTypes.MethodCall">
            <summary>
            A message with all information to be able to call a method on the client.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.MessageTypes.Progress">
            <summary>
            A long running server-method's progress.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.ConnectionStates">
            <summary>
            Possible SignalR Connection states.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.ConnectionStates.Initial">
            <summary>
            The initial state of the connection.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.ConnectionStates.Authenticating">
            <summary>
            The client authenticates itself with the server. This state is skipped if no AuthenticationProvider is present.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.ConnectionStates.Negotiating">
            <summary>
            The client sent out the negotiation request to the server.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.ConnectionStates.Connecting">
            <summary>
            The client received the negotiation data, created the transport and wait's for the transport's connection.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.ConnectionStates.Connected">
            <summary>
            The transport connected and started successfully.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.ConnectionStates.Reconnecting">
            <summary>
            The client started the reconnect process.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.ConnectionStates.Closed">
            <summary>
            The connection is closed.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.RequestTypes">
            <summary>
            Possible types of SignalR requests.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.RequestTypes.Negotiate">
            <summary>
            Request to the /negotiate path to negotiate protocol parameters.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.RequestTypes.Connect">
            <summary>
            Request to the /connect path to connect to the server. With long-polling, it's like a regular poll request.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.RequestTypes.Start">
            <summary>
            Request to the /start path to start the protocol.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.RequestTypes.Poll">
            <summary>
            Request to the /poll path to get new messages. Not used with the WebSocketTransport.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.RequestTypes.Send">
            <summary>
            Request to the /send path to send a message to the server. Not used with the WebSocketTransport.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.RequestTypes.Reconnect">
            <summary>
            Request to the /reconnect path to initiate a reconnection. It's used instead of the Connect type.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.RequestTypes.Abort">
            <summary>
            Request to the /abort path to close the connection.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.RequestTypes.Ping">
            <summary>
            Request to the /ping path to ping the server keeping the asp.net session alive.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.TransportStates">
            <summary>
            Possible states of a transport.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.TransportStates.Initial">
            <summary>
            Initial state
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.TransportStates.Connecting">
            <summary>
            Connecting
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.TransportStates.Reconnecting">
            <summary>
            Reconnecting
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.TransportStates.Starting">
            <summary>
            Sending Start request
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.TransportStates.Started">
            <summary>
            Start request finished successfully
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.TransportStates.Closing">
            <summary>
            Sending Abort request
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.TransportStates.Closed">
            <summary>
            The transport closed after Abort request sent
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.Hubs.Hub">
            <summary>
            Represents a clientside Hub. This class can be used as a base class to encapsulate proxy functionalities.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.Hubs.IHub">
            <summary>
            Interface to be able to hide internally used functions and properties.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Hubs.Hub.SentMessages">
            <summary>
            Table of the sent messages. These messages will be removed from this table when a Result message is received from the server.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Hubs.Hub.MethodTable">
            <summary>
            Methodname -> callback delegete mapping. This table stores the server callable functions.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Hubs.Hub.builder">
            <summary>
            A reusable StringBuilder to save some GC allocs
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Hubs.Hub.On(System.String,BestHTTP.SignalR.Hubs.OnMethodCallCallbackDelegate)">
            <summary>
            Registers a callback function to the given method.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Hubs.Hub.Off(System.String)">
            <summary>
            Removes callback from the given method.
            </summary>
            <param name="method"></param>
        </member>
        <member name="M:BestHTTP.SignalR.Hubs.Hub.Call(System.String,System.Object[])">
            <summary>
            Orders the server to call a method with the given arguments.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Hubs.Hub.Call(System.String,BestHTTP.SignalR.Hubs.OnMethodResultDelegate,System.Object[])">
            <summary>
            Orders the server to call a method with the given arguments.
            The onResult callback will be called when the server successfully called the function.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Hubs.Hub.Call(System.String,BestHTTP.SignalR.Hubs.OnMethodResultDelegate,BestHTTP.SignalR.Hubs.OnMethodFailedDelegate,System.Object[])">
            <summary>
            Orders the server to call a method with the given arguments.
            The onResult callback will be called when the server successfully called the function.
            The onResultError will be called when the server can't call the function, or when the function throws an exception.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Hubs.Hub.Call(System.String,BestHTTP.SignalR.Hubs.OnMethodResultDelegate,BestHTTP.SignalR.Hubs.OnMethodProgressDelegate,System.Object[])">
            <summary>
            Orders the server to call a method with the given arguments.
            The onResult callback will be called when the server successfully called the function.
            The onProgress callback called multiple times when the method is a long runnning function and reports back its progress.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Hubs.Hub.Call(System.String,BestHTTP.SignalR.Hubs.OnMethodResultDelegate,BestHTTP.SignalR.Hubs.OnMethodFailedDelegate,BestHTTP.SignalR.Hubs.OnMethodProgressDelegate,System.Object[])">
            <summary>
            Orders the server to call a method with the given arguments.
            The onResult callback will be called when the server successfully called the function.
            The onResultError will be called when the server can't call the function, or when the function throws an exception.
            The onProgress callback called multiple times when the method is a long runnning function and reports back its progress.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Hubs.Hub.BestHTTP#SignalR#Hubs#IHub#HasSentMessageId(System.UInt64)">
            <summary>
            Return true if this hub sent the message with the given id.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Hubs.Hub.BestHTTP#SignalR#Hubs#IHub#Close">
            <summary>
            Called on the manager's close. 
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Hubs.Hub.BestHTTP#SignalR#Hubs#IHub#OnMethod(BestHTTP.SignalR.Messages.MethodCallMessage)">
            <summary>
            Called when the client receives an order to call a hub-function.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Hubs.Hub.BestHTTP#SignalR#Hubs#IHub#OnMessage(BestHTTP.SignalR.Messages.IServerMessage)">
            <summary>
            Called when the client receives back messages as a result of a server method call.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Hubs.Hub.MergeState(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Merges the current and the new states.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Hubs.Hub.BuildMessage(BestHTTP.SignalR.Messages.ClientMessage)">
            <summary>
            Builds a JSon string from the given message.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Hubs.Hub.Name">
            <summary>
            Name of this hub.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Hubs.Hub.State">
            <summary>
            Server and user set state of the hub.
            </summary>
        </member>
        <member name="E:BestHTTP.SignalR.Hubs.Hub.OnMethodCall">
            <summary>
            Event called every time when the server sends an order to call a method on the client.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.JsonEncoders.IJsonEncoder">
            <summary>
            Interface to be able to write custom Json encoders/decoders.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.JsonEncoders.IJsonEncoder.Encode(System.Object)">
            <summary>
            This function must create a json formatted string from the given object. If the encoding fails, it should return null.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.JsonEncoders.IJsonEncoder.DecodeMessage(System.String)">
            <summary>
            This function must create a dictionary the Json formatted string parameter. If the decoding fails, it should return null.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.Messages.ClientMessage">
            <summary>
            This struct represents a message from the client.
            It holds every data and reference needed to construct the string represented message that will be sent to the wire.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Messages.ClientMessage.Hub">
            <summary>
            Reference to the source Hub. The Name and the State of the hub will be user.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Messages.ClientMessage.Method">
            <summary>
            Name of the method on the server to be called.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Messages.ClientMessage.Args">
            <summary>
            Arguments of the method.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Messages.ClientMessage.CallIdx">
            <summary>
            Unique id on the client of this message
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Messages.ClientMessage.ResultCallback">
            <summary>
            The delegate that will be called when the server will sends a result of this method call.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Messages.ClientMessage.ResultErrorCallback">
            <summary>
            The delegate that will be called when the server sends an error-result to this method call.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Messages.ClientMessage.ProgressCallback">
            <summary>
            The delegate that will be called when the server sends a progress message to this method call.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.Messages.KeepAliveMessage">
            <summary>
            Keep-alive message sent by the server. No data sent with it.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.Messages.MultiMessage">
            <summary>
            A message that may contains multiple sub-messages and additional informations.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.MultiMessage.MessageId">
            <summary>
            Id of the sent message
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.MultiMessage.IsInitialization">
            <summary>
            True if it's an initialization message, false otherwise.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.MultiMessage.GroupsToken">
            <summary>
            Group token may be sent, if the group changed that the client belongs to.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.MultiMessage.ShouldReconnect">
            <summary>
            The server suggests that the client should do a reconnect turn.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.MultiMessage.PollDelay">
            <summary>
            Additional poll deleay sent by the server.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.MultiMessage.Data">
            <summary>
            List of server messages sent inside this message.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.Messages.DataMessage">
            <summary>
            A simple non-hub data message. It holds only one Data property.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.Messages.MethodCallMessage">
            <summary>
            A Hub message that orders the client to call a method.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.MethodCallMessage.Hub">
            <summary>
            The name of the Hub that the method is called on.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.MethodCallMessage.Method">
            <summary>
            Name of the Method.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.MethodCallMessage.Arguments">
            <summary>
            Arguments of the method call.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.MethodCallMessage.State">
            <summary>
            State changes of the hub. It's handled automatically by the Hub.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.Messages.ResultMessage">
            <summary>
            Message of a server side method invocation result.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.ResultMessage.InvocationId">
            <summary>
            The unique id that the client set when called the server side method. Used by the plugin to deliver this message to the good Hub.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.ResultMessage.ReturnValue">
            <summary>
            The return value of the server side method call, or null if the method's return type is void.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.ResultMessage.State">
            <summary>
            State changes of the hub. It's handled automatically by the Hub.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.FailureMessage.InvocationId">
            <summary>
            The unique id that the client set when called the server side method. Used by the plugin to deliver this message to the good Hub.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.FailureMessage.IsHubError">
            <summary>
            True if it's a hub error.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.FailureMessage.ErrorMessage">
            <summary>
            If the method call failed, it contains the error message to detail what happened.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.FailureMessage.AdditionalData">
            <summary>
            A dictionary that may contain additional error data (can only be present for hub errors). It can be null.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.FailureMessage.StackTrace">
            <summary>
            Stack trace of the error. It present only if detailed error reporting is turned on on the server (https://msdn.microsoft.com/en-us/library/microsoft.aspnet.signalr.hubconfiguration.enabledetailederrors%28v=vs.118%29.aspx).
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.FailureMessage.State">
            <summary>
            State changes of the hub. It's handled automatically by the Hub.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.Messages.ProgressMessage">
            <summary>
            When a server method is a long running method the server can send the information about the progress of execution of the method to the client.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.ProgressMessage.InvocationId">
            <summary>
            The unique id that the client set when called the server side method. Used by the plugin to deliver this message to the good Hub.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Messages.ProgressMessage.Progress">
            <summary>
            Current progress of the long running method.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.NegotiationData.OnReceived">
            <summary>
            Event handler that called when the negotiation data received and parsed successfully.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.NegotiationData.OnError">
            <summary>
            Event handler that called when an error happens.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.NegotiationData.Start">
            <summary>
            Start to get the negotiation data.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.NegotiationData.Abort">
            <summary>
            Abort the negotiation request.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.NegotiationData.Url">
            <summary>
            Path to the SignalR endpoint. Currently not used by the client.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.NegotiationData.WebSocketServerUrl">
            <summary>
            WebSocket endpoint.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.NegotiationData.ConnectionToken">
            <summary>
            Connection token assigned by the server. See this article for more details: http://www.asp.net/signalr/overview/security/introduction-to-security#connectiontoken.
            This value needs to be sent in each subsequent request as the value of the connectionToken parameter
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.NegotiationData.ConnectionId">
            <summary>
            The id of the connection.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.NegotiationData.KeepAliveTimeout">
            <summary>
            The amount of time in seconds the client should wait before attempting to reconnect if it has not received a keep alive message.
            If the server is configured to not send keep alive messages this value is null.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.NegotiationData.DisconnectTimeout">
            <summary>
            The amount of time within which the client should try to reconnect if the connection goes away.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.NegotiationData.ConnectionTimeout">
            <summary>
            Timeout of poll requests.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.NegotiationData.TryWebSockets">
            <summary>
            Whether the server supports websockets.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.NegotiationData.ProtocolVersion">
            <summary>
            The version of the protocol used for communication.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.NegotiationData.TransportConnectTimeout">
            <summary>
            The maximum amount of time the client should try to connect to the server using a given transport.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.NegotiationData.LongPollDelay">
            <summary>
            The wait time before restablishing a long poll connection after data is sent from the server. The default value is 0.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.Transports.PostSendTransportBase">
            <summary>
            A base class for implementations that must send the data in unique requests. These are currently the LongPolling and ServerSentEvents transports.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.TransportBase.Connect">
            <summary>
            Start to connect to the server
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.TransportBase.Stop">
            <summary>
            Stop the connection
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.TransportBase.SendImpl(System.String)">
            <summary>
            The transport specific implementation to send the given json string to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.TransportBase.Started">
            <summary>
            Called when the Start request finished successfully, or after a reconnect.
            Manager.TransportOpened(); called from the TransportBase after this call
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.TransportBase.Aborted">
            <summary>
            Called when the abort request finished successfully.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.TransportBase.OnConnected">
            <summary>
            Called after a succesful connect/reconnect. The transport implementations have to call this function.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.TransportBase.Start">
            <summary>
            Sends out the /start request to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.TransportBase.Abort">
            <summary>
            Will abort the transport. In SignalR 'Abort'ing is a graceful process, while 'Close'ing is a hard-abortion...
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.TransportBase.Send(System.String)">
            <summary>
            Sends the given json string to the wire.
            </summary>
            <param name="jsonStr"></param>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.TransportBase.Reconnect">
            <summary>
            Start the reconnect process
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.TransportBase.Parse(BestHTTP.SignalR.JsonEncoders.IJsonEncoder,System.String)">
            <summary>
            When the json string is successfully parsed will return with an IServerMessage implementation.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Transports.TransportBase.Name">
            <summary>
            Name of the transport.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Transports.TransportBase.SupportsKeepAlive">
            <summary>
            True if the manager has to check the last message received time and reconnect if too much time passes.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Transports.TransportBase.Type">
            <summary>
            Type of the transport. Used mainly by the manager in its BuildUri function.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Transports.TransportBase.Connection">
            <summary>
            Reference to the manager.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Transports.TransportBase.State">
            <summary>
            The current state of the transport.
            </summary>
        </member>
        <member name="E:BestHTTP.SignalR.Transports.TransportBase.OnStateChanged">
            <summary>
            Thi event called when the transport's State set to a new value.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Transports.PostSendTransportBase.sendRequestQueue">
            <summary>
            Sent out send requests. Keeping a reference to them for future use.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Transports.PollingTransport.LastPoll">
            <summary>
            When we received the last poll.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Transports.PollingTransport.PollDelay">
            <summary>
            How much time we have to wait before we can send out a new poll request. This value sent by the server.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Transports.PollingTransport.PollTimeout">
            <summary>
            How much time we wait to a poll request to finish. It's value is the server sent negotiation's ConnectionTimeout + 10sec.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Transports.PollingTransport.pollRequest">
            <summary>
            Reference to the the current poll request.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.PollingTransport.Connect">
            <summary>
            Polling transport specific connection logic. It's a regular GET request to the /connect path.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.PollingTransport.Poll">
            <summary>
            Polling transport speficic function. Sends a GET request to the /poll path to receive messages.
            </summary>
        </member>
        <member name="T:BestHTTP.SignalR.Transports.ServerSentEventsTransport">
            <summary>
            A SignalR transport implementation that uses the Server-Sent Events protocol.
            </summary>
        </member>
        <member name="F:BestHTTP.SignalR.Transports.ServerSentEventsTransport.EventSource">
            <summary>
            The EventSource object.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.ServerSentEventsTransport.Abort">
            <summary>
            A custom Abort function where we will start to close the EventSource object.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Transports.ServerSentEventsTransport.SupportsKeepAlive">
            <summary>
            It's a persistent connection. We support the keep-alive mechanism.
            </summary>
        </member>
        <member name="P:BestHTTP.SignalR.Transports.ServerSentEventsTransport.Type">
            <summary>
            Type of the transport.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.WebSocketTransport.Connect">
            <summary>
            Websocket transport specific connection logic. It will create a WebSocket instance, and starts to connect to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.SignalR.Transports.WebSocketTransport.Aborted">
            <summary>
            The /abort request successfully finished
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.TransportEventTypes">
            <summary>
            Possible event types on the transport level.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.SocketIOEventTypes">
            <summary>
            Event types of the SocketIO protocol.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOEventTypes.Connect">
            <summary>
            Connect to a napespace, or we connected to a namespace
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOEventTypes.Disconnect">
            <summary>
            Disconnect a namespace, or we disconnected from a namespace.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOEventTypes.Event">
            <summary>
            A general event. The event's name is in the payload.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOEventTypes.Ack">
            <summary>
            Acknowledgement of an event.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOEventTypes.Error">
            <summary>
            Error sent by the server, or by the plugin
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOEventTypes.BinaryEvent">
            <summary>
            A general event with binary attached to the packet. The event's name is in the payload.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOEventTypes.BinaryAck">
            <summary>
            Acknowledgement of a binary event.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.SocketIOErrors">
            <summary>
            Possible error codes that the SocketIO server can send.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOErrors.UnknownTransport">
            <summary>
            Transport unknown
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOErrors.UnknownSid">
            <summary>
            Session ID unknown
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOErrors.BadHandshakeMethod">
            <summary>
            Bad handshake method
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOErrors.BadRequest">
            <summary>
            Bad request
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOErrors.Internal">
            <summary>
            Plugin internal error!
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketIOErrors.User">
            <summary>
            Exceptions that caught by the plugin but raised in a user code.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.Events.EventDescriptor">
            <summary>
            A class to describe an event, and its metadatas.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Events.EventDescriptor.CallbackArray">
            <summary>
            Cache an array on a hot-path.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventDescriptor.#ctor(System.Boolean,System.Boolean,BestHTTP.SocketIO.Events.SocketIOCallback)">
            <summary>
            Constructor to create an EventDescriptor instance and set the meta-datas.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventDescriptor.Call(BestHTTP.SocketIO.Socket,BestHTTP.SocketIO.Packet,System.Object[])">
            <summary>
            Will call the callback delegates with the given parameters and remove the callbacks if this descriptor marked with a true OnlyOnce property.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Events.EventDescriptor.Callbacks">
            <summary>
            List of callback delegates.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Events.EventDescriptor.OnlyOnce">
            <summary>
            If this property is true, callbacks are removed automatically after the event dispatch.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Events.EventDescriptor.AutoDecodePayload">
            <summary>
            If this property is true, the dispatching packet's Payload will be decoded using the Manager's Encoder.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.Events.EventNames">
            <summary>
            Helper class to provide functions to an easy Enum->string conversation of the transport and SocketIO evenet types.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventNames.IsBlacklisted(System.String)">
            <summary>
            Checks an event name whether it's blacklisted or not.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.Events.EventTable">
            <summary>
            This class helps keep track and maintain EventDescriptor instances and dispatching packets to the right delegates.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Events.EventTable.Table">
            <summary>
            The 'EventName -> List of events' mapping.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventTable.#ctor(BestHTTP.SocketIO.Socket)">
            <summary>
            Constructor to create an instance and bind it to a socket.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventTable.Register(System.String,BestHTTP.SocketIO.Events.SocketIOCallback,System.Boolean,System.Boolean)">
            <summary>
            Register a callback to a name with the given metadata.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventTable.Unregister(System.String)">
            <summary>
            Removes all events that registered for the given name.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventTable.Unregister(System.String,BestHTTP.SocketIO.Events.SocketIOCallback)">
            <summary>
            
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventTable.Call(System.String,BestHTTP.SocketIO.Packet,System.Object[])">
            <summary>
            Will call the delegates that associated to the given eventName.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventTable.Call(BestHTTP.SocketIO.Packet)">
            <summary>
            This function will get the eventName from the packet's Payload, and optionally will decode it from Json.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventTable.Clear">
            <summary>
            Remove all event -> delegate association.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Events.EventTable.ShouldDecodePayload(System.String)">
            <summary>
            Returns true, if for the given event name there are at least one event that needs a decoded 
            </summary>
            <param name="eventName"></param>
            <returns></returns>
        </member>
        <member name="P:BestHTTP.SocketIO.Events.EventTable.Socket">
            <summary>
            The Socket that this EventTable is bound to.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.HandshakeData">
            <summary>
            This class able to fill it's properties by starting a HTTP request and parsing its result. After a successfull response it will store the parsed data.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.HandshakeData.OnReceived">
            <summary>
            Event handler that called when the handshake data received and parsed successfully.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.HandshakeData.OnError">
            <summary>
            Event handler that called when an error happens.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.HandshakeData.Start">
            <summary>
            Internal function, this will start a regular GET request to the server to receive the handshake data.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.HandshakeData.Abort">
            <summary>
            Internal function to be able to abort the request if necessary.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.HandshakeData.OnHandshakeCallback(BestHTTP.HTTPRequest,BestHTTP.HTTPResponse)">
            <summary>
            Private event handler that called when the handshake request finishes.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.HandshakeData.Sid">
            <summary>
            Session ID of this connection.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.HandshakeData.Upgrades">
            <summary>
            List of possible updgrades.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.HandshakeData.PingInterval">
            <summary>
            What interval we have to set a ping message.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.HandshakeData.PingTimeout">
            <summary>
            What time have to pass without an answer to our ping request when we can consider the connection disconnected.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.HandshakeData.Manager">
            <summary>
            The SocketManager instance that this handshake data is bound to.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.IManager">
            <summary>
            Interface to hide internal functions from the user by implementing it as an explicit interface.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.ISocket">
            <summary>
            Interface to hide internal functions from the user by implementing it as an explicit interface.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.JsonEncoders.DefaultJSonEncoder">
            <summary>
            The default IJsonEncoder implementation. It's uses the Json class from the BestHTTP.JSON namespace to encode and decode.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.JsonEncoders.IJsonEncoder">
            <summary>
            Interface to be able to write custom Json encoders/decoders.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.JsonEncoders.IJsonEncoder.Decode(System.String)">
            <summary>
            The Decode function must create a list of objects from the Json formatted string parameter. If the decoding fails, it should return null.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.JsonEncoders.IJsonEncoder.Encode(System.Collections.Generic.List{System.Object})">
            <summary>
            The Encode function must create a json formatted string from the parameter. If the encoding fails, it should return null.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.#ctor">
            <summary>
            Internal constructor. Don't use it directly!
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.#ctor(System.String)">
            <summary>
            Internal constructor. Don't use it directly!
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.#ctor(BestHTTP.SocketIO.TransportEventTypes,BestHTTP.SocketIO.SocketIOEventTypes,System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Internal constructor. Don't use it directly!
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.DecodeEventName">
            <summary>
            Will set and return with the EventName from the packet's Payload string.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.ReconstructAttachmentAsIndex">
            <summary>
            Will switch the "{'_placeholder':true,'num':X}" to a the index num X.
            </summary>
            <returns>True if successfully reconstructed, false otherwise.</returns>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.ReconstructAttachmentAsBase64">
            <summary>
            Will switch the "{'_placeholder':true,'num':X}" to a the data as a base64 encoded string.
            </summary>
            <returns>True if successfully reconstructed, false otherwise.</returns>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.Parse(System.String)">
            <summary>
            Parse the packet from a server sent textual data. The Payload will be the raw json string.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.Encode">
            <summary>
            Encodes this packet to a Socket.IO formatted string.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.EncodeBinary">
            <summary>
            Encodes this packet to a Socket.IO formatted byte array.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.AddAttachmentFromServer(System.Byte[],System.Boolean)">
            <summary>
            Will add the byte[] that the server sent to the attachments list.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.EncodeData(System.Byte[],BestHTTP.SocketIO.Packet.PayloadTypes,System.Byte[])">
            <summary>
            Encodes a byte array to a Socket.IO binary encoded message
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.PlaceholderReplacer(System.Action{System.String,System.Collections.Generic.Dictionary{System.String,System.Object}})">
            <summary>
            Searches for the "{'_placeholder':true,'num':X}" string, and will call the given action to modify the PayLoad
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.ToString">
            <summary>
            Returns with the Payload of this packet.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Packet.Clone">
            <summary>
            Will clone this packet to an identical packet instance.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.TransportEvent">
            <summary>
            Event type of this packet on the transport layer.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.SocketIOEvent">
            <summary>
            The packet's type in the Socket.IO protocol.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.AttachmentCount">
            <summary>
            How many attachment should have this packet.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.Id">
            <summary>
            The internal ack-id of this packet.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.Namespace">
            <summary>
            The sender namespace's name.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.Payload">
            <summary>
            The payload as a Json string.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.EventName">
            <summary>
            The decoded event name from the payload string.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.Attachments">
            <summary>
            All binary data attached to this event.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.HasAllAttachment">
            <summary>
            Property to check whether all attachments are received to this packet.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.IsDecoded">
            <summary>
            True if it's already decoded. The DecodedArgs still can be null after the Decode call.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Packet.DecodedArgs">
            <summary>
            The decoded arguments from the result of a Json string -> c# object convert.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.Socket">
            <summary>
            This class represents a Socket.IO namespace.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Socket.AckCallbacks">
            <summary>
            A table to store acknowlegement callbacks associated to the given ids.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Socket.EventCallbacks">
            <summary>
            Tha callback table that helps this class to manage event subsciption and dispatching events.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Socket.arguments">
            <summary>
            Cached list to spare some GC alloc.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.#ctor(System.String,BestHTTP.SocketIO.SocketManager)">
            <summary>
            Internal constructor.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.BestHTTP#SocketIO#ISocket#Open">
            <summary>
            Internal function to start opening the socket.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.Disconnect">
            <summary>
            Disconnects this socket/namespace.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.BestHTTP#SocketIO#ISocket#Disconnect(System.Boolean)">
            <summary>
            Disconnects this socket/namespace.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.On(System.String,BestHTTP.SocketIO.Events.SocketIOCallback)">
            <summary>
            Register a callback for a given name
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.Off">
            <summary>
            Remove all callbacks for all events.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.Off(System.String)">
            <summary>
            Removes all callbacks to the given event.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.Off(BestHTTP.SocketIO.SocketIOEventTypes)">
            <summary>
            Removes all callbacks to the given event.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.Off(System.String,BestHTTP.SocketIO.Events.SocketIOCallback)">
            <summary>
            Remove the specified callback.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.Off(BestHTTP.SocketIO.SocketIOEventTypes,BestHTTP.SocketIO.Events.SocketIOCallback)">
            <summary>
            Remove the specified callback.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.BestHTTP#SocketIO#ISocket#OnPacket(BestHTTP.SocketIO.Packet)">
            <summary>
            Last call of the OnPacket chain(Transport -> Manager -> Socket), we will dispatch the event if there is any callback
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.BestHTTP#SocketIO#ISocket#EmitEvent(BestHTTP.SocketIO.SocketIOEventTypes,System.Object[])">
            <summary>
            Emits an internal packet-less event to the user level.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.BestHTTP#SocketIO#ISocket#EmitEvent(System.String,System.Object[])">
            <summary>
            Emits an internal packet-less event to the user level.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Socket.OnTransportOpen(BestHTTP.SocketIO.Socket,BestHTTP.SocketIO.Packet,System.Object[])">
            <summary>
            Called when a "connect" event received to the root namespace
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Socket.Manager">
            <summary>
            The SocketManager instance that created this socket.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Socket.Namespace">
            <summary>
            The namespace that this socket is bound to.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Socket.IsOpen">
            <summary>
            True if the socket is connected and open to the server. False otherwise.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Socket.AutoDecodePayload">
            <summary>
            While this property is True, the socket will decode the Packet's Payload data using the parent SocketManager's Encoder. You must set this property before any event subsciption! It's default value is True;
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.MinProtocolVersion">
            <summary>
            Supported Socket.IO protocol version
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.DefaultEncoder">
            <summary>
            The default Json encode/decoder that will be used to encode/decode the event arguments.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.Namespaces">
            <summary>
            Namespace name -> Socket mapping
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.Sockets">
            <summary>
            List of the sockets to able to iterate over them easily.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.OfflinePackets">
            <summary>
            List of unsent packets. Only instantiated when we have to use it.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.LastHeartbeat">
            <summary>
            When we sent out the last heartbeat(Ping) message.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.LastPongReceived">
            <summary>
            When we received the last Pong message answering to our heartbeat(Ping) message.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.ReconnectAt">
            <summary>
            When we have to try to do a reconnect attempt
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.ConnectionStarted">
            <summary>
            When we started to connect to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.#ctor(System.Uri)">
            <summary>
            Constructor to create a SocketManager instance that will connect to the given uri.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.#ctor(System.Uri,BestHTTP.SocketIO.SocketOptions)">
            <summary>
            Constructor to create a SocketManager instance.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.GetSocket">
            <summary>
            Returns with the "/" namespace, the same as the Socket property.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.GetSocket(System.String)">
            <summary>
            Returns with the specified namespace
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.BestHTTP#SocketIO#IManager#Remove(BestHTTP.SocketIO.Socket)">
            <summary>
            Internal function to remove a Socket instance from this manager.
            </summary>
            <param name="socket"></param>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.Open">
            <summary>
            This function will begin to open the Socket.IO connection by sending out the handshake request.
            If the Options' AutoConnect is true, it will be called automatically.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.BestHTTP#SocketIO#IManager#Close(System.Boolean)">
            <summary>
            Closes this Socket.IO connection.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.BestHTTP#SocketIO#IManager#TryToReconnect">
            <summary>
            Called from a ITransport implemetation when an error occures and we may have to try to reconnect.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.CreateTransports">
            <summary>
            Creates and starts opening/upgrading process of the transports.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.BestHTTP#SocketIO#IManager#OnTransportConnected(BestHTTP.SocketIO.Transports.ITransport)">
            <summary>
            Called by transports when they are connected to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.SelectTransport">
            <summary>
            Select the best transport to send out packets.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.SendOfflinePackets">
            <summary>
            Will select the best transport and sends out all packets that are in the OfflinePackets list.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.BestHTTP#SocketIO#IManager#SendPacket(BestHTTP.SocketIO.Packet)">
            <summary>
            Internal function that called from the Socket class. It will send out the packet instantly, or if no transport is available it will store
            the packet in the OfflinePackets list.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.BestHTTP#SocketIO#IManager#OnPacket(BestHTTP.SocketIO.Packet)">
            <summary>
            Called from the currently operating Transport. Will pass forward to the Socket that has to call the callbacks.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.EmitAll(System.String,System.Object[])">
            <summary>
            Sends an event to all available namespaces.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.BestHTTP#SocketIO#IManager#EmitEvent(System.String,System.Object[])">
            <summary>
            Emits an internal packet-less event to the root namespace without creating it if it isn't exists yet.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.BestHTTP#SocketIO#IManager#EmitEvent(BestHTTP.SocketIO.SocketIOEventTypes,System.Object[])">
            <summary>
            Emits an internal packet-less event to the root namespace without creating it if it isn't exists yet.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketManager.BestHTTP#Extensions#IHeartbeat#OnHeartbeatUpdate(System.TimeSpan)">
            <summary>
            Called from the HTTPManager's OnUpdate function every frame. It's main function is to send out heartbeat messages.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.State">
            <summary>
            The current state of this Socket.IO manager.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.Options">
            <summary>
            The SocketOptions instance that this manager will use.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.Uri">
            <summary>
            The Uri to the Socket.IO endpoint.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.Handshake">
            <summary>
            The server sent and parsed Handshake data.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.Transport">
            <summary>
            The currently used main transport instance.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.RequestCounter">
            <summary>
            The Request counter for request-based transports.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.Socket">
            <summary>
            The root("/") Socket.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.Item(System.String)">
            <summary>
            Indexer to access socket associated to the given namespace.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.ReconnectAttempts">
            <summary>
            How many reconnect attempts made.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.Encoder">
            <summary>
            The JSon encoder that will be used to encode the sent data to json and decode the received json to an object list.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.Timestamp">
            <summary>
            Timestamp support to the request based transports.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.NextAckId">
            <summary>
            Autoincrementing property to return Ack ids.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketManager.PreviousState">
            <summary>
            Internal property to store the previous state of the manager.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.SocketManager.States">
            <summary>
            Possible states of a SocketManager instance.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.States.Initial">
            <summary>
            Initial state of the SocketManager
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.States.Closed">
            <summary>
            The SocketManager is closed, initiated by the user or by the server
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.States.Opening">
            <summary>
            The SocketManager is currently opening.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.States.Open">
            <summary>
            The SocketManager is open, events can be sent to the server.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketManager.States.Reconnecting">
            <summary>
            An error occured, the SocketManager now trying to connect again to the server.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.SocketOptions.BuiltQueryParams">
            <summary>
            The cached value of the result of the BuildQueryParams() call.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketOptions.#ctor">
            <summary>
            Constructor, setting the default option values.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.SocketOptions.BuildQueryParams">
            <summary>
            Builds the keys and values from the AdditionalQueryParams to an key=value form. If AdditionalQueryParams is null or empty, it will return an empty string.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketOptions.Reconnection">
            <summary>
            Whether to reconnect automatically after a disconnect (default true)
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketOptions.ReconnectionAttempts">
            <summary>
            Number of attempts before giving up (default Int.MaxValue)
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketOptions.ReconnectionDelay">
            <summary>
            How long to initially wait before attempting a new reconnection (default 1000ms).
            Affected by +/- RandomizationFactor, for example the default initial delay will be between 500ms to 1500ms.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketOptions.ReconnectionDelayMax">
            <summary>
            Maximum amount of time to wait between reconnections (default 5000ms).
            Each attempt increases the reconnection delay along with a randomization as above.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketOptions.RandomizationFactor">
            <summary>
            (default 0.5`), [0..1]
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketOptions.Timeout">
            <summary>
            Connection timeout before a connect_error and connect_timeout events are emitted (default 20000ms)
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketOptions.AutoConnect">
            <summary>
            By setting this false, you have to call SocketManager's Open() whenever you decide it's appropriate.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketOptions.AdditionalQueryParams">
            <summary>
            Additional query parameters that will be passed for the handsake uri. If the value is null, or an empty string it will be not appended to the query only the key.
            <remarks>The keys and values must be escaped properly, as the plugin will not escape these. </remarks>
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.SocketOptions.QueryParamsOnlyForHandshake">
            <summary>
            If it's false, the parmateres in the AdditionalQueryParams will be passed for all http requests. Its default value is true.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.Transports.TransportStates">
            <summary>
            Possible states of an ITransport implementation.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Transports.TransportStates.Connecting">
            <summary>
            The transport is connecting to the server.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Transports.TransportStates.Opening">
            <summary>
            The transport is connected, and started the opening process.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Transports.TransportStates.Open">
            <summary>
            The transport is open, can send and receive packets.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Transports.TransportStates.Closed">
            <summary>
            The transport is closed.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Transports.TransportStates.Paused">
            <summary>
            The transport is paused.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.Transports.ITransport">
            <summary>
            An interface that a Socket.IO transport must implement.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.ITransport.Open">
            <summary>
            Start open/upgrade the transport.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.ITransport.Poll">
            <summary>
            Do a poll for available messages on the server.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.ITransport.Send(BestHTTP.SocketIO.Packet)">
            <summary>
            Send a single packet to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.ITransport.Send(System.Collections.Generic.List{BestHTTP.SocketIO.Packet})">
            <summary>
            Send a list of packets to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.ITransport.Close">
            <summary>
            Close this transport.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Transports.ITransport.State">
            <summary>
            Current state of the transport
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Transports.ITransport.Manager">
            <summary>
            SocketManager instance that this transport is bound to.
            </summary>
        </member>
        <member name="P:BestHTTP.SocketIO.Transports.ITransport.IsRequestInProgress">
            <summary>
            True if the transport is busy with sending messages.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Transports.PollingTransport.LastRequest">
            <summary>
            The last POST request we sent to the server.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Transports.PollingTransport.PollRequest">
            <summary>
            Last GET request we sent to the server.
            </summary>
        </member>
        <member name="F:BestHTTP.SocketIO.Transports.PollingTransport.PacketWithAttachment">
            <summary>
            The last packet with expected binary attachments
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.PollingTransport.Close">
            <summary>
            Closes the transport and cleans up resources.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.PollingTransport.OnPacket(BestHTTP.SocketIO.Packet)">
            <summary>
            Preprocessing and sending out packets to the manager.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.PollingTransport.ParseResponse(BestHTTP.HTTPResponse)">
            <summary>
            Will parse the response, and send out the parsed packets.
            </summary>
        </member>
        <member name="T:BestHTTP.SocketIO.Transports.WebSocketTransport">
            <summary>
            A transport implementation that can communicate with a SocketIO server.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.Close">
            <summary>
            Closes the transport and cleans up resources.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.Poll">
            <summary>
            Polling implementation. With WebSocket it's just a skeleton.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.OnOpen(BestHTTP.WebSocket.WebSocket)">
            <summary>
            WebSocket implementation OnOpen event handler.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.OnMessage(BestHTTP.WebSocket.WebSocket,System.String)">
            <summary>
            WebSocket implementation OnMessage event handler.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.OnBinary(BestHTTP.WebSocket.WebSocket,System.Byte[])">
            <summary>
            WebSocket implementation OnBinary event handler.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.OnError(BestHTTP.WebSocket.WebSocket,System.Exception)">
            <summary>
            WebSocket implementation OnError event handler.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.OnClosed(BestHTTP.WebSocket.WebSocket,System.UInt16,System.String)">
            <summary>
            WebSocket implementation OnClosed event handler.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.Send(BestHTTP.SocketIO.Packet)">
            <summary>
            A WebSocket implementation of the packet sending.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.Send(System.Collections.Generic.List{BestHTTP.SocketIO.Packet})">
            <summary>
            A WebSocket implementation of the packet sending.
            </summary>
        </member>
        <member name="M:BestHTTP.SocketIO.Transports.WebSocketTransport.OnPacket(BestHTTP.SocketIO.Packet)">
            <summary>
            Will only process packets that need to upgrade. All other packets are passed to the Manager.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.StatisticsQueryFlags.Connections">
            <summary>
            Connection based statistics will be returned as the result of the query.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.StatisticsQueryFlags.Cache">
            <summary>
            Caching based statistics will be returned as the result of the query.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.StatisticsQueryFlags.Cookies">
            <summary>
            Cookie based statistics will be returned as the result of the query.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.StatisticsQueryFlags.All">
            <summary>
            All statistics will be returned as the result of the query.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.GeneralStatistics.Connections">
            <summary>
            Number of HTTPConnection instances
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.GeneralStatistics.ActiveConnections">
            <summary>
            Number of active connections. These connections are currently processing a request.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.GeneralStatistics.FreeConnections">
            <summary>
            Number of free connections. These connections are finished with there requests and waiting for another request or to recycle.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.GeneralStatistics.RecycledConnections">
            <summary>
            Number of recycled connections. These connections will be removed as soon as possible.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.GeneralStatistics.RequestsInQueue">
            <summary>
            Number of requests that are waiting in the queue for a free connection.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.GeneralStatistics.CacheEntityCount">
            <summary>
            Number of cached responses.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.GeneralStatistics.CacheSize">
            <summary>
            Sum size of the cached responses in bytes.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.GeneralStatistics.CookieCount">
            <summary>
            Number of cookies in the Cookie Jar.
            </summary>
        </member>
        <member name="F:BestHTTP.Statistics.GeneralStatistics.CookieJarSize">
            <summary>
            Sum size of the stored cookies in bytes.
            </summary>
        </member>
        <member name="T:BestHTTP.WebSocket.Frames.WebSocketFrameReader">
            <summary>
            Represents an incoming WebSocket Frame.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.Frames.WebSocketFrameReader.Assemble(System.Collections.Generic.List{BestHTTP.WebSocket.Frames.WebSocketFrameReader})">
            <summary>
            Assembles all fragments into a final frame. Call this on the last fragment of a frame.
            </summary>
            <param name="fragments">The list of previously downloaded and parsed fragments of the frame</param>
        </member>
        <member name="P:BestHTTP.WebSocket.Frames.WebSocketFrameReader.IsFinal">
            <summary>
            True if it's a final Frame in a sequence, or the only one.
            </summary>
        </member>
        <member name="P:BestHTTP.WebSocket.Frames.WebSocketFrameReader.Type">
            <summary>
            The type of the Frame.
            </summary>
        </member>
        <member name="P:BestHTTP.WebSocket.Frames.WebSocketFrameReader.HasMask">
            <summary>
            Indicates if there are any mask sent to decode the data.
            </summary>
        </member>
        <member name="P:BestHTTP.WebSocket.Frames.WebSocketFrameReader.Length">
            <summary>
            The length of the Data.
            </summary>
        </member>
        <member name="P:BestHTTP.WebSocket.Frames.WebSocketFrameReader.Mask">
            <summary>
            The sent byte array as a mask to decode the data.
            </summary>
        </member>
        <member name="P:BestHTTP.WebSocket.Frames.WebSocketFrameReader.Data">
            <summary>
            The decoded array of bytes.
            </summary>
        </member>
        <member name="T:BestHTTP.WebSocket.Frames.IWebSocketFrameWriter">
            <summary>
            Outgoing Frame's interface.
            The Frame Writers are helper classes to help send various kind of messages to the server.
            Each type should have its own writer.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.Frames.IWebSocketFrameWriter.Get">
            <summary>
            The final array of bytes that will be sent to the server.
            </summary>
        </member>
        <member name="P:BestHTTP.WebSocket.Frames.IWebSocketFrameWriter.Type">
            <summary>
            Type of the frame.
            </summary>
        </member>
        <member name="T:BestHTTP.WebSocket.Frames.WebSocketBinaryFrame">
            <summary>
            Denotes a binary frame. The "Payload data" is arbitrary binary data whose interpretation is solely up to the application layer. 
            This is the base class of all other frame writers, as all frame can be represented as a byte array.
            </summary>
        </member>
        <member name="T:BestHTTP.WebSocket.Frames.WebSocketTextFrame">
            <summary>
            The "Payload data" is text data encoded as UTF-8.  Note that a particular text frame might include a partial UTF-8 sequence; however, the whole message MUST contain valid UTF-8. 
            </summary>
        </member>
        <member name="T:BestHTTP.WebSocket.Frames.WebSocketContinuationFrame">
            <summary>
            A fragmented message's first frame's contain the type of the message(binary or text), all consecutive frame of that message must be a Continuation frame.
            Last of these frame's Fin bit must be 1.
            </summary>
            <example>For a text message sent as three fragments, the first fragment would have an opcode of 0x1 (text) and a FIN bit clear, 
            the second fragment would have an opcode of 0x0 (Continuation) and a FIN bit clear, 
            and the third fragment would have an opcode of 0x0 (Continuation) and a FIN bit that is set.</example>
        </member>
        <member name="T:BestHTTP.WebSocket.Frames.WebSocketPing">
            <summary>
            The Ping frame contains an opcode of 0x9. A Ping frame MAY include "Application data".
            </summary>
        </member>
        <member name="T:BestHTTP.WebSocket.Frames.WebSocketPong">
            <summary>
            A Pong frame sent in response to a Ping frame must have identical "Application data" as found in the message body of the Ping frame being replied to.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.Frames.WebSocketPong.#ctor(BestHTTP.WebSocket.Frames.WebSocketFrameReader)">
            <summary>
            A Pong frame sent in response to a Ping frame must have identical "Application data" as found in the message body of the Ping frame being replied to.
            </summary>
        </member>
        <member name="T:BestHTTP.WebSocket.Frames.WebSocketClose">
            <summary>
            The Close frame MAY contain a body (the "Application data" portion of the frame) that indicates a reason for closing, 
            such as an endpoint shutting down, an endpoint having received a frame too large, or an endpoint having received a frame that
            does not conform to the format expected by the endpoint.
            As the data is not guaranteed to be human readable, clients MUST NOT show it to end users. 
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocket.OnOpen">
            <summary>
            Called when the connection to the WebSocket server is estabilished.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocket.OnMessage">
            <summary>
            Called when a new textual message is received from the server.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocket.OnBinary">
            <summary>
            Called when a new binary message is received from the server.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocket.OnClosed">
            <summary>
            Called when the WebSocket connection is closed.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocket.OnError">
            <summary>
            Called when an error is encountered. The Exception parameter may be null.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocket.OnErrorDesc">
            <summary>
            Called when an error is encountered. The parameter will be the description of the error.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocket.OnIncompleteFrame">
            <summary>
            Called when an incomplete frame received. No attemp will be made to reassemble these fragments internally, and no reference are stored after this event to this frame.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocket.requestSent">
            <summary>
            Indicates wheter we sent out the connection request to the server.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocket.webSocket">
            <summary>
            The internal WebSocketResponse object
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocket.#ctor(System.Uri)">
            <summary>
            Creates a WebSocket instance from the given uri.
            </summary>
            <param name="uri">The uri of the WebSocket server</param>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocket.#ctor(System.Uri,System.String,System.String)">
            <summary>
            Creates a WebSocket instance from the given uri, protocol and origin.
            </summary>
            <param name="uri">The uri of the WebSocket server</param>
            <param name="origin">Servers that are not intended to process input from any web page but only for certain sites SHOULD verify the |Origin| field is an origin they expect. 
            If the origin indicated is unacceptable to the server, then it SHOULD respond to the WebSocket handshake with a reply containing HTTP 403 Forbidden status code.</param>
            <param name="protocol">The application-level protocol that the client want to use(eg. "chat", "leaderboard", etc.). Can be null or empty string if not used.</param>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocket.Open">
            <summary>
            Start the opening process.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocket.Send(System.String)">
            <summary>
            It will send the given message to the server in one frame.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocket.Send(System.Byte[])">
            <summary>
            It will send the given data to the server in one frame.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocket.Send(System.Byte[],System.UInt64,System.UInt64)">
            <summary>
            Will send count bytes from a byte array, starting from offset.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocket.Send(BestHTTP.WebSocket.Frames.IWebSocketFrameWriter)">
            <summary>
            It will send the given frame to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocket.Close">
            <summary>
            It will initiate the closing of the connection to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocket.Close(System.UInt16,System.String)">
            <summary>
            It will initiate the closing of the connection to the server sending the given code and message.
            </summary>
        </member>
        <member name="P:BestHTTP.WebSocket.WebSocket.InternalRequest">
            <summary>
            The internal HTTPRequest object.
            </summary>
        </member>
        <member name="P:BestHTTP.WebSocket.WebSocket.IsOpen">
            <summary>
            The connection to the WebSocket server is open.
            </summary>
        </member>
        <member name="P:BestHTTP.WebSocket.WebSocket.StartPingThread">
            <summary>
            Set to true to start a new thread to send Pings to the WebSocket server
            </summary>
        </member>
        <member name="P:BestHTTP.WebSocket.WebSocket.PingFrequency">
            <summary>
            The delay between two Pings in millisecs. Minimum value is 100, default is 1000.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketResponse.OnText">
            <summary>
            Called when a Text message received
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketResponse.OnBinary">
            <summary>
            Called when a Binary message received
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketResponse.OnIncompleteFrame">
            <summary>
            Called when an incomplete frame received. No attemp will be made to reassemble these fragments.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketResponse.OnClosed">
            <summary>
            Called when the connection closed.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketResponse.closeSent">
            <summary>
            True if we sent out a Close message to the server
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketResponse.closed">
            <summary>
            True if this WebSocket connection is closed
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocketResponse.Send(System.String)">
            <summary>
            It will send the given message to the server in one frame.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocketResponse.Send(System.Byte[])">
            <summary>
            It will send the given data to the server in one frame.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocketResponse.Send(System.Byte[],System.UInt64,System.UInt64)">
            <summary>
            Will send count bytes from a byte array, starting from offset.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocketResponse.Send(BestHTTP.WebSocket.Frames.IWebSocketFrameWriter)">
            <summary>
            It will send the given frame to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocketResponse.Close">
            <summary>
            It will initiate the closing of the connection to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocketResponse.Close(System.UInt16,System.String)">
            <summary>
            It will initiate the closing of the connection to the server.
            </summary>
        </member>
        <member name="M:BestHTTP.WebSocket.WebSocketResponse.BestHTTP#IProtocol#HandleEvents">
            <summary>
            Internal function to send out received messages.
            </summary>
        </member>
        <member name="P:BestHTTP.WebSocket.WebSocketResponse.IsClosed">
            <summary>
            Indicates whether the connection to the server is closed or not.
            </summary>
        </member>
        <member name="P:BestHTTP.WebSocket.WebSocketResponse.PingFrequnecy">
            <summary>
            On what frequency we have to send a ping to the server.
            </summary>
        </member>
        <member name="P:BestHTTP.WebSocket.WebSocketResponse.MaxFragmentSize">
            <summary>
            Maximum size of a fragment's payload data.
            </summary>
        </member>
        <member name="T:BestHTTP.WebSocket.WebSocketStausCodes">
            <summary>
            http://tools.ietf.org/html/rfc6455#section-7.4.1
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketStausCodes.NormalClosure">
            <summary>
            Indicates a normal closure, meaning that the purpose for which the connection was established has been fulfilled.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketStausCodes.GoingAway">
            <summary>
            Indicates that an endpoint is "going away", such as a server going down or a browser having navigated away from a page.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketStausCodes.ProtocolError">
            <summary>
            Indicates that an endpoint is terminating the connection due to a protocol error.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketStausCodes.WrongDataType">
            <summary>
            Indicates that an endpoint is terminating the connection because it has received a type of data it cannot accept
            (e.g., an endpoint that understands only text data MAY send this if it receives a binary message).
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketStausCodes.Reserved">
            <summary>
            Reserved. The specific meaning might be defined in the future.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketStausCodes.NoStatusCode">
            <summary>
            A reserved value and MUST NOT be set as a status code in a Close control frame by an endpoint.
            It is designated for use in applications expecting a status code to indicate that no status code was actually present.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketStausCodes.ClosedAbnormally">
            <summary>
            A reserved value and MUST NOT be set as a status code in a Close control frame by an endpoint.
            It is designated for use in applications expecting a status code to indicate that the connection was closed abnormally, e.g., without sending or receiving a Close control frame.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketStausCodes.DataError">
            <summary>
            Indicates that an endpoint is terminating the connection because it has received data within a message that was not consistent with the type of the message (e.g., non-UTF-8 [RFC3629] data within a text message).
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketStausCodes.PolicyError">
            <summary>
            Indicates that an endpoint is terminating the connection because it has received a message that violates its policy.
            This is a generic status code that can be returned when there is no other more suitable status code (e.g., 1003 or 1009) or if there is a need to hide specific details about the policy.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketStausCodes.TooBigMessage">
            <summary>
            Indicates that an endpoint is terminating the connection because it has received a message that is too big for it to process.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketStausCodes.ExtensionExpected">
            <summary>
            Indicates that an endpoint (client) is terminating the connection because it has expected the server to negotiate one or more extension, 
            but the server didn't return them in the response message of the WebSocket handshake.
            The list of extensions that are needed SHOULD appear in the /reason/ part of the Close frame. Note that this status code is not used by the server, because it can fail the WebSocket handshake instead.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketStausCodes.WrongRequest">
            <summary>
            Indicates that a server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.
            </summary>
        </member>
        <member name="F:BestHTTP.WebSocket.WebSocketStausCodes.TLSHandshakeError">
            <summary>
            A reserved value and MUST NOT be set as a status code in a Close control frame by an endpoint.  It is designated for use in applications expecting a status code to indicate that the connection was closed due to a failure to perform a TLS handshake (e.g., the server certificate can't be verified).
            </summary>
        </member>
    </members>
</doc>
